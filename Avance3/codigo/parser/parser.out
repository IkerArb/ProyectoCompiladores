Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programa
Rule 1     programa -> creadirprocglobal a c cancion
Rule 2     creadirprocglobal -> <empty>
Rule 3     a -> empty
Rule 4     a -> vars b
Rule 5     b -> empty
Rule 6     b -> a
Rule 7     c -> empty
Rule 8     c -> funcion d
Rule 9     d -> empty
Rule 10    d -> c
Rule 11    vars -> VAR v : tipo ;
Rule 12    v -> ID
Rule 13    funcion -> FUNC tipo ID meterfuncion ( params ) f bloque
Rule 14    meterfuncion -> <empty>
Rule 15    f -> empty
Rule 16    f -> vars g
Rule 17    g -> empty
Rule 18    g -> f
Rule 19    params -> empty
Rule 20    params -> tipo ID meterparams h
Rule 21    meterparams -> <empty>
Rule 22    h -> empty
Rule 23    h -> , params
Rule 24    i -> empty
Rule 25    i -> estatuto j
Rule 26    j -> empty
Rule 27    j -> i
Rule 28    bloque -> { i }
Rule 29    cancion -> CANCION ( CTEE ) metercancion f bloque
Rule 30    metercancion -> <empty>
Rule 31    estatuto -> asignacion
Rule 32    estatuto -> if
Rule 33    estatuto -> for
Rule 34    estatuto -> return
Rule 35    estatuto -> while
Rule 36    estatuto -> play
Rule 37    estatuto -> print
Rule 38    asignacion -> ID = neur8 k ;
Rule 39    neur8 -> <empty>
Rule 40    k -> expresion
Rule 41    k -> asiglista
Rule 42    asiglista -> NEW LIST ( )
Rule 43    if -> IF ( expresion ) neur13 bloque l ;
Rule 44    neur13 -> <empty>
Rule 45    l -> empty neur15
Rule 46    l -> ELSE neur14 bloque
Rule 47    neur14 -> <empty>
Rule 48    neur15 -> <empty>
Rule 49    for -> FOR ( asignacion expresion asignacion ) bloque ;
Rule 50    expresion -> m subexpresion
Rule 51    m -> empty
Rule 52    m -> NOT
Rule 53    subexpresion -> exp neur10 o
Rule 54    neur10 -> <empty>
Rule 55    o -> empty
Rule 56    o -> AND neur9_1 subexpresion
Rule 57    o -> OR neur9_2 subexpresion
Rule 58    neur9_1 -> <empty>
Rule 59    neur9_2 -> <empty>
Rule 60    exp -> nexp p neur12
Rule 61    neur12 -> <empty>
Rule 62    p -> empty
Rule 63    p -> EQ neur11_1 nexp
Rule 64    p -> NOTEQ neur11_2 nexp
Rule 65    p -> > neur11_3 nexp
Rule 66    p -> < neur11_4 nexp
Rule 67    p -> MTHANEQ neur11_5 nexp
Rule 68    p -> LTHANEQ neur11_6 nexp
Rule 69    neur11_1 -> <empty>
Rule 70    neur11_2 -> <empty>
Rule 71    neur11_3 -> <empty>
Rule 72    neur11_4 -> <empty>
Rule 73    neur11_5 -> <empty>
Rule 74    neur11_6 -> <empty>
Rule 75    nexp -> termino neur5 q
Rule 76    neur5 -> <empty>
Rule 77    q -> empty
Rule 78    q -> + neur3_1 nexp
Rule 79    q -> - neur3_2 nexp
Rule 80    neur3_1 -> <empty>
Rule 81    neur3_2 -> <empty>
Rule 82    termino -> factor neur4 n
Rule 83    neur4 -> <empty>
Rule 84    n -> empty
Rule 85    n -> * neur2_1 termino
Rule 86    n -> / neur2_2 termino
Rule 87    neur2_1 -> <empty>
Rule 88    neur2_2 -> <empty>
Rule 89    factor -> ( neur6 expresion ) neur7
Rule 90    factor -> varcte neur1
Rule 91    neur6 -> <empty>
Rule 92    neur7 -> <empty>
Rule 93    neur1 -> <empty>
Rule 94    varcte -> ID r neurVar
Rule 95    varcte -> CTEE neurCteE
Rule 96    varcte -> CTEF neurCteF
Rule 97    varcte -> CTEBOOL neurCteB
Rule 98    varcte -> callfunc
Rule 99    varcte -> CTECHAR neurCteCh
Rule 100   neurVar -> <empty>
Rule 101   neurCteE -> <empty>
Rule 102   neurCteF -> <empty>
Rule 103   neurCteB -> <empty>
Rule 104   neurCteCh -> <empty>
Rule 105   r -> empty
Rule 106   r -> oplista
Rule 107   oplista -> ID . x
Rule 108   x -> inlistset
Rule 109   x -> append
Rule 110   x -> length
Rule 111   x -> getlist
Rule 112   x -> removelist
Rule 113   inlistset -> SET ( CTEE , expresion )
Rule 114   append -> APPEND ( expresion )
Rule 115   length -> LENGTH ( )
Rule 116   getlist -> GET ( expresion )
Rule 117   removelist -> REMOVE ( expresion )
Rule 118   while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ;
Rule 119   neur16 -> <empty>
Rule 120   neur17 -> <empty>
Rule 121   play -> PLAY ( NOTA , CTEE ) ;
Rule 122   print -> PRINT expresion ;
Rule 123   callfunc -> CALL ID ( s ) ;
Rule 124   s -> empty
Rule 125   s -> expresion t
Rule 126   t -> empty
Rule 127   t -> , s
Rule 128   return -> RETURN ( expresion ) ;
Rule 129   tipo -> u y
Rule 130   u -> empty
Rule 131   u -> LIST
Rule 132   y -> INT
Rule 133   y -> CHAR
Rule 134   y -> FLOAT
Rule 135   y -> BOOL
Rule 136   empty -> <empty>

Terminals, with rules where they appear

(                    : 13 29 42 43 49 89 113 114 115 116 117 118 121 123 128
)                    : 13 29 42 43 49 89 113 114 115 116 117 118 121 123 128
*                    : 85
+                    : 78
,                    : 23 113 121 127
-                    : 79
.                    : 107
/                    : 86
:                    : 11
;                    : 11 38 43 49 118 121 122 123 128
<                    : 66
=                    : 38
>                    : 65
AND                  : 56
APPEND               : 114
BOOL                 : 135
CALL                 : 123
CANCION              : 29
CHAR                 : 133
CTEBOOL              : 97
CTECHAR              : 99
CTEE                 : 29 95 113 121
CTEF                 : 96
ELSE                 : 46
EQ                   : 63
FLOAT                : 134
FOR                  : 49
FUNC                 : 13
GET                  : 116
ID                   : 12 13 20 38 94 107 123
IF                   : 43
INT                  : 132
LENGTH               : 115
LIST                 : 42 131
LTHANEQ              : 68
MTHANEQ              : 67
NEW                  : 42
NOT                  : 52
NOTA                 : 121
NOTEQ                : 64
OR                   : 57
PLAY                 : 121
PRINT                : 122
REMOVE               : 117
RETURN               : 128
SET                  : 113
VAR                  : 11
WHILE                : 118
error                : 
{                    : 28
}                    : 28

Nonterminals, with rules where they appear

a                    : 1 6
append               : 109
asiglista            : 41
asignacion           : 31 49 49
b                    : 4
bloque               : 13 29 43 46 49 118
c                    : 1 10
callfunc             : 98
cancion              : 1
creadirprocglobal    : 1
d                    : 8
empty                : 3 5 7 9 15 17 19 22 24 26 45 51 55 62 77 84 105 124 126 130
estatuto             : 25
exp                  : 53
expresion            : 40 43 49 89 113 114 116 117 118 122 125 128
f                    : 13 18 29
factor               : 82
for                  : 33
funcion              : 8
g                    : 16
getlist              : 111
h                    : 20
i                    : 27 28
if                   : 32
inlistset            : 108
j                    : 25
k                    : 38
l                    : 43
length               : 110
m                    : 50
metercancion         : 29
meterfuncion         : 13
meterparams          : 20
n                    : 82
neur1                : 90
neur10               : 53
neur11_1             : 63
neur11_2             : 64
neur11_3             : 65
neur11_4             : 66
neur11_5             : 67
neur11_6             : 68
neur12               : 60
neur13               : 43 118
neur14               : 46
neur15               : 45
neur16               : 118
neur17               : 118
neur2_1              : 85
neur2_2              : 86
neur3_1              : 78
neur3_2              : 79
neur4                : 82
neur5                : 75
neur6                : 89
neur7                : 89
neur8                : 38
neur9_1              : 56
neur9_2              : 57
neurCteB             : 97
neurCteCh            : 99
neurCteE             : 95
neurCteF             : 96
neurVar              : 94
nexp                 : 60 63 64 65 66 67 68 78 79
o                    : 53
oplista              : 106
p                    : 60
params               : 13 23
play                 : 36
print                : 37
programa             : 0
q                    : 75
r                    : 94
removelist           : 112
return               : 34
s                    : 123 127
subexpresion         : 50 56 57
t                    : 125
termino              : 75 85 86
tipo                 : 11 13 20
u                    : 129
v                    : 11
varcte               : 90
vars                 : 4 16
while                : 35
x                    : 107
y                    : 129

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . creadirprocglobal a c cancion
    (2) creadirprocglobal -> .

    VAR             reduce using rule 2 (creadirprocglobal -> .)
    FUNC            reduce using rule 2 (creadirprocglobal -> .)
    CANCION         reduce using rule 2 (creadirprocglobal -> .)

    programa                       shift and go to state 1
    creadirprocglobal              shift and go to state 2

state 1

    (0) S' -> programa .



state 2

    (1) programa -> creadirprocglobal . a c cancion
    (3) a -> . empty
    (4) a -> . vars b
    (136) empty -> .
    (11) vars -> . VAR v : tipo ;

    FUNC            reduce using rule 136 (empty -> .)
    CANCION         reduce using rule 136 (empty -> .)
    VAR             shift and go to state 5

    a                              shift and go to state 3
    vars                           shift and go to state 4
    empty                          shift and go to state 6

state 3

    (1) programa -> creadirprocglobal a . c cancion
    (7) c -> . empty
    (8) c -> . funcion d
    (136) empty -> .
    (13) funcion -> . FUNC tipo ID meterfuncion ( params ) f bloque

    CANCION         reduce using rule 136 (empty -> .)
    FUNC            shift and go to state 8

    c                              shift and go to state 7
    empty                          shift and go to state 9
    funcion                        shift and go to state 10

state 4

    (4) a -> vars . b
    (5) b -> . empty
    (6) b -> . a
    (136) empty -> .
    (3) a -> . empty
    (4) a -> . vars b
    (11) vars -> . VAR v : tipo ;

    FUNC            reduce using rule 136 (empty -> .)
    CANCION         reduce using rule 136 (empty -> .)
    VAR             shift and go to state 5

    a                              shift and go to state 11
    b                              shift and go to state 12
    vars                           shift and go to state 4
    empty                          shift and go to state 13

state 5

    (11) vars -> VAR . v : tipo ;
    (12) v -> . ID

    ID              shift and go to state 15

    v                              shift and go to state 14

state 6

    (3) a -> empty .

    FUNC            reduce using rule 3 (a -> empty .)
    CANCION         reduce using rule 3 (a -> empty .)


state 7

    (1) programa -> creadirprocglobal a c . cancion
    (29) cancion -> . CANCION ( CTEE ) metercancion f bloque

    CANCION         shift and go to state 16

    cancion                        shift and go to state 17

state 8

    (13) funcion -> FUNC . tipo ID meterfuncion ( params ) f bloque
    (129) tipo -> . u y
    (130) u -> . empty
    (131) u -> . LIST
    (136) empty -> .

    LIST            shift and go to state 19
    INT             reduce using rule 136 (empty -> .)
    CHAR            reduce using rule 136 (empty -> .)
    FLOAT           reduce using rule 136 (empty -> .)
    BOOL            reduce using rule 136 (empty -> .)

    tipo                           shift and go to state 18
    u                              shift and go to state 20
    empty                          shift and go to state 21

state 9

    (7) c -> empty .

    CANCION         reduce using rule 7 (c -> empty .)


state 10

    (8) c -> funcion . d
    (9) d -> . empty
    (10) d -> . c
    (136) empty -> .
    (7) c -> . empty
    (8) c -> . funcion d
    (13) funcion -> . FUNC tipo ID meterfuncion ( params ) f bloque

    CANCION         reduce using rule 136 (empty -> .)
    FUNC            shift and go to state 8

    c                              shift and go to state 22
    d                              shift and go to state 23
    empty                          shift and go to state 24
    funcion                        shift and go to state 10

state 11

    (6) b -> a .

    FUNC            reduce using rule 6 (b -> a .)
    CANCION         reduce using rule 6 (b -> a .)


state 12

    (4) a -> vars b .

    FUNC            reduce using rule 4 (a -> vars b .)
    CANCION         reduce using rule 4 (a -> vars b .)


state 13

    (5) b -> empty .
    (3) a -> empty .

  ! reduce/reduce conflict for FUNC resolved using rule 3 (a -> empty .)
  ! reduce/reduce conflict for CANCION resolved using rule 3 (a -> empty .)
    FUNC            reduce using rule 3 (a -> empty .)
    CANCION         reduce using rule 3 (a -> empty .)

  ! FUNC            [ reduce using rule 5 (b -> empty .) ]
  ! CANCION         [ reduce using rule 5 (b -> empty .) ]


state 14

    (11) vars -> VAR v . : tipo ;

    :               shift and go to state 25


state 15

    (12) v -> ID .

    :               reduce using rule 12 (v -> ID .)


state 16

    (29) cancion -> CANCION . ( CTEE ) metercancion f bloque

    (               shift and go to state 26


state 17

    (1) programa -> creadirprocglobal a c cancion .

    $end            reduce using rule 1 (programa -> creadirprocglobal a c cancion .)


state 18

    (13) funcion -> FUNC tipo . ID meterfuncion ( params ) f bloque

    ID              shift and go to state 27


state 19

    (131) u -> LIST .

    INT             reduce using rule 131 (u -> LIST .)
    CHAR            reduce using rule 131 (u -> LIST .)
    FLOAT           reduce using rule 131 (u -> LIST .)
    BOOL            reduce using rule 131 (u -> LIST .)


state 20

    (129) tipo -> u . y
    (132) y -> . INT
    (133) y -> . CHAR
    (134) y -> . FLOAT
    (135) y -> . BOOL

    INT             shift and go to state 28
    CHAR            shift and go to state 30
    FLOAT           shift and go to state 29
    BOOL            shift and go to state 32

    y                              shift and go to state 31

state 21

    (130) u -> empty .

    INT             reduce using rule 130 (u -> empty .)
    CHAR            reduce using rule 130 (u -> empty .)
    FLOAT           reduce using rule 130 (u -> empty .)
    BOOL            reduce using rule 130 (u -> empty .)


state 22

    (10) d -> c .

    CANCION         reduce using rule 10 (d -> c .)


state 23

    (8) c -> funcion d .

    CANCION         reduce using rule 8 (c -> funcion d .)


state 24

    (9) d -> empty .
    (7) c -> empty .

  ! reduce/reduce conflict for CANCION resolved using rule 7 (c -> empty .)
    CANCION         reduce using rule 7 (c -> empty .)

  ! CANCION         [ reduce using rule 9 (d -> empty .) ]


state 25

    (11) vars -> VAR v : . tipo ;
    (129) tipo -> . u y
    (130) u -> . empty
    (131) u -> . LIST
    (136) empty -> .

    LIST            shift and go to state 19
    INT             reduce using rule 136 (empty -> .)
    CHAR            reduce using rule 136 (empty -> .)
    FLOAT           reduce using rule 136 (empty -> .)
    BOOL            reduce using rule 136 (empty -> .)

    u                              shift and go to state 20
    empty                          shift and go to state 21
    tipo                           shift and go to state 33

state 26

    (29) cancion -> CANCION ( . CTEE ) metercancion f bloque

    CTEE            shift and go to state 34


state 27

    (13) funcion -> FUNC tipo ID . meterfuncion ( params ) f bloque
    (14) meterfuncion -> .

    (               reduce using rule 14 (meterfuncion -> .)

    meterfuncion                   shift and go to state 35

state 28

    (132) y -> INT .

    ID              reduce using rule 132 (y -> INT .)
    ;               reduce using rule 132 (y -> INT .)


state 29

    (134) y -> FLOAT .

    ID              reduce using rule 134 (y -> FLOAT .)
    ;               reduce using rule 134 (y -> FLOAT .)


state 30

    (133) y -> CHAR .

    ID              reduce using rule 133 (y -> CHAR .)
    ;               reduce using rule 133 (y -> CHAR .)


state 31

    (129) tipo -> u y .

    ID              reduce using rule 129 (tipo -> u y .)
    ;               reduce using rule 129 (tipo -> u y .)


state 32

    (135) y -> BOOL .

    ID              reduce using rule 135 (y -> BOOL .)
    ;               reduce using rule 135 (y -> BOOL .)


state 33

    (11) vars -> VAR v : tipo . ;

    ;               shift and go to state 36


state 34

    (29) cancion -> CANCION ( CTEE . ) metercancion f bloque

    )               shift and go to state 37


state 35

    (13) funcion -> FUNC tipo ID meterfuncion . ( params ) f bloque

    (               shift and go to state 38


state 36

    (11) vars -> VAR v : tipo ; .

    VAR             reduce using rule 11 (vars -> VAR v : tipo ; .)
    FUNC            reduce using rule 11 (vars -> VAR v : tipo ; .)
    CANCION         reduce using rule 11 (vars -> VAR v : tipo ; .)
    {               reduce using rule 11 (vars -> VAR v : tipo ; .)


state 37

    (29) cancion -> CANCION ( CTEE ) . metercancion f bloque
    (30) metercancion -> .

    VAR             reduce using rule 30 (metercancion -> .)
    {               reduce using rule 30 (metercancion -> .)

    metercancion                   shift and go to state 39

state 38

    (13) funcion -> FUNC tipo ID meterfuncion ( . params ) f bloque
    (19) params -> . empty
    (20) params -> . tipo ID meterparams h
    (136) empty -> .
    (129) tipo -> . u y
    (130) u -> . empty
    (131) u -> . LIST

    )               reduce using rule 136 (empty -> .)
    INT             reduce using rule 136 (empty -> .)
    CHAR            reduce using rule 136 (empty -> .)
    FLOAT           reduce using rule 136 (empty -> .)
    BOOL            reduce using rule 136 (empty -> .)
    LIST            shift and go to state 19

    tipo                           shift and go to state 40
    params                         shift and go to state 41
    u                              shift and go to state 20
    empty                          shift and go to state 42

state 39

    (29) cancion -> CANCION ( CTEE ) metercancion . f bloque
    (15) f -> . empty
    (16) f -> . vars g
    (136) empty -> .
    (11) vars -> . VAR v : tipo ;

    {               reduce using rule 136 (empty -> .)
    VAR             shift and go to state 5

    vars                           shift and go to state 43
    f                              shift and go to state 44
    empty                          shift and go to state 45

state 40

    (20) params -> tipo . ID meterparams h

    ID              shift and go to state 46


state 41

    (13) funcion -> FUNC tipo ID meterfuncion ( params . ) f bloque

    )               shift and go to state 47


state 42

    (19) params -> empty .
    (130) u -> empty .

    )               reduce using rule 19 (params -> empty .)
    INT             reduce using rule 130 (u -> empty .)
    CHAR            reduce using rule 130 (u -> empty .)
    FLOAT           reduce using rule 130 (u -> empty .)
    BOOL            reduce using rule 130 (u -> empty .)


state 43

    (16) f -> vars . g
    (17) g -> . empty
    (18) g -> . f
    (136) empty -> .
    (15) f -> . empty
    (16) f -> . vars g
    (11) vars -> . VAR v : tipo ;

    {               reduce using rule 136 (empty -> .)
    VAR             shift and go to state 5

    g                              shift and go to state 48
    f                              shift and go to state 49
    vars                           shift and go to state 43
    empty                          shift and go to state 50

state 44

    (29) cancion -> CANCION ( CTEE ) metercancion f . bloque
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 52

state 45

    (15) f -> empty .

    {               reduce using rule 15 (f -> empty .)


state 46

    (20) params -> tipo ID . meterparams h
    (21) meterparams -> .

    ,               reduce using rule 21 (meterparams -> .)
    )               reduce using rule 21 (meterparams -> .)

    meterparams                    shift and go to state 53

state 47

    (13) funcion -> FUNC tipo ID meterfuncion ( params ) . f bloque
    (15) f -> . empty
    (16) f -> . vars g
    (136) empty -> .
    (11) vars -> . VAR v : tipo ;

    {               reduce using rule 136 (empty -> .)
    VAR             shift and go to state 5

    vars                           shift and go to state 43
    f                              shift and go to state 54
    empty                          shift and go to state 45

state 48

    (16) f -> vars g .

    {               reduce using rule 16 (f -> vars g .)


state 49

    (18) g -> f .

    {               reduce using rule 18 (g -> f .)


state 50

    (17) g -> empty .
    (15) f -> empty .

  ! reduce/reduce conflict for { resolved using rule 15 (f -> empty .)
    {               reduce using rule 15 (f -> empty .)

  ! {               [ reduce using rule 17 (g -> empty .) ]


state 51

    (28) bloque -> { . i }
    (24) i -> . empty
    (25) i -> . estatuto j
    (136) empty -> .
    (31) estatuto -> . asignacion
    (32) estatuto -> . if
    (33) estatuto -> . for
    (34) estatuto -> . return
    (35) estatuto -> . while
    (36) estatuto -> . play
    (37) estatuto -> . print
    (38) asignacion -> . ID = neur8 k ;
    (43) if -> . IF ( expresion ) neur13 bloque l ;
    (49) for -> . FOR ( asignacion expresion asignacion ) bloque ;
    (128) return -> . RETURN ( expresion ) ;
    (118) while -> . WHILE ( neur16 expresion ) neur13 bloque neur17 ;
    (121) play -> . PLAY ( NOTA , CTEE ) ;
    (122) print -> . PRINT expresion ;

    }               reduce using rule 136 (empty -> .)
    ID              shift and go to state 67
    IF              shift and go to state 68
    FOR             shift and go to state 66
    RETURN          shift and go to state 55
    WHILE           shift and go to state 57
    PLAY            shift and go to state 56
    PRINT           shift and go to state 58

    play                           shift and go to state 64
    return                         shift and go to state 65
    for                            shift and go to state 60
    asignacion                     shift and go to state 69
    i                              shift and go to state 70
    estatuto                       shift and go to state 61
    while                          shift and go to state 71
    print                          shift and go to state 62
    empty                          shift and go to state 63
    if                             shift and go to state 59

state 52

    (29) cancion -> CANCION ( CTEE ) metercancion f bloque .

    $end            reduce using rule 29 (cancion -> CANCION ( CTEE ) metercancion f bloque .)


state 53

    (20) params -> tipo ID meterparams . h
    (22) h -> . empty
    (23) h -> . , params
    (136) empty -> .

    ,               shift and go to state 73
    )               reduce using rule 136 (empty -> .)

    h                              shift and go to state 72
    empty                          shift and go to state 74

state 54

    (13) funcion -> FUNC tipo ID meterfuncion ( params ) f . bloque
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 75

state 55

    (128) return -> RETURN . ( expresion ) ;

    (               shift and go to state 76


state 56

    (121) play -> PLAY . ( NOTA , CTEE ) ;

    (               shift and go to state 77


state 57

    (118) while -> WHILE . ( neur16 expresion ) neur13 bloque neur17 ;

    (               shift and go to state 78


state 58

    (122) print -> PRINT . expresion ;
    (50) expresion -> . m subexpresion
    (51) m -> . empty
    (52) m -> . NOT
    (136) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    CTEE            reduce using rule 136 (empty -> .)
    CTEF            reduce using rule 136 (empty -> .)
    CTEBOOL         reduce using rule 136 (empty -> .)
    CTECHAR         reduce using rule 136 (empty -> .)
    CALL            reduce using rule 136 (empty -> .)

    expresion                      shift and go to state 79
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 59

    (32) estatuto -> if .

    ID              reduce using rule 32 (estatuto -> if .)
    IF              reduce using rule 32 (estatuto -> if .)
    FOR             reduce using rule 32 (estatuto -> if .)
    RETURN          reduce using rule 32 (estatuto -> if .)
    WHILE           reduce using rule 32 (estatuto -> if .)
    PLAY            reduce using rule 32 (estatuto -> if .)
    PRINT           reduce using rule 32 (estatuto -> if .)
    }               reduce using rule 32 (estatuto -> if .)


state 60

    (33) estatuto -> for .

    ID              reduce using rule 33 (estatuto -> for .)
    IF              reduce using rule 33 (estatuto -> for .)
    FOR             reduce using rule 33 (estatuto -> for .)
    RETURN          reduce using rule 33 (estatuto -> for .)
    WHILE           reduce using rule 33 (estatuto -> for .)
    PLAY            reduce using rule 33 (estatuto -> for .)
    PRINT           reduce using rule 33 (estatuto -> for .)
    }               reduce using rule 33 (estatuto -> for .)


state 61

    (25) i -> estatuto . j
    (26) j -> . empty
    (27) j -> . i
    (136) empty -> .
    (24) i -> . empty
    (25) i -> . estatuto j
    (31) estatuto -> . asignacion
    (32) estatuto -> . if
    (33) estatuto -> . for
    (34) estatuto -> . return
    (35) estatuto -> . while
    (36) estatuto -> . play
    (37) estatuto -> . print
    (38) asignacion -> . ID = neur8 k ;
    (43) if -> . IF ( expresion ) neur13 bloque l ;
    (49) for -> . FOR ( asignacion expresion asignacion ) bloque ;
    (128) return -> . RETURN ( expresion ) ;
    (118) while -> . WHILE ( neur16 expresion ) neur13 bloque neur17 ;
    (121) play -> . PLAY ( NOTA , CTEE ) ;
    (122) print -> . PRINT expresion ;

    }               reduce using rule 136 (empty -> .)
    ID              shift and go to state 67
    IF              shift and go to state 68
    FOR             shift and go to state 66
    RETURN          shift and go to state 55
    WHILE           shift and go to state 57
    PLAY            shift and go to state 56
    PRINT           shift and go to state 58

    play                           shift and go to state 64
    j                              shift and go to state 85
    return                         shift and go to state 65
    for                            shift and go to state 60
    asignacion                     shift and go to state 69
    i                              shift and go to state 84
    estatuto                       shift and go to state 61
    while                          shift and go to state 71
    print                          shift and go to state 62
    empty                          shift and go to state 83
    if                             shift and go to state 59

state 62

    (37) estatuto -> print .

    ID              reduce using rule 37 (estatuto -> print .)
    IF              reduce using rule 37 (estatuto -> print .)
    FOR             reduce using rule 37 (estatuto -> print .)
    RETURN          reduce using rule 37 (estatuto -> print .)
    WHILE           reduce using rule 37 (estatuto -> print .)
    PLAY            reduce using rule 37 (estatuto -> print .)
    PRINT           reduce using rule 37 (estatuto -> print .)
    }               reduce using rule 37 (estatuto -> print .)


state 63

    (24) i -> empty .

    }               reduce using rule 24 (i -> empty .)


state 64

    (36) estatuto -> play .

    ID              reduce using rule 36 (estatuto -> play .)
    IF              reduce using rule 36 (estatuto -> play .)
    FOR             reduce using rule 36 (estatuto -> play .)
    RETURN          reduce using rule 36 (estatuto -> play .)
    WHILE           reduce using rule 36 (estatuto -> play .)
    PLAY            reduce using rule 36 (estatuto -> play .)
    PRINT           reduce using rule 36 (estatuto -> play .)
    }               reduce using rule 36 (estatuto -> play .)


state 65

    (34) estatuto -> return .

    ID              reduce using rule 34 (estatuto -> return .)
    IF              reduce using rule 34 (estatuto -> return .)
    FOR             reduce using rule 34 (estatuto -> return .)
    RETURN          reduce using rule 34 (estatuto -> return .)
    WHILE           reduce using rule 34 (estatuto -> return .)
    PLAY            reduce using rule 34 (estatuto -> return .)
    PRINT           reduce using rule 34 (estatuto -> return .)
    }               reduce using rule 34 (estatuto -> return .)


state 66

    (49) for -> FOR . ( asignacion expresion asignacion ) bloque ;

    (               shift and go to state 86


state 67

    (38) asignacion -> ID . = neur8 k ;

    =               shift and go to state 87


state 68

    (43) if -> IF . ( expresion ) neur13 bloque l ;

    (               shift and go to state 88


state 69

    (31) estatuto -> asignacion .

    ID              reduce using rule 31 (estatuto -> asignacion .)
    IF              reduce using rule 31 (estatuto -> asignacion .)
    FOR             reduce using rule 31 (estatuto -> asignacion .)
    RETURN          reduce using rule 31 (estatuto -> asignacion .)
    WHILE           reduce using rule 31 (estatuto -> asignacion .)
    PLAY            reduce using rule 31 (estatuto -> asignacion .)
    PRINT           reduce using rule 31 (estatuto -> asignacion .)
    }               reduce using rule 31 (estatuto -> asignacion .)


state 70

    (28) bloque -> { i . }

    }               shift and go to state 89


state 71

    (35) estatuto -> while .

    ID              reduce using rule 35 (estatuto -> while .)
    IF              reduce using rule 35 (estatuto -> while .)
    FOR             reduce using rule 35 (estatuto -> while .)
    RETURN          reduce using rule 35 (estatuto -> while .)
    WHILE           reduce using rule 35 (estatuto -> while .)
    PLAY            reduce using rule 35 (estatuto -> while .)
    PRINT           reduce using rule 35 (estatuto -> while .)
    }               reduce using rule 35 (estatuto -> while .)


state 72

    (20) params -> tipo ID meterparams h .

    )               reduce using rule 20 (params -> tipo ID meterparams h .)


state 73

    (23) h -> , . params
    (19) params -> . empty
    (20) params -> . tipo ID meterparams h
    (136) empty -> .
    (129) tipo -> . u y
    (130) u -> . empty
    (131) u -> . LIST

    )               reduce using rule 136 (empty -> .)
    INT             reduce using rule 136 (empty -> .)
    CHAR            reduce using rule 136 (empty -> .)
    FLOAT           reduce using rule 136 (empty -> .)
    BOOL            reduce using rule 136 (empty -> .)
    LIST            shift and go to state 19

    tipo                           shift and go to state 40
    u                              shift and go to state 20
    params                         shift and go to state 90
    empty                          shift and go to state 42

state 74

    (22) h -> empty .

    )               reduce using rule 22 (h -> empty .)


state 75

    (13) funcion -> FUNC tipo ID meterfuncion ( params ) f bloque .

    FUNC            reduce using rule 13 (funcion -> FUNC tipo ID meterfuncion ( params ) f bloque .)
    CANCION         reduce using rule 13 (funcion -> FUNC tipo ID meterfuncion ( params ) f bloque .)


state 76

    (128) return -> RETURN ( . expresion ) ;
    (50) expresion -> . m subexpresion
    (51) m -> . empty
    (52) m -> . NOT
    (136) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    CTEE            reduce using rule 136 (empty -> .)
    CTEF            reduce using rule 136 (empty -> .)
    CTEBOOL         reduce using rule 136 (empty -> .)
    CTECHAR         reduce using rule 136 (empty -> .)
    CALL            reduce using rule 136 (empty -> .)

    expresion                      shift and go to state 91
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 77

    (121) play -> PLAY ( . NOTA , CTEE ) ;

    NOTA            shift and go to state 92


state 78

    (118) while -> WHILE ( . neur16 expresion ) neur13 bloque neur17 ;
    (119) neur16 -> .

    NOT             reduce using rule 119 (neur16 -> .)
    (               reduce using rule 119 (neur16 -> .)
    ID              reduce using rule 119 (neur16 -> .)
    CTEE            reduce using rule 119 (neur16 -> .)
    CTEF            reduce using rule 119 (neur16 -> .)
    CTEBOOL         reduce using rule 119 (neur16 -> .)
    CTECHAR         reduce using rule 119 (neur16 -> .)
    CALL            reduce using rule 119 (neur16 -> .)

    neur16                         shift and go to state 93

state 79

    (122) print -> PRINT expresion . ;

    ;               shift and go to state 94


state 80

    (50) expresion -> m . subexpresion
    (53) subexpresion -> . exp neur10 o
    (60) exp -> . nexp p neur12
    (75) nexp -> . termino neur5 q
    (82) termino -> . factor neur4 n
    (89) factor -> . ( neur6 expresion ) neur7
    (90) factor -> . varcte neur1
    (94) varcte -> . ID r neurVar
    (95) varcte -> . CTEE neurCteE
    (96) varcte -> . CTEF neurCteF
    (97) varcte -> . CTEBOOL neurCteB
    (98) varcte -> . callfunc
    (99) varcte -> . CTECHAR neurCteCh
    (123) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    termino                        shift and go to state 95
    varcte                         shift and go to state 97
    nexp                           shift and go to state 99
    factor                         shift and go to state 100
    subexpresion                   shift and go to state 102
    callfunc                       shift and go to state 105
    exp                            shift and go to state 107

state 81

    (52) m -> NOT .

    (               reduce using rule 52 (m -> NOT .)
    ID              reduce using rule 52 (m -> NOT .)
    CTEE            reduce using rule 52 (m -> NOT .)
    CTEF            reduce using rule 52 (m -> NOT .)
    CTEBOOL         reduce using rule 52 (m -> NOT .)
    CTECHAR         reduce using rule 52 (m -> NOT .)
    CALL            reduce using rule 52 (m -> NOT .)


state 82

    (51) m -> empty .

    (               reduce using rule 51 (m -> empty .)
    ID              reduce using rule 51 (m -> empty .)
    CTEE            reduce using rule 51 (m -> empty .)
    CTEF            reduce using rule 51 (m -> empty .)
    CTEBOOL         reduce using rule 51 (m -> empty .)
    CTECHAR         reduce using rule 51 (m -> empty .)
    CALL            reduce using rule 51 (m -> empty .)


state 83

    (26) j -> empty .
    (24) i -> empty .

  ! reduce/reduce conflict for } resolved using rule 24 (i -> empty .)
    }               reduce using rule 24 (i -> empty .)

  ! }               [ reduce using rule 26 (j -> empty .) ]


state 84

    (27) j -> i .

    }               reduce using rule 27 (j -> i .)


state 85

    (25) i -> estatuto j .

    }               reduce using rule 25 (i -> estatuto j .)


state 86

    (49) for -> FOR ( . asignacion expresion asignacion ) bloque ;
    (38) asignacion -> . ID = neur8 k ;

    ID              shift and go to state 67

    asignacion                     shift and go to state 109

state 87

    (38) asignacion -> ID = . neur8 k ;
    (39) neur8 -> .

    NEW             reduce using rule 39 (neur8 -> .)
    NOT             reduce using rule 39 (neur8 -> .)
    (               reduce using rule 39 (neur8 -> .)
    ID              reduce using rule 39 (neur8 -> .)
    CTEE            reduce using rule 39 (neur8 -> .)
    CTEF            reduce using rule 39 (neur8 -> .)
    CTEBOOL         reduce using rule 39 (neur8 -> .)
    CTECHAR         reduce using rule 39 (neur8 -> .)
    CALL            reduce using rule 39 (neur8 -> .)

    neur8                          shift and go to state 110

state 88

    (43) if -> IF ( . expresion ) neur13 bloque l ;
    (50) expresion -> . m subexpresion
    (51) m -> . empty
    (52) m -> . NOT
    (136) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    CTEE            reduce using rule 136 (empty -> .)
    CTEF            reduce using rule 136 (empty -> .)
    CTEBOOL         reduce using rule 136 (empty -> .)
    CTECHAR         reduce using rule 136 (empty -> .)
    CALL            reduce using rule 136 (empty -> .)

    expresion                      shift and go to state 111
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 89

    (28) bloque -> { i } .

    ;               reduce using rule 28 (bloque -> { i } .)
    $end            reduce using rule 28 (bloque -> { i } .)
    ELSE            reduce using rule 28 (bloque -> { i } .)
    FUNC            reduce using rule 28 (bloque -> { i } .)
    CANCION         reduce using rule 28 (bloque -> { i } .)


state 90

    (23) h -> , params .

    )               reduce using rule 23 (h -> , params .)


state 91

    (128) return -> RETURN ( expresion . ) ;

    )               shift and go to state 112


state 92

    (121) play -> PLAY ( NOTA . , CTEE ) ;

    ,               shift and go to state 113


state 93

    (118) while -> WHILE ( neur16 . expresion ) neur13 bloque neur17 ;
    (50) expresion -> . m subexpresion
    (51) m -> . empty
    (52) m -> . NOT
    (136) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    CTEE            reduce using rule 136 (empty -> .)
    CTEF            reduce using rule 136 (empty -> .)
    CTEBOOL         reduce using rule 136 (empty -> .)
    CTECHAR         reduce using rule 136 (empty -> .)
    CALL            reduce using rule 136 (empty -> .)

    expresion                      shift and go to state 114
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 94

    (122) print -> PRINT expresion ; .

    ID              reduce using rule 122 (print -> PRINT expresion ; .)
    IF              reduce using rule 122 (print -> PRINT expresion ; .)
    FOR             reduce using rule 122 (print -> PRINT expresion ; .)
    RETURN          reduce using rule 122 (print -> PRINT expresion ; .)
    WHILE           reduce using rule 122 (print -> PRINT expresion ; .)
    PLAY            reduce using rule 122 (print -> PRINT expresion ; .)
    PRINT           reduce using rule 122 (print -> PRINT expresion ; .)
    }               reduce using rule 122 (print -> PRINT expresion ; .)


state 95

    (75) nexp -> termino . neur5 q
    (76) neur5 -> .

    +               reduce using rule 76 (neur5 -> .)
    -               reduce using rule 76 (neur5 -> .)
    EQ              reduce using rule 76 (neur5 -> .)
    NOTEQ           reduce using rule 76 (neur5 -> .)
    >               reduce using rule 76 (neur5 -> .)
    <               reduce using rule 76 (neur5 -> .)
    MTHANEQ         reduce using rule 76 (neur5 -> .)
    LTHANEQ         reduce using rule 76 (neur5 -> .)
    AND             reduce using rule 76 (neur5 -> .)
    OR              reduce using rule 76 (neur5 -> .)
    ;               reduce using rule 76 (neur5 -> .)
    )               reduce using rule 76 (neur5 -> .)
    ID              reduce using rule 76 (neur5 -> .)
    ,               reduce using rule 76 (neur5 -> .)

    neur5                          shift and go to state 115

state 96

    (99) varcte -> CTECHAR . neurCteCh
    (104) neurCteCh -> .

    *               reduce using rule 104 (neurCteCh -> .)
    /               reduce using rule 104 (neurCteCh -> .)
    +               reduce using rule 104 (neurCteCh -> .)
    -               reduce using rule 104 (neurCteCh -> .)
    EQ              reduce using rule 104 (neurCteCh -> .)
    NOTEQ           reduce using rule 104 (neurCteCh -> .)
    >               reduce using rule 104 (neurCteCh -> .)
    <               reduce using rule 104 (neurCteCh -> .)
    MTHANEQ         reduce using rule 104 (neurCteCh -> .)
    LTHANEQ         reduce using rule 104 (neurCteCh -> .)
    AND             reduce using rule 104 (neurCteCh -> .)
    OR              reduce using rule 104 (neurCteCh -> .)
    ;               reduce using rule 104 (neurCteCh -> .)
    )               reduce using rule 104 (neurCteCh -> .)
    ID              reduce using rule 104 (neurCteCh -> .)
    ,               reduce using rule 104 (neurCteCh -> .)

    neurCteCh                      shift and go to state 116

state 97

    (90) factor -> varcte . neur1
    (93) neur1 -> .

    *               reduce using rule 93 (neur1 -> .)
    /               reduce using rule 93 (neur1 -> .)
    +               reduce using rule 93 (neur1 -> .)
    -               reduce using rule 93 (neur1 -> .)
    EQ              reduce using rule 93 (neur1 -> .)
    NOTEQ           reduce using rule 93 (neur1 -> .)
    >               reduce using rule 93 (neur1 -> .)
    <               reduce using rule 93 (neur1 -> .)
    MTHANEQ         reduce using rule 93 (neur1 -> .)
    LTHANEQ         reduce using rule 93 (neur1 -> .)
    AND             reduce using rule 93 (neur1 -> .)
    OR              reduce using rule 93 (neur1 -> .)
    ;               reduce using rule 93 (neur1 -> .)
    )               reduce using rule 93 (neur1 -> .)
    ID              reduce using rule 93 (neur1 -> .)
    ,               reduce using rule 93 (neur1 -> .)

    neur1                          shift and go to state 117

state 98

    (89) factor -> ( . neur6 expresion ) neur7
    (91) neur6 -> .

    NOT             reduce using rule 91 (neur6 -> .)
    (               reduce using rule 91 (neur6 -> .)
    ID              reduce using rule 91 (neur6 -> .)
    CTEE            reduce using rule 91 (neur6 -> .)
    CTEF            reduce using rule 91 (neur6 -> .)
    CTEBOOL         reduce using rule 91 (neur6 -> .)
    CTECHAR         reduce using rule 91 (neur6 -> .)
    CALL            reduce using rule 91 (neur6 -> .)

    neur6                          shift and go to state 118

state 99

    (60) exp -> nexp . p neur12
    (62) p -> . empty
    (63) p -> . EQ neur11_1 nexp
    (64) p -> . NOTEQ neur11_2 nexp
    (65) p -> . > neur11_3 nexp
    (66) p -> . < neur11_4 nexp
    (67) p -> . MTHANEQ neur11_5 nexp
    (68) p -> . LTHANEQ neur11_6 nexp
    (136) empty -> .

    EQ              shift and go to state 123
    NOTEQ           shift and go to state 122
    >               shift and go to state 126
    <               shift and go to state 124
    MTHANEQ         shift and go to state 119
    LTHANEQ         shift and go to state 121
    AND             reduce using rule 136 (empty -> .)
    OR              reduce using rule 136 (empty -> .)
    ;               reduce using rule 136 (empty -> .)
    )               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    ,               reduce using rule 136 (empty -> .)

    p                              shift and go to state 120
    empty                          shift and go to state 125

state 100

    (82) termino -> factor . neur4 n
    (83) neur4 -> .

    *               reduce using rule 83 (neur4 -> .)
    /               reduce using rule 83 (neur4 -> .)
    +               reduce using rule 83 (neur4 -> .)
    -               reduce using rule 83 (neur4 -> .)
    EQ              reduce using rule 83 (neur4 -> .)
    NOTEQ           reduce using rule 83 (neur4 -> .)
    >               reduce using rule 83 (neur4 -> .)
    <               reduce using rule 83 (neur4 -> .)
    MTHANEQ         reduce using rule 83 (neur4 -> .)
    LTHANEQ         reduce using rule 83 (neur4 -> .)
    AND             reduce using rule 83 (neur4 -> .)
    OR              reduce using rule 83 (neur4 -> .)
    ;               reduce using rule 83 (neur4 -> .)
    )               reduce using rule 83 (neur4 -> .)
    ID              reduce using rule 83 (neur4 -> .)
    ,               reduce using rule 83 (neur4 -> .)

    neur4                          shift and go to state 127

state 101

    (123) callfunc -> CALL . ID ( s ) ;

    ID              shift and go to state 128


state 102

    (50) expresion -> m subexpresion .

    ,               reduce using rule 50 (expresion -> m subexpresion .)
    )               reduce using rule 50 (expresion -> m subexpresion .)
    ID              reduce using rule 50 (expresion -> m subexpresion .)
    ;               reduce using rule 50 (expresion -> m subexpresion .)


state 103

    (94) varcte -> ID . r neurVar
    (105) r -> . empty
    (106) r -> . oplista
    (136) empty -> .
    (107) oplista -> . ID . x

  ! shift/reduce conflict for ID resolved as shift
    *               reduce using rule 136 (empty -> .)
    /               reduce using rule 136 (empty -> .)
    +               reduce using rule 136 (empty -> .)
    -               reduce using rule 136 (empty -> .)
    EQ              reduce using rule 136 (empty -> .)
    NOTEQ           reduce using rule 136 (empty -> .)
    >               reduce using rule 136 (empty -> .)
    <               reduce using rule 136 (empty -> .)
    MTHANEQ         reduce using rule 136 (empty -> .)
    LTHANEQ         reduce using rule 136 (empty -> .)
    AND             reduce using rule 136 (empty -> .)
    OR              reduce using rule 136 (empty -> .)
    ;               reduce using rule 136 (empty -> .)
    )               reduce using rule 136 (empty -> .)
    ,               reduce using rule 136 (empty -> .)
    ID              shift and go to state 131

  ! ID              [ reduce using rule 136 (empty -> .) ]

    oplista                        shift and go to state 129
    r                              shift and go to state 130
    empty                          shift and go to state 132

state 104

    (97) varcte -> CTEBOOL . neurCteB
    (103) neurCteB -> .

    *               reduce using rule 103 (neurCteB -> .)
    /               reduce using rule 103 (neurCteB -> .)
    +               reduce using rule 103 (neurCteB -> .)
    -               reduce using rule 103 (neurCteB -> .)
    EQ              reduce using rule 103 (neurCteB -> .)
    NOTEQ           reduce using rule 103 (neurCteB -> .)
    >               reduce using rule 103 (neurCteB -> .)
    <               reduce using rule 103 (neurCteB -> .)
    MTHANEQ         reduce using rule 103 (neurCteB -> .)
    LTHANEQ         reduce using rule 103 (neurCteB -> .)
    AND             reduce using rule 103 (neurCteB -> .)
    OR              reduce using rule 103 (neurCteB -> .)
    ;               reduce using rule 103 (neurCteB -> .)
    )               reduce using rule 103 (neurCteB -> .)
    ID              reduce using rule 103 (neurCteB -> .)
    ,               reduce using rule 103 (neurCteB -> .)

    neurCteB                       shift and go to state 133

state 105

    (98) varcte -> callfunc .

    *               reduce using rule 98 (varcte -> callfunc .)
    /               reduce using rule 98 (varcte -> callfunc .)
    +               reduce using rule 98 (varcte -> callfunc .)
    -               reduce using rule 98 (varcte -> callfunc .)
    EQ              reduce using rule 98 (varcte -> callfunc .)
    NOTEQ           reduce using rule 98 (varcte -> callfunc .)
    >               reduce using rule 98 (varcte -> callfunc .)
    <               reduce using rule 98 (varcte -> callfunc .)
    MTHANEQ         reduce using rule 98 (varcte -> callfunc .)
    LTHANEQ         reduce using rule 98 (varcte -> callfunc .)
    AND             reduce using rule 98 (varcte -> callfunc .)
    OR              reduce using rule 98 (varcte -> callfunc .)
    ;               reduce using rule 98 (varcte -> callfunc .)
    )               reduce using rule 98 (varcte -> callfunc .)
    ID              reduce using rule 98 (varcte -> callfunc .)
    ,               reduce using rule 98 (varcte -> callfunc .)


state 106

    (96) varcte -> CTEF . neurCteF
    (102) neurCteF -> .

    *               reduce using rule 102 (neurCteF -> .)
    /               reduce using rule 102 (neurCteF -> .)
    +               reduce using rule 102 (neurCteF -> .)
    -               reduce using rule 102 (neurCteF -> .)
    EQ              reduce using rule 102 (neurCteF -> .)
    NOTEQ           reduce using rule 102 (neurCteF -> .)
    >               reduce using rule 102 (neurCteF -> .)
    <               reduce using rule 102 (neurCteF -> .)
    MTHANEQ         reduce using rule 102 (neurCteF -> .)
    LTHANEQ         reduce using rule 102 (neurCteF -> .)
    AND             reduce using rule 102 (neurCteF -> .)
    OR              reduce using rule 102 (neurCteF -> .)
    ;               reduce using rule 102 (neurCteF -> .)
    )               reduce using rule 102 (neurCteF -> .)
    ID              reduce using rule 102 (neurCteF -> .)
    ,               reduce using rule 102 (neurCteF -> .)

    neurCteF                       shift and go to state 134

state 107

    (53) subexpresion -> exp . neur10 o
    (54) neur10 -> .

    AND             reduce using rule 54 (neur10 -> .)
    OR              reduce using rule 54 (neur10 -> .)
    ;               reduce using rule 54 (neur10 -> .)
    )               reduce using rule 54 (neur10 -> .)
    ID              reduce using rule 54 (neur10 -> .)
    ,               reduce using rule 54 (neur10 -> .)

    neur10                         shift and go to state 135

state 108

    (95) varcte -> CTEE . neurCteE
    (101) neurCteE -> .

    *               reduce using rule 101 (neurCteE -> .)
    /               reduce using rule 101 (neurCteE -> .)
    +               reduce using rule 101 (neurCteE -> .)
    -               reduce using rule 101 (neurCteE -> .)
    EQ              reduce using rule 101 (neurCteE -> .)
    NOTEQ           reduce using rule 101 (neurCteE -> .)
    >               reduce using rule 101 (neurCteE -> .)
    <               reduce using rule 101 (neurCteE -> .)
    MTHANEQ         reduce using rule 101 (neurCteE -> .)
    LTHANEQ         reduce using rule 101 (neurCteE -> .)
    AND             reduce using rule 101 (neurCteE -> .)
    OR              reduce using rule 101 (neurCteE -> .)
    ;               reduce using rule 101 (neurCteE -> .)
    )               reduce using rule 101 (neurCteE -> .)
    ID              reduce using rule 101 (neurCteE -> .)
    ,               reduce using rule 101 (neurCteE -> .)

    neurCteE                       shift and go to state 136

state 109

    (49) for -> FOR ( asignacion . expresion asignacion ) bloque ;
    (50) expresion -> . m subexpresion
    (51) m -> . empty
    (52) m -> . NOT
    (136) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    CTEE            reduce using rule 136 (empty -> .)
    CTEF            reduce using rule 136 (empty -> .)
    CTEBOOL         reduce using rule 136 (empty -> .)
    CTECHAR         reduce using rule 136 (empty -> .)
    CALL            reduce using rule 136 (empty -> .)

    expresion                      shift and go to state 137
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 110

    (38) asignacion -> ID = neur8 . k ;
    (40) k -> . expresion
    (41) k -> . asiglista
    (50) expresion -> . m subexpresion
    (42) asiglista -> . NEW LIST ( )
    (51) m -> . empty
    (52) m -> . NOT
    (136) empty -> .

    NEW             shift and go to state 141
    NOT             shift and go to state 81
    (               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    CTEE            reduce using rule 136 (empty -> .)
    CTEF            reduce using rule 136 (empty -> .)
    CTEBOOL         reduce using rule 136 (empty -> .)
    CTECHAR         reduce using rule 136 (empty -> .)
    CALL            reduce using rule 136 (empty -> .)

    expresion                      shift and go to state 138
    k                              shift and go to state 139
    m                              shift and go to state 80
    asiglista                      shift and go to state 140
    empty                          shift and go to state 82

state 111

    (43) if -> IF ( expresion . ) neur13 bloque l ;

    )               shift and go to state 142


state 112

    (128) return -> RETURN ( expresion ) . ;

    ;               shift and go to state 143


state 113

    (121) play -> PLAY ( NOTA , . CTEE ) ;

    CTEE            shift and go to state 144


state 114

    (118) while -> WHILE ( neur16 expresion . ) neur13 bloque neur17 ;

    )               shift and go to state 145


state 115

    (75) nexp -> termino neur5 . q
    (77) q -> . empty
    (78) q -> . + neur3_1 nexp
    (79) q -> . - neur3_2 nexp
    (136) empty -> .

    +               shift and go to state 146
    -               shift and go to state 147
    EQ              reduce using rule 136 (empty -> .)
    NOTEQ           reduce using rule 136 (empty -> .)
    >               reduce using rule 136 (empty -> .)
    <               reduce using rule 136 (empty -> .)
    MTHANEQ         reduce using rule 136 (empty -> .)
    LTHANEQ         reduce using rule 136 (empty -> .)
    AND             reduce using rule 136 (empty -> .)
    OR              reduce using rule 136 (empty -> .)
    ;               reduce using rule 136 (empty -> .)
    )               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    ,               reduce using rule 136 (empty -> .)

    q                              shift and go to state 148
    empty                          shift and go to state 149

state 116

    (99) varcte -> CTECHAR neurCteCh .

    *               reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    /               reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    +               reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    -               reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    EQ              reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    NOTEQ           reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    >               reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    <               reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    MTHANEQ         reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    LTHANEQ         reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    AND             reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    OR              reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    ;               reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    )               reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    ID              reduce using rule 99 (varcte -> CTECHAR neurCteCh .)
    ,               reduce using rule 99 (varcte -> CTECHAR neurCteCh .)


state 117

    (90) factor -> varcte neur1 .

    *               reduce using rule 90 (factor -> varcte neur1 .)
    /               reduce using rule 90 (factor -> varcte neur1 .)
    +               reduce using rule 90 (factor -> varcte neur1 .)
    -               reduce using rule 90 (factor -> varcte neur1 .)
    AND             reduce using rule 90 (factor -> varcte neur1 .)
    OR              reduce using rule 90 (factor -> varcte neur1 .)
    ;               reduce using rule 90 (factor -> varcte neur1 .)
    )               reduce using rule 90 (factor -> varcte neur1 .)
    ID              reduce using rule 90 (factor -> varcte neur1 .)
    ,               reduce using rule 90 (factor -> varcte neur1 .)
    EQ              reduce using rule 90 (factor -> varcte neur1 .)
    NOTEQ           reduce using rule 90 (factor -> varcte neur1 .)
    >               reduce using rule 90 (factor -> varcte neur1 .)
    <               reduce using rule 90 (factor -> varcte neur1 .)
    MTHANEQ         reduce using rule 90 (factor -> varcte neur1 .)
    LTHANEQ         reduce using rule 90 (factor -> varcte neur1 .)


state 118

    (89) factor -> ( neur6 . expresion ) neur7
    (50) expresion -> . m subexpresion
    (51) m -> . empty
    (52) m -> . NOT
    (136) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    CTEE            reduce using rule 136 (empty -> .)
    CTEF            reduce using rule 136 (empty -> .)
    CTEBOOL         reduce using rule 136 (empty -> .)
    CTECHAR         reduce using rule 136 (empty -> .)
    CALL            reduce using rule 136 (empty -> .)

    expresion                      shift and go to state 150
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 119

    (67) p -> MTHANEQ . neur11_5 nexp
    (73) neur11_5 -> .

    (               reduce using rule 73 (neur11_5 -> .)
    ID              reduce using rule 73 (neur11_5 -> .)
    CTEE            reduce using rule 73 (neur11_5 -> .)
    CTEF            reduce using rule 73 (neur11_5 -> .)
    CTEBOOL         reduce using rule 73 (neur11_5 -> .)
    CTECHAR         reduce using rule 73 (neur11_5 -> .)
    CALL            reduce using rule 73 (neur11_5 -> .)

    neur11_5                       shift and go to state 151

state 120

    (60) exp -> nexp p . neur12
    (61) neur12 -> .

    AND             reduce using rule 61 (neur12 -> .)
    OR              reduce using rule 61 (neur12 -> .)
    ;               reduce using rule 61 (neur12 -> .)
    )               reduce using rule 61 (neur12 -> .)
    ID              reduce using rule 61 (neur12 -> .)
    ,               reduce using rule 61 (neur12 -> .)

    neur12                         shift and go to state 152

state 121

    (68) p -> LTHANEQ . neur11_6 nexp
    (74) neur11_6 -> .

    (               reduce using rule 74 (neur11_6 -> .)
    ID              reduce using rule 74 (neur11_6 -> .)
    CTEE            reduce using rule 74 (neur11_6 -> .)
    CTEF            reduce using rule 74 (neur11_6 -> .)
    CTEBOOL         reduce using rule 74 (neur11_6 -> .)
    CTECHAR         reduce using rule 74 (neur11_6 -> .)
    CALL            reduce using rule 74 (neur11_6 -> .)

    neur11_6                       shift and go to state 153

state 122

    (64) p -> NOTEQ . neur11_2 nexp
    (70) neur11_2 -> .

    (               reduce using rule 70 (neur11_2 -> .)
    ID              reduce using rule 70 (neur11_2 -> .)
    CTEE            reduce using rule 70 (neur11_2 -> .)
    CTEF            reduce using rule 70 (neur11_2 -> .)
    CTEBOOL         reduce using rule 70 (neur11_2 -> .)
    CTECHAR         reduce using rule 70 (neur11_2 -> .)
    CALL            reduce using rule 70 (neur11_2 -> .)

    neur11_2                       shift and go to state 154

state 123

    (63) p -> EQ . neur11_1 nexp
    (69) neur11_1 -> .

    (               reduce using rule 69 (neur11_1 -> .)
    ID              reduce using rule 69 (neur11_1 -> .)
    CTEE            reduce using rule 69 (neur11_1 -> .)
    CTEF            reduce using rule 69 (neur11_1 -> .)
    CTEBOOL         reduce using rule 69 (neur11_1 -> .)
    CTECHAR         reduce using rule 69 (neur11_1 -> .)
    CALL            reduce using rule 69 (neur11_1 -> .)

    neur11_1                       shift and go to state 155

state 124

    (66) p -> < . neur11_4 nexp
    (72) neur11_4 -> .

    (               reduce using rule 72 (neur11_4 -> .)
    ID              reduce using rule 72 (neur11_4 -> .)
    CTEE            reduce using rule 72 (neur11_4 -> .)
    CTEF            reduce using rule 72 (neur11_4 -> .)
    CTEBOOL         reduce using rule 72 (neur11_4 -> .)
    CTECHAR         reduce using rule 72 (neur11_4 -> .)
    CALL            reduce using rule 72 (neur11_4 -> .)

    neur11_4                       shift and go to state 156

state 125

    (62) p -> empty .

    AND             reduce using rule 62 (p -> empty .)
    OR              reduce using rule 62 (p -> empty .)
    ;               reduce using rule 62 (p -> empty .)
    )               reduce using rule 62 (p -> empty .)
    ID              reduce using rule 62 (p -> empty .)
    ,               reduce using rule 62 (p -> empty .)


state 126

    (65) p -> > . neur11_3 nexp
    (71) neur11_3 -> .

    (               reduce using rule 71 (neur11_3 -> .)
    ID              reduce using rule 71 (neur11_3 -> .)
    CTEE            reduce using rule 71 (neur11_3 -> .)
    CTEF            reduce using rule 71 (neur11_3 -> .)
    CTEBOOL         reduce using rule 71 (neur11_3 -> .)
    CTECHAR         reduce using rule 71 (neur11_3 -> .)
    CALL            reduce using rule 71 (neur11_3 -> .)

    neur11_3                       shift and go to state 157

state 127

    (82) termino -> factor neur4 . n
    (84) n -> . empty
    (85) n -> . * neur2_1 termino
    (86) n -> . / neur2_2 termino
    (136) empty -> .

    *               shift and go to state 158
    /               shift and go to state 159
    +               reduce using rule 136 (empty -> .)
    -               reduce using rule 136 (empty -> .)
    EQ              reduce using rule 136 (empty -> .)
    NOTEQ           reduce using rule 136 (empty -> .)
    >               reduce using rule 136 (empty -> .)
    <               reduce using rule 136 (empty -> .)
    MTHANEQ         reduce using rule 136 (empty -> .)
    LTHANEQ         reduce using rule 136 (empty -> .)
    AND             reduce using rule 136 (empty -> .)
    OR              reduce using rule 136 (empty -> .)
    ;               reduce using rule 136 (empty -> .)
    )               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    ,               reduce using rule 136 (empty -> .)

    n                              shift and go to state 160
    empty                          shift and go to state 161

state 128

    (123) callfunc -> CALL ID . ( s ) ;

    (               shift and go to state 162


state 129

    (106) r -> oplista .

    *               reduce using rule 106 (r -> oplista .)
    /               reduce using rule 106 (r -> oplista .)
    +               reduce using rule 106 (r -> oplista .)
    -               reduce using rule 106 (r -> oplista .)
    EQ              reduce using rule 106 (r -> oplista .)
    NOTEQ           reduce using rule 106 (r -> oplista .)
    >               reduce using rule 106 (r -> oplista .)
    <               reduce using rule 106 (r -> oplista .)
    MTHANEQ         reduce using rule 106 (r -> oplista .)
    LTHANEQ         reduce using rule 106 (r -> oplista .)
    AND             reduce using rule 106 (r -> oplista .)
    OR              reduce using rule 106 (r -> oplista .)
    ;               reduce using rule 106 (r -> oplista .)
    )               reduce using rule 106 (r -> oplista .)
    ID              reduce using rule 106 (r -> oplista .)
    ,               reduce using rule 106 (r -> oplista .)


state 130

    (94) varcte -> ID r . neurVar
    (100) neurVar -> .

    *               reduce using rule 100 (neurVar -> .)
    /               reduce using rule 100 (neurVar -> .)
    +               reduce using rule 100 (neurVar -> .)
    -               reduce using rule 100 (neurVar -> .)
    EQ              reduce using rule 100 (neurVar -> .)
    NOTEQ           reduce using rule 100 (neurVar -> .)
    >               reduce using rule 100 (neurVar -> .)
    <               reduce using rule 100 (neurVar -> .)
    MTHANEQ         reduce using rule 100 (neurVar -> .)
    LTHANEQ         reduce using rule 100 (neurVar -> .)
    AND             reduce using rule 100 (neurVar -> .)
    OR              reduce using rule 100 (neurVar -> .)
    ;               reduce using rule 100 (neurVar -> .)
    )               reduce using rule 100 (neurVar -> .)
    ID              reduce using rule 100 (neurVar -> .)
    ,               reduce using rule 100 (neurVar -> .)

    neurVar                        shift and go to state 163

state 131

    (107) oplista -> ID . . x

    .               shift and go to state 164


state 132

    (105) r -> empty .

    *               reduce using rule 105 (r -> empty .)
    /               reduce using rule 105 (r -> empty .)
    +               reduce using rule 105 (r -> empty .)
    -               reduce using rule 105 (r -> empty .)
    EQ              reduce using rule 105 (r -> empty .)
    NOTEQ           reduce using rule 105 (r -> empty .)
    >               reduce using rule 105 (r -> empty .)
    <               reduce using rule 105 (r -> empty .)
    MTHANEQ         reduce using rule 105 (r -> empty .)
    LTHANEQ         reduce using rule 105 (r -> empty .)
    AND             reduce using rule 105 (r -> empty .)
    OR              reduce using rule 105 (r -> empty .)
    ;               reduce using rule 105 (r -> empty .)
    )               reduce using rule 105 (r -> empty .)
    ID              reduce using rule 105 (r -> empty .)
    ,               reduce using rule 105 (r -> empty .)


state 133

    (97) varcte -> CTEBOOL neurCteB .

    *               reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    /               reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    +               reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    -               reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    EQ              reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    NOTEQ           reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    >               reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    <               reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    MTHANEQ         reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    LTHANEQ         reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    AND             reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    OR              reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    ;               reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    )               reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    ID              reduce using rule 97 (varcte -> CTEBOOL neurCteB .)
    ,               reduce using rule 97 (varcte -> CTEBOOL neurCteB .)


state 134

    (96) varcte -> CTEF neurCteF .

    *               reduce using rule 96 (varcte -> CTEF neurCteF .)
    /               reduce using rule 96 (varcte -> CTEF neurCteF .)
    +               reduce using rule 96 (varcte -> CTEF neurCteF .)
    -               reduce using rule 96 (varcte -> CTEF neurCteF .)
    EQ              reduce using rule 96 (varcte -> CTEF neurCteF .)
    NOTEQ           reduce using rule 96 (varcte -> CTEF neurCteF .)
    >               reduce using rule 96 (varcte -> CTEF neurCteF .)
    <               reduce using rule 96 (varcte -> CTEF neurCteF .)
    MTHANEQ         reduce using rule 96 (varcte -> CTEF neurCteF .)
    LTHANEQ         reduce using rule 96 (varcte -> CTEF neurCteF .)
    AND             reduce using rule 96 (varcte -> CTEF neurCteF .)
    OR              reduce using rule 96 (varcte -> CTEF neurCteF .)
    ;               reduce using rule 96 (varcte -> CTEF neurCteF .)
    )               reduce using rule 96 (varcte -> CTEF neurCteF .)
    ID              reduce using rule 96 (varcte -> CTEF neurCteF .)
    ,               reduce using rule 96 (varcte -> CTEF neurCteF .)


state 135

    (53) subexpresion -> exp neur10 . o
    (55) o -> . empty
    (56) o -> . AND neur9_1 subexpresion
    (57) o -> . OR neur9_2 subexpresion
    (136) empty -> .

    AND             shift and go to state 165
    OR              shift and go to state 167
    ;               reduce using rule 136 (empty -> .)
    )               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    ,               reduce using rule 136 (empty -> .)

    o                              shift and go to state 166
    empty                          shift and go to state 168

state 136

    (95) varcte -> CTEE neurCteE .

    *               reduce using rule 95 (varcte -> CTEE neurCteE .)
    /               reduce using rule 95 (varcte -> CTEE neurCteE .)
    +               reduce using rule 95 (varcte -> CTEE neurCteE .)
    -               reduce using rule 95 (varcte -> CTEE neurCteE .)
    EQ              reduce using rule 95 (varcte -> CTEE neurCteE .)
    NOTEQ           reduce using rule 95 (varcte -> CTEE neurCteE .)
    >               reduce using rule 95 (varcte -> CTEE neurCteE .)
    <               reduce using rule 95 (varcte -> CTEE neurCteE .)
    MTHANEQ         reduce using rule 95 (varcte -> CTEE neurCteE .)
    LTHANEQ         reduce using rule 95 (varcte -> CTEE neurCteE .)
    AND             reduce using rule 95 (varcte -> CTEE neurCteE .)
    OR              reduce using rule 95 (varcte -> CTEE neurCteE .)
    ;               reduce using rule 95 (varcte -> CTEE neurCteE .)
    )               reduce using rule 95 (varcte -> CTEE neurCteE .)
    ID              reduce using rule 95 (varcte -> CTEE neurCteE .)
    ,               reduce using rule 95 (varcte -> CTEE neurCteE .)


state 137

    (49) for -> FOR ( asignacion expresion . asignacion ) bloque ;
    (38) asignacion -> . ID = neur8 k ;

    ID              shift and go to state 67

    asignacion                     shift and go to state 169

state 138

    (40) k -> expresion .

    ;               reduce using rule 40 (k -> expresion .)


state 139

    (38) asignacion -> ID = neur8 k . ;

    ;               shift and go to state 170


state 140

    (41) k -> asiglista .

    ;               reduce using rule 41 (k -> asiglista .)


state 141

    (42) asiglista -> NEW . LIST ( )

    LIST            shift and go to state 171


state 142

    (43) if -> IF ( expresion ) . neur13 bloque l ;
    (44) neur13 -> .

    {               reduce using rule 44 (neur13 -> .)

    neur13                         shift and go to state 172

state 143

    (128) return -> RETURN ( expresion ) ; .

    ID              reduce using rule 128 (return -> RETURN ( expresion ) ; .)
    IF              reduce using rule 128 (return -> RETURN ( expresion ) ; .)
    FOR             reduce using rule 128 (return -> RETURN ( expresion ) ; .)
    RETURN          reduce using rule 128 (return -> RETURN ( expresion ) ; .)
    WHILE           reduce using rule 128 (return -> RETURN ( expresion ) ; .)
    PLAY            reduce using rule 128 (return -> RETURN ( expresion ) ; .)
    PRINT           reduce using rule 128 (return -> RETURN ( expresion ) ; .)
    }               reduce using rule 128 (return -> RETURN ( expresion ) ; .)


state 144

    (121) play -> PLAY ( NOTA , CTEE . ) ;

    )               shift and go to state 173


state 145

    (118) while -> WHILE ( neur16 expresion ) . neur13 bloque neur17 ;
    (44) neur13 -> .

    {               reduce using rule 44 (neur13 -> .)

    neur13                         shift and go to state 174

state 146

    (78) q -> + . neur3_1 nexp
    (80) neur3_1 -> .

    (               reduce using rule 80 (neur3_1 -> .)
    ID              reduce using rule 80 (neur3_1 -> .)
    CTEE            reduce using rule 80 (neur3_1 -> .)
    CTEF            reduce using rule 80 (neur3_1 -> .)
    CTEBOOL         reduce using rule 80 (neur3_1 -> .)
    CTECHAR         reduce using rule 80 (neur3_1 -> .)
    CALL            reduce using rule 80 (neur3_1 -> .)

    neur3_1                        shift and go to state 175

state 147

    (79) q -> - . neur3_2 nexp
    (81) neur3_2 -> .

    (               reduce using rule 81 (neur3_2 -> .)
    ID              reduce using rule 81 (neur3_2 -> .)
    CTEE            reduce using rule 81 (neur3_2 -> .)
    CTEF            reduce using rule 81 (neur3_2 -> .)
    CTEBOOL         reduce using rule 81 (neur3_2 -> .)
    CTECHAR         reduce using rule 81 (neur3_2 -> .)
    CALL            reduce using rule 81 (neur3_2 -> .)

    neur3_2                        shift and go to state 176

state 148

    (75) nexp -> termino neur5 q .

    EQ              reduce using rule 75 (nexp -> termino neur5 q .)
    NOTEQ           reduce using rule 75 (nexp -> termino neur5 q .)
    >               reduce using rule 75 (nexp -> termino neur5 q .)
    <               reduce using rule 75 (nexp -> termino neur5 q .)
    MTHANEQ         reduce using rule 75 (nexp -> termino neur5 q .)
    LTHANEQ         reduce using rule 75 (nexp -> termino neur5 q .)
    AND             reduce using rule 75 (nexp -> termino neur5 q .)
    OR              reduce using rule 75 (nexp -> termino neur5 q .)
    ;               reduce using rule 75 (nexp -> termino neur5 q .)
    )               reduce using rule 75 (nexp -> termino neur5 q .)
    ID              reduce using rule 75 (nexp -> termino neur5 q .)
    ,               reduce using rule 75 (nexp -> termino neur5 q .)


state 149

    (77) q -> empty .

    EQ              reduce using rule 77 (q -> empty .)
    NOTEQ           reduce using rule 77 (q -> empty .)
    >               reduce using rule 77 (q -> empty .)
    <               reduce using rule 77 (q -> empty .)
    MTHANEQ         reduce using rule 77 (q -> empty .)
    LTHANEQ         reduce using rule 77 (q -> empty .)
    AND             reduce using rule 77 (q -> empty .)
    OR              reduce using rule 77 (q -> empty .)
    ;               reduce using rule 77 (q -> empty .)
    )               reduce using rule 77 (q -> empty .)
    ID              reduce using rule 77 (q -> empty .)
    ,               reduce using rule 77 (q -> empty .)


state 150

    (89) factor -> ( neur6 expresion . ) neur7

    )               shift and go to state 177


state 151

    (67) p -> MTHANEQ neur11_5 . nexp
    (75) nexp -> . termino neur5 q
    (82) termino -> . factor neur4 n
    (89) factor -> . ( neur6 expresion ) neur7
    (90) factor -> . varcte neur1
    (94) varcte -> . ID r neurVar
    (95) varcte -> . CTEE neurCteE
    (96) varcte -> . CTEF neurCteF
    (97) varcte -> . CTEBOOL neurCteB
    (98) varcte -> . callfunc
    (99) varcte -> . CTECHAR neurCteCh
    (123) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    nexp                           shift and go to state 178
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 152

    (60) exp -> nexp p neur12 .

    AND             reduce using rule 60 (exp -> nexp p neur12 .)
    OR              reduce using rule 60 (exp -> nexp p neur12 .)
    ;               reduce using rule 60 (exp -> nexp p neur12 .)
    )               reduce using rule 60 (exp -> nexp p neur12 .)
    ID              reduce using rule 60 (exp -> nexp p neur12 .)
    ,               reduce using rule 60 (exp -> nexp p neur12 .)


state 153

    (68) p -> LTHANEQ neur11_6 . nexp
    (75) nexp -> . termino neur5 q
    (82) termino -> . factor neur4 n
    (89) factor -> . ( neur6 expresion ) neur7
    (90) factor -> . varcte neur1
    (94) varcte -> . ID r neurVar
    (95) varcte -> . CTEE neurCteE
    (96) varcte -> . CTEF neurCteF
    (97) varcte -> . CTEBOOL neurCteB
    (98) varcte -> . callfunc
    (99) varcte -> . CTECHAR neurCteCh
    (123) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    nexp                           shift and go to state 179
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 154

    (64) p -> NOTEQ neur11_2 . nexp
    (75) nexp -> . termino neur5 q
    (82) termino -> . factor neur4 n
    (89) factor -> . ( neur6 expresion ) neur7
    (90) factor -> . varcte neur1
    (94) varcte -> . ID r neurVar
    (95) varcte -> . CTEE neurCteE
    (96) varcte -> . CTEF neurCteF
    (97) varcte -> . CTEBOOL neurCteB
    (98) varcte -> . callfunc
    (99) varcte -> . CTECHAR neurCteCh
    (123) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    nexp                           shift and go to state 180
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 155

    (63) p -> EQ neur11_1 . nexp
    (75) nexp -> . termino neur5 q
    (82) termino -> . factor neur4 n
    (89) factor -> . ( neur6 expresion ) neur7
    (90) factor -> . varcte neur1
    (94) varcte -> . ID r neurVar
    (95) varcte -> . CTEE neurCteE
    (96) varcte -> . CTEF neurCteF
    (97) varcte -> . CTEBOOL neurCteB
    (98) varcte -> . callfunc
    (99) varcte -> . CTECHAR neurCteCh
    (123) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    nexp                           shift and go to state 181
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 156

    (66) p -> < neur11_4 . nexp
    (75) nexp -> . termino neur5 q
    (82) termino -> . factor neur4 n
    (89) factor -> . ( neur6 expresion ) neur7
    (90) factor -> . varcte neur1
    (94) varcte -> . ID r neurVar
    (95) varcte -> . CTEE neurCteE
    (96) varcte -> . CTEF neurCteF
    (97) varcte -> . CTEBOOL neurCteB
    (98) varcte -> . callfunc
    (99) varcte -> . CTECHAR neurCteCh
    (123) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    nexp                           shift and go to state 182
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 157

    (65) p -> > neur11_3 . nexp
    (75) nexp -> . termino neur5 q
    (82) termino -> . factor neur4 n
    (89) factor -> . ( neur6 expresion ) neur7
    (90) factor -> . varcte neur1
    (94) varcte -> . ID r neurVar
    (95) varcte -> . CTEE neurCteE
    (96) varcte -> . CTEF neurCteF
    (97) varcte -> . CTEBOOL neurCteB
    (98) varcte -> . callfunc
    (99) varcte -> . CTECHAR neurCteCh
    (123) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    nexp                           shift and go to state 183
    callfunc                       shift and go to state 105
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 158

    (85) n -> * . neur2_1 termino
    (87) neur2_1 -> .

    (               reduce using rule 87 (neur2_1 -> .)
    ID              reduce using rule 87 (neur2_1 -> .)
    CTEE            reduce using rule 87 (neur2_1 -> .)
    CTEF            reduce using rule 87 (neur2_1 -> .)
    CTEBOOL         reduce using rule 87 (neur2_1 -> .)
    CTECHAR         reduce using rule 87 (neur2_1 -> .)
    CALL            reduce using rule 87 (neur2_1 -> .)

    neur2_1                        shift and go to state 184

state 159

    (86) n -> / . neur2_2 termino
    (88) neur2_2 -> .

    (               reduce using rule 88 (neur2_2 -> .)
    ID              reduce using rule 88 (neur2_2 -> .)
    CTEE            reduce using rule 88 (neur2_2 -> .)
    CTEF            reduce using rule 88 (neur2_2 -> .)
    CTEBOOL         reduce using rule 88 (neur2_2 -> .)
    CTECHAR         reduce using rule 88 (neur2_2 -> .)
    CALL            reduce using rule 88 (neur2_2 -> .)

    neur2_2                        shift and go to state 185

state 160

    (82) termino -> factor neur4 n .

    +               reduce using rule 82 (termino -> factor neur4 n .)
    -               reduce using rule 82 (termino -> factor neur4 n .)
    AND             reduce using rule 82 (termino -> factor neur4 n .)
    OR              reduce using rule 82 (termino -> factor neur4 n .)
    ;               reduce using rule 82 (termino -> factor neur4 n .)
    )               reduce using rule 82 (termino -> factor neur4 n .)
    ID              reduce using rule 82 (termino -> factor neur4 n .)
    ,               reduce using rule 82 (termino -> factor neur4 n .)
    EQ              reduce using rule 82 (termino -> factor neur4 n .)
    NOTEQ           reduce using rule 82 (termino -> factor neur4 n .)
    >               reduce using rule 82 (termino -> factor neur4 n .)
    <               reduce using rule 82 (termino -> factor neur4 n .)
    MTHANEQ         reduce using rule 82 (termino -> factor neur4 n .)
    LTHANEQ         reduce using rule 82 (termino -> factor neur4 n .)


state 161

    (84) n -> empty .

    +               reduce using rule 84 (n -> empty .)
    -               reduce using rule 84 (n -> empty .)
    EQ              reduce using rule 84 (n -> empty .)
    NOTEQ           reduce using rule 84 (n -> empty .)
    >               reduce using rule 84 (n -> empty .)
    <               reduce using rule 84 (n -> empty .)
    MTHANEQ         reduce using rule 84 (n -> empty .)
    LTHANEQ         reduce using rule 84 (n -> empty .)
    AND             reduce using rule 84 (n -> empty .)
    OR              reduce using rule 84 (n -> empty .)
    ;               reduce using rule 84 (n -> empty .)
    )               reduce using rule 84 (n -> empty .)
    ID              reduce using rule 84 (n -> empty .)
    ,               reduce using rule 84 (n -> empty .)


state 162

    (123) callfunc -> CALL ID ( . s ) ;
    (124) s -> . empty
    (125) s -> . expresion t
    (136) empty -> .
    (50) expresion -> . m subexpresion
    (51) m -> . empty
    (52) m -> . NOT

    )               reduce using rule 136 (empty -> .)
    (               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    CTEE            reduce using rule 136 (empty -> .)
    CTEF            reduce using rule 136 (empty -> .)
    CTEBOOL         reduce using rule 136 (empty -> .)
    CTECHAR         reduce using rule 136 (empty -> .)
    CALL            reduce using rule 136 (empty -> .)
    NOT             shift and go to state 81

    expresion                      shift and go to state 186
    m                              shift and go to state 80
    s                              shift and go to state 187
    empty                          shift and go to state 188

state 163

    (94) varcte -> ID r neurVar .

    *               reduce using rule 94 (varcte -> ID r neurVar .)
    /               reduce using rule 94 (varcte -> ID r neurVar .)
    +               reduce using rule 94 (varcte -> ID r neurVar .)
    -               reduce using rule 94 (varcte -> ID r neurVar .)
    EQ              reduce using rule 94 (varcte -> ID r neurVar .)
    NOTEQ           reduce using rule 94 (varcte -> ID r neurVar .)
    >               reduce using rule 94 (varcte -> ID r neurVar .)
    <               reduce using rule 94 (varcte -> ID r neurVar .)
    MTHANEQ         reduce using rule 94 (varcte -> ID r neurVar .)
    LTHANEQ         reduce using rule 94 (varcte -> ID r neurVar .)
    AND             reduce using rule 94 (varcte -> ID r neurVar .)
    OR              reduce using rule 94 (varcte -> ID r neurVar .)
    ;               reduce using rule 94 (varcte -> ID r neurVar .)
    )               reduce using rule 94 (varcte -> ID r neurVar .)
    ID              reduce using rule 94 (varcte -> ID r neurVar .)
    ,               reduce using rule 94 (varcte -> ID r neurVar .)


state 164

    (107) oplista -> ID . . x
    (108) x -> . inlistset
    (109) x -> . append
    (110) x -> . length
    (111) x -> . getlist
    (112) x -> . removelist
    (113) inlistset -> . SET ( CTEE , expresion )
    (114) append -> . APPEND ( expresion )
    (115) length -> . LENGTH ( )
    (116) getlist -> . GET ( expresion )
    (117) removelist -> . REMOVE ( expresion )

    SET             shift and go to state 189
    APPEND          shift and go to state 196
    LENGTH          shift and go to state 194
    GET             shift and go to state 191
    REMOVE          shift and go to state 193

    inlistset                      shift and go to state 190
    getlist                        shift and go to state 192
    length                         shift and go to state 195
    x                              shift and go to state 197
    removelist                     shift and go to state 198
    append                         shift and go to state 199

state 165

    (56) o -> AND . neur9_1 subexpresion
    (58) neur9_1 -> .

    (               reduce using rule 58 (neur9_1 -> .)
    ID              reduce using rule 58 (neur9_1 -> .)
    CTEE            reduce using rule 58 (neur9_1 -> .)
    CTEF            reduce using rule 58 (neur9_1 -> .)
    CTEBOOL         reduce using rule 58 (neur9_1 -> .)
    CTECHAR         reduce using rule 58 (neur9_1 -> .)
    CALL            reduce using rule 58 (neur9_1 -> .)

    neur9_1                        shift and go to state 200

state 166

    (53) subexpresion -> exp neur10 o .

    ;               reduce using rule 53 (subexpresion -> exp neur10 o .)
    )               reduce using rule 53 (subexpresion -> exp neur10 o .)
    ID              reduce using rule 53 (subexpresion -> exp neur10 o .)
    ,               reduce using rule 53 (subexpresion -> exp neur10 o .)


state 167

    (57) o -> OR . neur9_2 subexpresion
    (59) neur9_2 -> .

    (               reduce using rule 59 (neur9_2 -> .)
    ID              reduce using rule 59 (neur9_2 -> .)
    CTEE            reduce using rule 59 (neur9_2 -> .)
    CTEF            reduce using rule 59 (neur9_2 -> .)
    CTEBOOL         reduce using rule 59 (neur9_2 -> .)
    CTECHAR         reduce using rule 59 (neur9_2 -> .)
    CALL            reduce using rule 59 (neur9_2 -> .)

    neur9_2                        shift and go to state 201

state 168

    (55) o -> empty .

    ;               reduce using rule 55 (o -> empty .)
    )               reduce using rule 55 (o -> empty .)
    ID              reduce using rule 55 (o -> empty .)
    ,               reduce using rule 55 (o -> empty .)


state 169

    (49) for -> FOR ( asignacion expresion asignacion . ) bloque ;

    )               shift and go to state 202


state 170

    (38) asignacion -> ID = neur8 k ; .

    NOT             reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    (               reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    ID              reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CTEE            reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CTEF            reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CTEBOOL         reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CTECHAR         reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CALL            reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    IF              reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    FOR             reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    RETURN          reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    WHILE           reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    PLAY            reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    PRINT           reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    }               reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    )               reduce using rule 38 (asignacion -> ID = neur8 k ; .)


state 171

    (42) asiglista -> NEW LIST . ( )

    (               shift and go to state 203


state 172

    (43) if -> IF ( expresion ) neur13 . bloque l ;
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 204

state 173

    (121) play -> PLAY ( NOTA , CTEE ) . ;

    ;               shift and go to state 205


state 174

    (118) while -> WHILE ( neur16 expresion ) neur13 . bloque neur17 ;
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 206

state 175

    (78) q -> + neur3_1 . nexp
    (75) nexp -> . termino neur5 q
    (82) termino -> . factor neur4 n
    (89) factor -> . ( neur6 expresion ) neur7
    (90) factor -> . varcte neur1
    (94) varcte -> . ID r neurVar
    (95) varcte -> . CTEE neurCteE
    (96) varcte -> . CTEF neurCteF
    (97) varcte -> . CTEBOOL neurCteB
    (98) varcte -> . callfunc
    (99) varcte -> . CTECHAR neurCteCh
    (123) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    nexp                           shift and go to state 207
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 176

    (79) q -> - neur3_2 . nexp
    (75) nexp -> . termino neur5 q
    (82) termino -> . factor neur4 n
    (89) factor -> . ( neur6 expresion ) neur7
    (90) factor -> . varcte neur1
    (94) varcte -> . ID r neurVar
    (95) varcte -> . CTEE neurCteE
    (96) varcte -> . CTEF neurCteF
    (97) varcte -> . CTEBOOL neurCteB
    (98) varcte -> . callfunc
    (99) varcte -> . CTECHAR neurCteCh
    (123) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    nexp                           shift and go to state 208
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 177

    (89) factor -> ( neur6 expresion ) . neur7
    (92) neur7 -> .

    *               reduce using rule 92 (neur7 -> .)
    /               reduce using rule 92 (neur7 -> .)
    +               reduce using rule 92 (neur7 -> .)
    -               reduce using rule 92 (neur7 -> .)
    EQ              reduce using rule 92 (neur7 -> .)
    NOTEQ           reduce using rule 92 (neur7 -> .)
    >               reduce using rule 92 (neur7 -> .)
    <               reduce using rule 92 (neur7 -> .)
    MTHANEQ         reduce using rule 92 (neur7 -> .)
    LTHANEQ         reduce using rule 92 (neur7 -> .)
    AND             reduce using rule 92 (neur7 -> .)
    OR              reduce using rule 92 (neur7 -> .)
    ;               reduce using rule 92 (neur7 -> .)
    )               reduce using rule 92 (neur7 -> .)
    ID              reduce using rule 92 (neur7 -> .)
    ,               reduce using rule 92 (neur7 -> .)

    neur7                          shift and go to state 209

state 178

    (67) p -> MTHANEQ neur11_5 nexp .

    AND             reduce using rule 67 (p -> MTHANEQ neur11_5 nexp .)
    OR              reduce using rule 67 (p -> MTHANEQ neur11_5 nexp .)
    ;               reduce using rule 67 (p -> MTHANEQ neur11_5 nexp .)
    )               reduce using rule 67 (p -> MTHANEQ neur11_5 nexp .)
    ID              reduce using rule 67 (p -> MTHANEQ neur11_5 nexp .)
    ,               reduce using rule 67 (p -> MTHANEQ neur11_5 nexp .)


state 179

    (68) p -> LTHANEQ neur11_6 nexp .

    AND             reduce using rule 68 (p -> LTHANEQ neur11_6 nexp .)
    OR              reduce using rule 68 (p -> LTHANEQ neur11_6 nexp .)
    ;               reduce using rule 68 (p -> LTHANEQ neur11_6 nexp .)
    )               reduce using rule 68 (p -> LTHANEQ neur11_6 nexp .)
    ID              reduce using rule 68 (p -> LTHANEQ neur11_6 nexp .)
    ,               reduce using rule 68 (p -> LTHANEQ neur11_6 nexp .)


state 180

    (64) p -> NOTEQ neur11_2 nexp .

    AND             reduce using rule 64 (p -> NOTEQ neur11_2 nexp .)
    OR              reduce using rule 64 (p -> NOTEQ neur11_2 nexp .)
    ;               reduce using rule 64 (p -> NOTEQ neur11_2 nexp .)
    )               reduce using rule 64 (p -> NOTEQ neur11_2 nexp .)
    ID              reduce using rule 64 (p -> NOTEQ neur11_2 nexp .)
    ,               reduce using rule 64 (p -> NOTEQ neur11_2 nexp .)


state 181

    (63) p -> EQ neur11_1 nexp .

    AND             reduce using rule 63 (p -> EQ neur11_1 nexp .)
    OR              reduce using rule 63 (p -> EQ neur11_1 nexp .)
    ;               reduce using rule 63 (p -> EQ neur11_1 nexp .)
    )               reduce using rule 63 (p -> EQ neur11_1 nexp .)
    ID              reduce using rule 63 (p -> EQ neur11_1 nexp .)
    ,               reduce using rule 63 (p -> EQ neur11_1 nexp .)


state 182

    (66) p -> < neur11_4 nexp .

    AND             reduce using rule 66 (p -> < neur11_4 nexp .)
    OR              reduce using rule 66 (p -> < neur11_4 nexp .)
    ;               reduce using rule 66 (p -> < neur11_4 nexp .)
    )               reduce using rule 66 (p -> < neur11_4 nexp .)
    ID              reduce using rule 66 (p -> < neur11_4 nexp .)
    ,               reduce using rule 66 (p -> < neur11_4 nexp .)


state 183

    (65) p -> > neur11_3 nexp .

    AND             reduce using rule 65 (p -> > neur11_3 nexp .)
    OR              reduce using rule 65 (p -> > neur11_3 nexp .)
    ;               reduce using rule 65 (p -> > neur11_3 nexp .)
    )               reduce using rule 65 (p -> > neur11_3 nexp .)
    ID              reduce using rule 65 (p -> > neur11_3 nexp .)
    ,               reduce using rule 65 (p -> > neur11_3 nexp .)


state 184

    (85) n -> * neur2_1 . termino
    (82) termino -> . factor neur4 n
    (89) factor -> . ( neur6 expresion ) neur7
    (90) factor -> . varcte neur1
    (94) varcte -> . ID r neurVar
    (95) varcte -> . CTEE neurCteE
    (96) varcte -> . CTEF neurCteF
    (97) varcte -> . CTEBOOL neurCteB
    (98) varcte -> . callfunc
    (99) varcte -> . CTECHAR neurCteCh
    (123) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    termino                        shift and go to state 210
    factor                         shift and go to state 100

state 185

    (86) n -> / neur2_2 . termino
    (82) termino -> . factor neur4 n
    (89) factor -> . ( neur6 expresion ) neur7
    (90) factor -> . varcte neur1
    (94) varcte -> . ID r neurVar
    (95) varcte -> . CTEE neurCteE
    (96) varcte -> . CTEF neurCteF
    (97) varcte -> . CTEBOOL neurCteB
    (98) varcte -> . callfunc
    (99) varcte -> . CTECHAR neurCteCh
    (123) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    termino                        shift and go to state 211
    factor                         shift and go to state 100

state 186

    (125) s -> expresion . t
    (126) t -> . empty
    (127) t -> . , s
    (136) empty -> .

    ,               shift and go to state 214
    )               reduce using rule 136 (empty -> .)

    t                              shift and go to state 212
    empty                          shift and go to state 213

state 187

    (123) callfunc -> CALL ID ( s . ) ;

    )               shift and go to state 215


state 188

    (124) s -> empty .
    (51) m -> empty .

    )               reduce using rule 124 (s -> empty .)
    (               reduce using rule 51 (m -> empty .)
    ID              reduce using rule 51 (m -> empty .)
    CTEE            reduce using rule 51 (m -> empty .)
    CTEF            reduce using rule 51 (m -> empty .)
    CTEBOOL         reduce using rule 51 (m -> empty .)
    CTECHAR         reduce using rule 51 (m -> empty .)
    CALL            reduce using rule 51 (m -> empty .)


state 189

    (113) inlistset -> SET . ( CTEE , expresion )

    (               shift and go to state 216


state 190

    (108) x -> inlistset .

    *               reduce using rule 108 (x -> inlistset .)
    /               reduce using rule 108 (x -> inlistset .)
    +               reduce using rule 108 (x -> inlistset .)
    -               reduce using rule 108 (x -> inlistset .)
    EQ              reduce using rule 108 (x -> inlistset .)
    NOTEQ           reduce using rule 108 (x -> inlistset .)
    >               reduce using rule 108 (x -> inlistset .)
    <               reduce using rule 108 (x -> inlistset .)
    MTHANEQ         reduce using rule 108 (x -> inlistset .)
    LTHANEQ         reduce using rule 108 (x -> inlistset .)
    AND             reduce using rule 108 (x -> inlistset .)
    OR              reduce using rule 108 (x -> inlistset .)
    ;               reduce using rule 108 (x -> inlistset .)
    )               reduce using rule 108 (x -> inlistset .)
    ID              reduce using rule 108 (x -> inlistset .)
    ,               reduce using rule 108 (x -> inlistset .)


state 191

    (116) getlist -> GET . ( expresion )

    (               shift and go to state 217


state 192

    (111) x -> getlist .

    *               reduce using rule 111 (x -> getlist .)
    /               reduce using rule 111 (x -> getlist .)
    +               reduce using rule 111 (x -> getlist .)
    -               reduce using rule 111 (x -> getlist .)
    EQ              reduce using rule 111 (x -> getlist .)
    NOTEQ           reduce using rule 111 (x -> getlist .)
    >               reduce using rule 111 (x -> getlist .)
    <               reduce using rule 111 (x -> getlist .)
    MTHANEQ         reduce using rule 111 (x -> getlist .)
    LTHANEQ         reduce using rule 111 (x -> getlist .)
    AND             reduce using rule 111 (x -> getlist .)
    OR              reduce using rule 111 (x -> getlist .)
    ;               reduce using rule 111 (x -> getlist .)
    )               reduce using rule 111 (x -> getlist .)
    ID              reduce using rule 111 (x -> getlist .)
    ,               reduce using rule 111 (x -> getlist .)


state 193

    (117) removelist -> REMOVE . ( expresion )

    (               shift and go to state 218


state 194

    (115) length -> LENGTH . ( )

    (               shift and go to state 219


state 195

    (110) x -> length .

    *               reduce using rule 110 (x -> length .)
    /               reduce using rule 110 (x -> length .)
    +               reduce using rule 110 (x -> length .)
    -               reduce using rule 110 (x -> length .)
    EQ              reduce using rule 110 (x -> length .)
    NOTEQ           reduce using rule 110 (x -> length .)
    >               reduce using rule 110 (x -> length .)
    <               reduce using rule 110 (x -> length .)
    MTHANEQ         reduce using rule 110 (x -> length .)
    LTHANEQ         reduce using rule 110 (x -> length .)
    AND             reduce using rule 110 (x -> length .)
    OR              reduce using rule 110 (x -> length .)
    ;               reduce using rule 110 (x -> length .)
    )               reduce using rule 110 (x -> length .)
    ID              reduce using rule 110 (x -> length .)
    ,               reduce using rule 110 (x -> length .)


state 196

    (114) append -> APPEND . ( expresion )

    (               shift and go to state 220


state 197

    (107) oplista -> ID . x .

    *               reduce using rule 107 (oplista -> ID . x .)
    /               reduce using rule 107 (oplista -> ID . x .)
    +               reduce using rule 107 (oplista -> ID . x .)
    -               reduce using rule 107 (oplista -> ID . x .)
    EQ              reduce using rule 107 (oplista -> ID . x .)
    NOTEQ           reduce using rule 107 (oplista -> ID . x .)
    >               reduce using rule 107 (oplista -> ID . x .)
    <               reduce using rule 107 (oplista -> ID . x .)
    MTHANEQ         reduce using rule 107 (oplista -> ID . x .)
    LTHANEQ         reduce using rule 107 (oplista -> ID . x .)
    AND             reduce using rule 107 (oplista -> ID . x .)
    OR              reduce using rule 107 (oplista -> ID . x .)
    ;               reduce using rule 107 (oplista -> ID . x .)
    )               reduce using rule 107 (oplista -> ID . x .)
    ID              reduce using rule 107 (oplista -> ID . x .)
    ,               reduce using rule 107 (oplista -> ID . x .)


state 198

    (112) x -> removelist .

    *               reduce using rule 112 (x -> removelist .)
    /               reduce using rule 112 (x -> removelist .)
    +               reduce using rule 112 (x -> removelist .)
    -               reduce using rule 112 (x -> removelist .)
    EQ              reduce using rule 112 (x -> removelist .)
    NOTEQ           reduce using rule 112 (x -> removelist .)
    >               reduce using rule 112 (x -> removelist .)
    <               reduce using rule 112 (x -> removelist .)
    MTHANEQ         reduce using rule 112 (x -> removelist .)
    LTHANEQ         reduce using rule 112 (x -> removelist .)
    AND             reduce using rule 112 (x -> removelist .)
    OR              reduce using rule 112 (x -> removelist .)
    ;               reduce using rule 112 (x -> removelist .)
    )               reduce using rule 112 (x -> removelist .)
    ID              reduce using rule 112 (x -> removelist .)
    ,               reduce using rule 112 (x -> removelist .)


state 199

    (109) x -> append .

    *               reduce using rule 109 (x -> append .)
    /               reduce using rule 109 (x -> append .)
    +               reduce using rule 109 (x -> append .)
    -               reduce using rule 109 (x -> append .)
    EQ              reduce using rule 109 (x -> append .)
    NOTEQ           reduce using rule 109 (x -> append .)
    >               reduce using rule 109 (x -> append .)
    <               reduce using rule 109 (x -> append .)
    MTHANEQ         reduce using rule 109 (x -> append .)
    LTHANEQ         reduce using rule 109 (x -> append .)
    AND             reduce using rule 109 (x -> append .)
    OR              reduce using rule 109 (x -> append .)
    ;               reduce using rule 109 (x -> append .)
    )               reduce using rule 109 (x -> append .)
    ID              reduce using rule 109 (x -> append .)
    ,               reduce using rule 109 (x -> append .)


state 200

    (56) o -> AND neur9_1 . subexpresion
    (53) subexpresion -> . exp neur10 o
    (60) exp -> . nexp p neur12
    (75) nexp -> . termino neur5 q
    (82) termino -> . factor neur4 n
    (89) factor -> . ( neur6 expresion ) neur7
    (90) factor -> . varcte neur1
    (94) varcte -> . ID r neurVar
    (95) varcte -> . CTEE neurCteE
    (96) varcte -> . CTEF neurCteF
    (97) varcte -> . CTEBOOL neurCteB
    (98) varcte -> . callfunc
    (99) varcte -> . CTECHAR neurCteCh
    (123) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    termino                        shift and go to state 95
    varcte                         shift and go to state 97
    nexp                           shift and go to state 99
    factor                         shift and go to state 100
    subexpresion                   shift and go to state 221
    callfunc                       shift and go to state 105
    exp                            shift and go to state 107

state 201

    (57) o -> OR neur9_2 . subexpresion
    (53) subexpresion -> . exp neur10 o
    (60) exp -> . nexp p neur12
    (75) nexp -> . termino neur5 q
    (82) termino -> . factor neur4 n
    (89) factor -> . ( neur6 expresion ) neur7
    (90) factor -> . varcte neur1
    (94) varcte -> . ID r neurVar
    (95) varcte -> . CTEE neurCteE
    (96) varcte -> . CTEF neurCteF
    (97) varcte -> . CTEBOOL neurCteB
    (98) varcte -> . callfunc
    (99) varcte -> . CTECHAR neurCteCh
    (123) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    termino                        shift and go to state 95
    varcte                         shift and go to state 97
    nexp                           shift and go to state 99
    factor                         shift and go to state 100
    subexpresion                   shift and go to state 222
    callfunc                       shift and go to state 105
    exp                            shift and go to state 107

state 202

    (49) for -> FOR ( asignacion expresion asignacion ) . bloque ;
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 223

state 203

    (42) asiglista -> NEW LIST ( . )

    )               shift and go to state 224


state 204

    (43) if -> IF ( expresion ) neur13 bloque . l ;
    (45) l -> . empty neur15
    (46) l -> . ELSE neur14 bloque
    (136) empty -> .

    ELSE            shift and go to state 226
    ;               reduce using rule 136 (empty -> .)

    l                              shift and go to state 225
    empty                          shift and go to state 227

state 205

    (121) play -> PLAY ( NOTA , CTEE ) ; .

    ID              reduce using rule 121 (play -> PLAY ( NOTA , CTEE ) ; .)
    IF              reduce using rule 121 (play -> PLAY ( NOTA , CTEE ) ; .)
    FOR             reduce using rule 121 (play -> PLAY ( NOTA , CTEE ) ; .)
    RETURN          reduce using rule 121 (play -> PLAY ( NOTA , CTEE ) ; .)
    WHILE           reduce using rule 121 (play -> PLAY ( NOTA , CTEE ) ; .)
    PLAY            reduce using rule 121 (play -> PLAY ( NOTA , CTEE ) ; .)
    PRINT           reduce using rule 121 (play -> PLAY ( NOTA , CTEE ) ; .)
    }               reduce using rule 121 (play -> PLAY ( NOTA , CTEE ) ; .)


state 206

    (118) while -> WHILE ( neur16 expresion ) neur13 bloque . neur17 ;
    (120) neur17 -> .

    ;               reduce using rule 120 (neur17 -> .)

    neur17                         shift and go to state 228

state 207

    (78) q -> + neur3_1 nexp .

    EQ              reduce using rule 78 (q -> + neur3_1 nexp .)
    NOTEQ           reduce using rule 78 (q -> + neur3_1 nexp .)
    >               reduce using rule 78 (q -> + neur3_1 nexp .)
    <               reduce using rule 78 (q -> + neur3_1 nexp .)
    MTHANEQ         reduce using rule 78 (q -> + neur3_1 nexp .)
    LTHANEQ         reduce using rule 78 (q -> + neur3_1 nexp .)
    AND             reduce using rule 78 (q -> + neur3_1 nexp .)
    OR              reduce using rule 78 (q -> + neur3_1 nexp .)
    ;               reduce using rule 78 (q -> + neur3_1 nexp .)
    )               reduce using rule 78 (q -> + neur3_1 nexp .)
    ID              reduce using rule 78 (q -> + neur3_1 nexp .)
    ,               reduce using rule 78 (q -> + neur3_1 nexp .)


state 208

    (79) q -> - neur3_2 nexp .

    EQ              reduce using rule 79 (q -> - neur3_2 nexp .)
    NOTEQ           reduce using rule 79 (q -> - neur3_2 nexp .)
    >               reduce using rule 79 (q -> - neur3_2 nexp .)
    <               reduce using rule 79 (q -> - neur3_2 nexp .)
    MTHANEQ         reduce using rule 79 (q -> - neur3_2 nexp .)
    LTHANEQ         reduce using rule 79 (q -> - neur3_2 nexp .)
    AND             reduce using rule 79 (q -> - neur3_2 nexp .)
    OR              reduce using rule 79 (q -> - neur3_2 nexp .)
    ;               reduce using rule 79 (q -> - neur3_2 nexp .)
    )               reduce using rule 79 (q -> - neur3_2 nexp .)
    ID              reduce using rule 79 (q -> - neur3_2 nexp .)
    ,               reduce using rule 79 (q -> - neur3_2 nexp .)


state 209

    (89) factor -> ( neur6 expresion ) neur7 .

    *               reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    /               reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    +               reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    -               reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    AND             reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    OR              reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    ;               reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    )               reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    ID              reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    ,               reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    EQ              reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    NOTEQ           reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    >               reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    <               reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    MTHANEQ         reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)
    LTHANEQ         reduce using rule 89 (factor -> ( neur6 expresion ) neur7 .)


state 210

    (85) n -> * neur2_1 termino .

    +               reduce using rule 85 (n -> * neur2_1 termino .)
    -               reduce using rule 85 (n -> * neur2_1 termino .)
    EQ              reduce using rule 85 (n -> * neur2_1 termino .)
    NOTEQ           reduce using rule 85 (n -> * neur2_1 termino .)
    >               reduce using rule 85 (n -> * neur2_1 termino .)
    <               reduce using rule 85 (n -> * neur2_1 termino .)
    MTHANEQ         reduce using rule 85 (n -> * neur2_1 termino .)
    LTHANEQ         reduce using rule 85 (n -> * neur2_1 termino .)
    AND             reduce using rule 85 (n -> * neur2_1 termino .)
    OR              reduce using rule 85 (n -> * neur2_1 termino .)
    ;               reduce using rule 85 (n -> * neur2_1 termino .)
    )               reduce using rule 85 (n -> * neur2_1 termino .)
    ID              reduce using rule 85 (n -> * neur2_1 termino .)
    ,               reduce using rule 85 (n -> * neur2_1 termino .)


state 211

    (86) n -> / neur2_2 termino .

    +               reduce using rule 86 (n -> / neur2_2 termino .)
    -               reduce using rule 86 (n -> / neur2_2 termino .)
    EQ              reduce using rule 86 (n -> / neur2_2 termino .)
    NOTEQ           reduce using rule 86 (n -> / neur2_2 termino .)
    >               reduce using rule 86 (n -> / neur2_2 termino .)
    <               reduce using rule 86 (n -> / neur2_2 termino .)
    MTHANEQ         reduce using rule 86 (n -> / neur2_2 termino .)
    LTHANEQ         reduce using rule 86 (n -> / neur2_2 termino .)
    AND             reduce using rule 86 (n -> / neur2_2 termino .)
    OR              reduce using rule 86 (n -> / neur2_2 termino .)
    ;               reduce using rule 86 (n -> / neur2_2 termino .)
    )               reduce using rule 86 (n -> / neur2_2 termino .)
    ID              reduce using rule 86 (n -> / neur2_2 termino .)
    ,               reduce using rule 86 (n -> / neur2_2 termino .)


state 212

    (125) s -> expresion t .

    )               reduce using rule 125 (s -> expresion t .)


state 213

    (126) t -> empty .

    )               reduce using rule 126 (t -> empty .)


state 214

    (127) t -> , . s
    (124) s -> . empty
    (125) s -> . expresion t
    (136) empty -> .
    (50) expresion -> . m subexpresion
    (51) m -> . empty
    (52) m -> . NOT

    )               reduce using rule 136 (empty -> .)
    (               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    CTEE            reduce using rule 136 (empty -> .)
    CTEF            reduce using rule 136 (empty -> .)
    CTEBOOL         reduce using rule 136 (empty -> .)
    CTECHAR         reduce using rule 136 (empty -> .)
    CALL            reduce using rule 136 (empty -> .)
    NOT             shift and go to state 81

    expresion                      shift and go to state 186
    m                              shift and go to state 80
    s                              shift and go to state 229
    empty                          shift and go to state 188

state 215

    (123) callfunc -> CALL ID ( s ) . ;

    ;               shift and go to state 230


state 216

    (113) inlistset -> SET ( . CTEE , expresion )

    CTEE            shift and go to state 231


state 217

    (116) getlist -> GET ( . expresion )
    (50) expresion -> . m subexpresion
    (51) m -> . empty
    (52) m -> . NOT
    (136) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    CTEE            reduce using rule 136 (empty -> .)
    CTEF            reduce using rule 136 (empty -> .)
    CTEBOOL         reduce using rule 136 (empty -> .)
    CTECHAR         reduce using rule 136 (empty -> .)
    CALL            reduce using rule 136 (empty -> .)

    expresion                      shift and go to state 232
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 218

    (117) removelist -> REMOVE ( . expresion )
    (50) expresion -> . m subexpresion
    (51) m -> . empty
    (52) m -> . NOT
    (136) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    CTEE            reduce using rule 136 (empty -> .)
    CTEF            reduce using rule 136 (empty -> .)
    CTEBOOL         reduce using rule 136 (empty -> .)
    CTECHAR         reduce using rule 136 (empty -> .)
    CALL            reduce using rule 136 (empty -> .)

    expresion                      shift and go to state 233
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 219

    (115) length -> LENGTH ( . )

    )               shift and go to state 234


state 220

    (114) append -> APPEND ( . expresion )
    (50) expresion -> . m subexpresion
    (51) m -> . empty
    (52) m -> . NOT
    (136) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    CTEE            reduce using rule 136 (empty -> .)
    CTEF            reduce using rule 136 (empty -> .)
    CTEBOOL         reduce using rule 136 (empty -> .)
    CTECHAR         reduce using rule 136 (empty -> .)
    CALL            reduce using rule 136 (empty -> .)

    expresion                      shift and go to state 235
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 221

    (56) o -> AND neur9_1 subexpresion .

    ;               reduce using rule 56 (o -> AND neur9_1 subexpresion .)
    )               reduce using rule 56 (o -> AND neur9_1 subexpresion .)
    ID              reduce using rule 56 (o -> AND neur9_1 subexpresion .)
    ,               reduce using rule 56 (o -> AND neur9_1 subexpresion .)


state 222

    (57) o -> OR neur9_2 subexpresion .

    ;               reduce using rule 57 (o -> OR neur9_2 subexpresion .)
    )               reduce using rule 57 (o -> OR neur9_2 subexpresion .)
    ID              reduce using rule 57 (o -> OR neur9_2 subexpresion .)
    ,               reduce using rule 57 (o -> OR neur9_2 subexpresion .)


state 223

    (49) for -> FOR ( asignacion expresion asignacion ) bloque . ;

    ;               shift and go to state 236


state 224

    (42) asiglista -> NEW LIST ( ) .

    ;               reduce using rule 42 (asiglista -> NEW LIST ( ) .)


state 225

    (43) if -> IF ( expresion ) neur13 bloque l . ;

    ;               shift and go to state 237


state 226

    (46) l -> ELSE . neur14 bloque
    (47) neur14 -> .

    {               reduce using rule 47 (neur14 -> .)

    neur14                         shift and go to state 238

state 227

    (45) l -> empty . neur15
    (48) neur15 -> .

    ;               reduce using rule 48 (neur15 -> .)

    neur15                         shift and go to state 239

state 228

    (118) while -> WHILE ( neur16 expresion ) neur13 bloque neur17 . ;

    ;               shift and go to state 240


state 229

    (127) t -> , s .

    )               reduce using rule 127 (t -> , s .)


state 230

    (123) callfunc -> CALL ID ( s ) ; .

    *               reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    /               reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    +               reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    -               reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    AND             reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    OR              reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    ;               reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    )               reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    ID              reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    ,               reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    EQ              reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    NOTEQ           reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    >               reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    <               reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    MTHANEQ         reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)
    LTHANEQ         reduce using rule 123 (callfunc -> CALL ID ( s ) ; .)


state 231

    (113) inlistset -> SET ( CTEE . , expresion )

    ,               shift and go to state 241


state 232

    (116) getlist -> GET ( expresion . )

    )               shift and go to state 242


state 233

    (117) removelist -> REMOVE ( expresion . )

    )               shift and go to state 243


state 234

    (115) length -> LENGTH ( ) .

    *               reduce using rule 115 (length -> LENGTH ( ) .)
    /               reduce using rule 115 (length -> LENGTH ( ) .)
    +               reduce using rule 115 (length -> LENGTH ( ) .)
    -               reduce using rule 115 (length -> LENGTH ( ) .)
    EQ              reduce using rule 115 (length -> LENGTH ( ) .)
    NOTEQ           reduce using rule 115 (length -> LENGTH ( ) .)
    >               reduce using rule 115 (length -> LENGTH ( ) .)
    <               reduce using rule 115 (length -> LENGTH ( ) .)
    MTHANEQ         reduce using rule 115 (length -> LENGTH ( ) .)
    LTHANEQ         reduce using rule 115 (length -> LENGTH ( ) .)
    AND             reduce using rule 115 (length -> LENGTH ( ) .)
    OR              reduce using rule 115 (length -> LENGTH ( ) .)
    ;               reduce using rule 115 (length -> LENGTH ( ) .)
    )               reduce using rule 115 (length -> LENGTH ( ) .)
    ID              reduce using rule 115 (length -> LENGTH ( ) .)
    ,               reduce using rule 115 (length -> LENGTH ( ) .)


state 235

    (114) append -> APPEND ( expresion . )

    )               shift and go to state 244


state 236

    (49) for -> FOR ( asignacion expresion asignacion ) bloque ; .

    ID              reduce using rule 49 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    IF              reduce using rule 49 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    FOR             reduce using rule 49 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    RETURN          reduce using rule 49 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    WHILE           reduce using rule 49 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    PLAY            reduce using rule 49 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    PRINT           reduce using rule 49 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    }               reduce using rule 49 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)


state 237

    (43) if -> IF ( expresion ) neur13 bloque l ; .

    ID              reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)
    IF              reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)
    FOR             reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)
    RETURN          reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)
    WHILE           reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)
    PLAY            reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)
    PRINT           reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)
    }               reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)


state 238

    (46) l -> ELSE neur14 . bloque
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 245

state 239

    (45) l -> empty neur15 .

    ;               reduce using rule 45 (l -> empty neur15 .)


state 240

    (118) while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .

    ID              reduce using rule 118 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)
    IF              reduce using rule 118 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)
    FOR             reduce using rule 118 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)
    RETURN          reduce using rule 118 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)
    WHILE           reduce using rule 118 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)
    PLAY            reduce using rule 118 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)
    PRINT           reduce using rule 118 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)
    }               reduce using rule 118 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)


state 241

    (113) inlistset -> SET ( CTEE , . expresion )
    (50) expresion -> . m subexpresion
    (51) m -> . empty
    (52) m -> . NOT
    (136) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 136 (empty -> .)
    ID              reduce using rule 136 (empty -> .)
    CTEE            reduce using rule 136 (empty -> .)
    CTEF            reduce using rule 136 (empty -> .)
    CTEBOOL         reduce using rule 136 (empty -> .)
    CTECHAR         reduce using rule 136 (empty -> .)
    CALL            reduce using rule 136 (empty -> .)

    expresion                      shift and go to state 246
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 242

    (116) getlist -> GET ( expresion ) .

    *               reduce using rule 116 (getlist -> GET ( expresion ) .)
    /               reduce using rule 116 (getlist -> GET ( expresion ) .)
    +               reduce using rule 116 (getlist -> GET ( expresion ) .)
    -               reduce using rule 116 (getlist -> GET ( expresion ) .)
    EQ              reduce using rule 116 (getlist -> GET ( expresion ) .)
    NOTEQ           reduce using rule 116 (getlist -> GET ( expresion ) .)
    >               reduce using rule 116 (getlist -> GET ( expresion ) .)
    <               reduce using rule 116 (getlist -> GET ( expresion ) .)
    MTHANEQ         reduce using rule 116 (getlist -> GET ( expresion ) .)
    LTHANEQ         reduce using rule 116 (getlist -> GET ( expresion ) .)
    AND             reduce using rule 116 (getlist -> GET ( expresion ) .)
    OR              reduce using rule 116 (getlist -> GET ( expresion ) .)
    ;               reduce using rule 116 (getlist -> GET ( expresion ) .)
    )               reduce using rule 116 (getlist -> GET ( expresion ) .)
    ID              reduce using rule 116 (getlist -> GET ( expresion ) .)
    ,               reduce using rule 116 (getlist -> GET ( expresion ) .)


state 243

    (117) removelist -> REMOVE ( expresion ) .

    *               reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    /               reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    +               reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    -               reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    EQ              reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    NOTEQ           reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    >               reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    <               reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    MTHANEQ         reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    LTHANEQ         reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    AND             reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    OR              reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    ;               reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    )               reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    ID              reduce using rule 117 (removelist -> REMOVE ( expresion ) .)
    ,               reduce using rule 117 (removelist -> REMOVE ( expresion ) .)


state 244

    (114) append -> APPEND ( expresion ) .

    *               reduce using rule 114 (append -> APPEND ( expresion ) .)
    /               reduce using rule 114 (append -> APPEND ( expresion ) .)
    +               reduce using rule 114 (append -> APPEND ( expresion ) .)
    -               reduce using rule 114 (append -> APPEND ( expresion ) .)
    EQ              reduce using rule 114 (append -> APPEND ( expresion ) .)
    NOTEQ           reduce using rule 114 (append -> APPEND ( expresion ) .)
    >               reduce using rule 114 (append -> APPEND ( expresion ) .)
    <               reduce using rule 114 (append -> APPEND ( expresion ) .)
    MTHANEQ         reduce using rule 114 (append -> APPEND ( expresion ) .)
    LTHANEQ         reduce using rule 114 (append -> APPEND ( expresion ) .)
    AND             reduce using rule 114 (append -> APPEND ( expresion ) .)
    OR              reduce using rule 114 (append -> APPEND ( expresion ) .)
    ;               reduce using rule 114 (append -> APPEND ( expresion ) .)
    )               reduce using rule 114 (append -> APPEND ( expresion ) .)
    ID              reduce using rule 114 (append -> APPEND ( expresion ) .)
    ,               reduce using rule 114 (append -> APPEND ( expresion ) .)


state 245

    (46) l -> ELSE neur14 bloque .

    ;               reduce using rule 46 (l -> ELSE neur14 bloque .)


state 246

    (113) inlistset -> SET ( CTEE , expresion . )

    )               shift and go to state 247


state 247

    (113) inlistset -> SET ( CTEE , expresion ) .

    *               reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    /               reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    +               reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    -               reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    EQ              reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    NOTEQ           reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    >               reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    <               reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    MTHANEQ         reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    LTHANEQ         reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    AND             reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    OR              reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    ;               reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    )               reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    ID              reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)
    ,               reduce using rule 113 (inlistset -> SET ( CTEE , expresion ) .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 103 resolved as shift
WARNING: reduce/reduce conflict in state 13 resolved using rule (a -> empty)
WARNING: rejected rule (b -> empty) in state 13
WARNING: reduce/reduce conflict in state 24 resolved using rule (c -> empty)
WARNING: rejected rule (d -> empty) in state 24
WARNING: reduce/reduce conflict in state 50 resolved using rule (f -> empty)
WARNING: rejected rule (g -> empty) in state 50
WARNING: reduce/reduce conflict in state 83 resolved using rule (i -> empty)
WARNING: rejected rule (j -> empty) in state 83
WARNING: Rule (b -> empty) is never reduced
WARNING: Rule (d -> empty) is never reduced
WARNING: Rule (g -> empty) is never reduced
WARNING: Rule (j -> empty) is never reduced
