Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programa
Rule 1     programa -> creadirprocglobal a c cancion
Rule 2     creadirprocglobal -> <empty>
Rule 3     a -> empty
Rule 4     a -> vars b
Rule 5     b -> empty
Rule 6     b -> a
Rule 7     c -> empty
Rule 8     c -> funcion d
Rule 9     d -> empty
Rule 10    d -> c
Rule 11    vars -> VAR v : tipo ;
Rule 12    v -> ID
Rule 13    funcion -> FUNC tipo ID meterfuncion ( params ) f bloque
Rule 14    meterfuncion -> <empty>
Rule 15    f -> empty
Rule 16    f -> vars g
Rule 17    g -> empty
Rule 18    g -> f
Rule 19    params -> empty
Rule 20    params -> tipo ID meterparams h
Rule 21    meterparams -> <empty>
Rule 22    h -> empty
Rule 23    h -> , params
Rule 24    i -> empty
Rule 25    i -> estatuto j
Rule 26    j -> empty
Rule 27    j -> i
Rule 28    bloque -> { i }
Rule 29    cancion -> CANCION ( CTEE ) metercancion f bloque
Rule 30    metercancion -> <empty>
Rule 31    estatuto -> asignacion
Rule 32    estatuto -> if
Rule 33    estatuto -> for
Rule 34    estatuto -> return
Rule 35    estatuto -> while
Rule 36    estatuto -> play
Rule 37    estatuto -> print
Rule 38    asignacion -> ID = neur8 k ;
Rule 39    neur8 -> <empty>
Rule 40    k -> expresion
Rule 41    k -> asiglista
Rule 42    asiglista -> NEW LIST ( )
Rule 43    if -> IF ( expresion ) neur13 bloque l ;
Rule 44    neur13 -> <empty>
Rule 45    l -> empty neur15
Rule 46    l -> ELSE neur14 bloque
Rule 47    neur14 -> <empty>
Rule 48    neur15 -> <empty>
Rule 49    for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
Rule 50    neur18 -> <empty>
Rule 51    neur19 -> <empty>
Rule 52    neur21 -> <empty>
Rule 53    neur20 -> <empty>
Rule 54    expresion -> m subexpresion
Rule 55    m -> empty
Rule 56    m -> NOT
Rule 57    subexpresion -> exp neur10 o
Rule 58    neur10 -> <empty>
Rule 59    o -> empty
Rule 60    o -> AND neur9_1 subexpresion
Rule 61    o -> OR neur9_2 subexpresion
Rule 62    neur9_1 -> <empty>
Rule 63    neur9_2 -> <empty>
Rule 64    exp -> nexp p neur12
Rule 65    neur12 -> <empty>
Rule 66    p -> empty
Rule 67    p -> EQ neur11_1 nexp
Rule 68    p -> NOTEQ neur11_2 nexp
Rule 69    p -> > neur11_3 nexp
Rule 70    p -> < neur11_4 nexp
Rule 71    p -> MTHANEQ neur11_5 nexp
Rule 72    p -> LTHANEQ neur11_6 nexp
Rule 73    neur11_1 -> <empty>
Rule 74    neur11_2 -> <empty>
Rule 75    neur11_3 -> <empty>
Rule 76    neur11_4 -> <empty>
Rule 77    neur11_5 -> <empty>
Rule 78    neur11_6 -> <empty>
Rule 79    nexp -> termino neur5 q
Rule 80    neur5 -> <empty>
Rule 81    q -> empty
Rule 82    q -> + neur3_1 nexp
Rule 83    q -> - neur3_2 nexp
Rule 84    neur3_1 -> <empty>
Rule 85    neur3_2 -> <empty>
Rule 86    termino -> factor neur4 n
Rule 87    neur4 -> <empty>
Rule 88    n -> empty
Rule 89    n -> * neur2_1 termino
Rule 90    n -> / neur2_2 termino
Rule 91    neur2_1 -> <empty>
Rule 92    neur2_2 -> <empty>
Rule 93    factor -> ( neur6 expresion ) neur7
Rule 94    factor -> varcte neur1
Rule 95    neur6 -> <empty>
Rule 96    neur7 -> <empty>
Rule 97    neur1 -> <empty>
Rule 98    varcte -> ID r neurVar
Rule 99    varcte -> CTEE neurCteE
Rule 100   varcte -> CTEF neurCteF
Rule 101   varcte -> CTEBOOL neurCteB
Rule 102   varcte -> callfunc
Rule 103   varcte -> CTECHAR neurCteCh
Rule 104   neurVar -> <empty>
Rule 105   neurCteE -> <empty>
Rule 106   neurCteF -> <empty>
Rule 107   neurCteB -> <empty>
Rule 108   neurCteCh -> <empty>
Rule 109   r -> empty
Rule 110   r -> oplista
Rule 111   oplista -> ID . x
Rule 112   x -> inlistset
Rule 113   x -> append
Rule 114   x -> length
Rule 115   x -> getlist
Rule 116   x -> removelist
Rule 117   inlistset -> SET ( CTEE , expresion )
Rule 118   append -> APPEND ( expresion )
Rule 119   length -> LENGTH ( )
Rule 120   getlist -> GET ( expresion )
Rule 121   removelist -> REMOVE ( expresion )
Rule 122   while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ;
Rule 123   neur16 -> <empty>
Rule 124   neur17 -> <empty>
Rule 125   play -> PLAY ( NOTA , CTEE ) ;
Rule 126   print -> PRINT expresion ;
Rule 127   callfunc -> CALL ID ( s ) ;
Rule 128   s -> empty
Rule 129   s -> expresion t
Rule 130   t -> empty
Rule 131   t -> , s
Rule 132   return -> RETURN ( expresion ) ;
Rule 133   tipo -> u y
Rule 134   u -> empty
Rule 135   u -> LIST
Rule 136   y -> INT
Rule 137   y -> CHAR
Rule 138   y -> FLOAT
Rule 139   y -> BOOL
Rule 140   empty -> <empty>

Terminals, with rules where they appear

(                    : 13 29 42 43 49 93 117 118 119 120 121 122 125 127 132
)                    : 13 29 42 43 49 93 117 118 119 120 121 122 125 127 132
*                    : 89
+                    : 82
,                    : 23 117 125 131
-                    : 83
.                    : 111
/                    : 90
:                    : 11
;                    : 11 38 43 49 49 122 125 126 127 132
<                    : 70
=                    : 38
>                    : 69
AND                  : 60
APPEND               : 118
BOOL                 : 139
CALL                 : 127
CANCION              : 29
CHAR                 : 137
CTEBOOL              : 101
CTECHAR              : 103
CTEE                 : 29 99 117 125
CTEF                 : 100
ELSE                 : 46
EQ                   : 67
FLOAT                : 138
FOR                  : 49
FUNC                 : 13
GET                  : 120
ID                   : 12 13 20 38 98 111 127
IF                   : 43
INT                  : 136
LENGTH               : 119
LIST                 : 42 135
LTHANEQ              : 72
MTHANEQ              : 71
NEW                  : 42
NOT                  : 56
NOTA                 : 125
NOTEQ                : 68
OR                   : 61
PLAY                 : 125
PRINT                : 126
REMOVE               : 121
RETURN               : 132
SET                  : 117
VAR                  : 11
WHILE                : 122
error                : 
{                    : 28
}                    : 28

Nonterminals, with rules where they appear

a                    : 1 6
append               : 113
asiglista            : 41
asignacion           : 31 49 49
b                    : 4
bloque               : 13 29 43 46 49 122
c                    : 1 10
callfunc             : 102
cancion              : 1
creadirprocglobal    : 1
d                    : 8
empty                : 3 5 7 9 15 17 19 22 24 26 45 55 59 66 81 88 109 128 130 134
estatuto             : 25
exp                  : 57
expresion            : 40 43 49 93 117 118 120 121 122 126 129 132
f                    : 13 18 29
factor               : 86
for                  : 33
funcion              : 8
g                    : 16
getlist              : 115
h                    : 20
i                    : 27 28
if                   : 32
inlistset            : 112
j                    : 25
k                    : 38
l                    : 43
length               : 114
m                    : 54
metercancion         : 29
meterfuncion         : 13
meterparams          : 20
n                    : 86
neur1                : 94
neur10               : 57
neur11_1             : 67
neur11_2             : 68
neur11_3             : 69
neur11_4             : 70
neur11_5             : 71
neur11_6             : 72
neur12               : 64
neur13               : 43 122
neur14               : 46
neur15               : 45
neur16               : 122
neur17               : 122
neur18               : 49
neur19               : 49
neur20               : 49
neur21               : 49
neur2_1              : 89
neur2_2              : 90
neur3_1              : 82
neur3_2              : 83
neur4                : 86
neur5                : 79
neur6                : 93
neur7                : 93
neur8                : 38
neur9_1              : 60
neur9_2              : 61
neurCteB             : 101
neurCteCh            : 103
neurCteE             : 99
neurCteF             : 100
neurVar              : 98
nexp                 : 64 67 68 69 70 71 72 82 83
o                    : 57
oplista              : 110
p                    : 64
params               : 13 23
play                 : 36
print                : 37
programa             : 0
q                    : 79
r                    : 98
removelist           : 116
return               : 34
s                    : 127 131
subexpresion         : 54 60 61
t                    : 129
termino              : 79 89 90
tipo                 : 11 13 20
u                    : 133
v                    : 11
varcte               : 94
vars                 : 4 16
while                : 35
x                    : 111
y                    : 133

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . creadirprocglobal a c cancion
    (2) creadirprocglobal -> .

    VAR             reduce using rule 2 (creadirprocglobal -> .)
    FUNC            reduce using rule 2 (creadirprocglobal -> .)
    CANCION         reduce using rule 2 (creadirprocglobal -> .)

    programa                       shift and go to state 1
    creadirprocglobal              shift and go to state 2

state 1

    (0) S' -> programa .



state 2

    (1) programa -> creadirprocglobal . a c cancion
    (3) a -> . empty
    (4) a -> . vars b
    (140) empty -> .
    (11) vars -> . VAR v : tipo ;

    FUNC            reduce using rule 140 (empty -> .)
    CANCION         reduce using rule 140 (empty -> .)
    VAR             shift and go to state 5

    a                              shift and go to state 3
    vars                           shift and go to state 4
    empty                          shift and go to state 6

state 3

    (1) programa -> creadirprocglobal a . c cancion
    (7) c -> . empty
    (8) c -> . funcion d
    (140) empty -> .
    (13) funcion -> . FUNC tipo ID meterfuncion ( params ) f bloque

    CANCION         reduce using rule 140 (empty -> .)
    FUNC            shift and go to state 8

    c                              shift and go to state 7
    empty                          shift and go to state 9
    funcion                        shift and go to state 10

state 4

    (4) a -> vars . b
    (5) b -> . empty
    (6) b -> . a
    (140) empty -> .
    (3) a -> . empty
    (4) a -> . vars b
    (11) vars -> . VAR v : tipo ;

    FUNC            reduce using rule 140 (empty -> .)
    CANCION         reduce using rule 140 (empty -> .)
    VAR             shift and go to state 5

    a                              shift and go to state 11
    b                              shift and go to state 12
    vars                           shift and go to state 4
    empty                          shift and go to state 13

state 5

    (11) vars -> VAR . v : tipo ;
    (12) v -> . ID

    ID              shift and go to state 15

    v                              shift and go to state 14

state 6

    (3) a -> empty .

    FUNC            reduce using rule 3 (a -> empty .)
    CANCION         reduce using rule 3 (a -> empty .)


state 7

    (1) programa -> creadirprocglobal a c . cancion
    (29) cancion -> . CANCION ( CTEE ) metercancion f bloque

    CANCION         shift and go to state 16

    cancion                        shift and go to state 17

state 8

    (13) funcion -> FUNC . tipo ID meterfuncion ( params ) f bloque
    (133) tipo -> . u y
    (134) u -> . empty
    (135) u -> . LIST
    (140) empty -> .

    LIST            shift and go to state 19
    INT             reduce using rule 140 (empty -> .)
    CHAR            reduce using rule 140 (empty -> .)
    FLOAT           reduce using rule 140 (empty -> .)
    BOOL            reduce using rule 140 (empty -> .)

    tipo                           shift and go to state 18
    u                              shift and go to state 20
    empty                          shift and go to state 21

state 9

    (7) c -> empty .

    CANCION         reduce using rule 7 (c -> empty .)


state 10

    (8) c -> funcion . d
    (9) d -> . empty
    (10) d -> . c
    (140) empty -> .
    (7) c -> . empty
    (8) c -> . funcion d
    (13) funcion -> . FUNC tipo ID meterfuncion ( params ) f bloque

    CANCION         reduce using rule 140 (empty -> .)
    FUNC            shift and go to state 8

    c                              shift and go to state 22
    d                              shift and go to state 23
    empty                          shift and go to state 24
    funcion                        shift and go to state 10

state 11

    (6) b -> a .

    FUNC            reduce using rule 6 (b -> a .)
    CANCION         reduce using rule 6 (b -> a .)


state 12

    (4) a -> vars b .

    FUNC            reduce using rule 4 (a -> vars b .)
    CANCION         reduce using rule 4 (a -> vars b .)


state 13

    (5) b -> empty .
    (3) a -> empty .

  ! reduce/reduce conflict for FUNC resolved using rule 3 (a -> empty .)
  ! reduce/reduce conflict for CANCION resolved using rule 3 (a -> empty .)
    FUNC            reduce using rule 3 (a -> empty .)
    CANCION         reduce using rule 3 (a -> empty .)

  ! FUNC            [ reduce using rule 5 (b -> empty .) ]
  ! CANCION         [ reduce using rule 5 (b -> empty .) ]


state 14

    (11) vars -> VAR v . : tipo ;

    :               shift and go to state 25


state 15

    (12) v -> ID .

    :               reduce using rule 12 (v -> ID .)


state 16

    (29) cancion -> CANCION . ( CTEE ) metercancion f bloque

    (               shift and go to state 26


state 17

    (1) programa -> creadirprocglobal a c cancion .

    $end            reduce using rule 1 (programa -> creadirprocglobal a c cancion .)


state 18

    (13) funcion -> FUNC tipo . ID meterfuncion ( params ) f bloque

    ID              shift and go to state 27


state 19

    (135) u -> LIST .

    INT             reduce using rule 135 (u -> LIST .)
    CHAR            reduce using rule 135 (u -> LIST .)
    FLOAT           reduce using rule 135 (u -> LIST .)
    BOOL            reduce using rule 135 (u -> LIST .)


state 20

    (133) tipo -> u . y
    (136) y -> . INT
    (137) y -> . CHAR
    (138) y -> . FLOAT
    (139) y -> . BOOL

    INT             shift and go to state 28
    CHAR            shift and go to state 30
    FLOAT           shift and go to state 29
    BOOL            shift and go to state 32

    y                              shift and go to state 31

state 21

    (134) u -> empty .

    INT             reduce using rule 134 (u -> empty .)
    CHAR            reduce using rule 134 (u -> empty .)
    FLOAT           reduce using rule 134 (u -> empty .)
    BOOL            reduce using rule 134 (u -> empty .)


state 22

    (10) d -> c .

    CANCION         reduce using rule 10 (d -> c .)


state 23

    (8) c -> funcion d .

    CANCION         reduce using rule 8 (c -> funcion d .)


state 24

    (9) d -> empty .
    (7) c -> empty .

  ! reduce/reduce conflict for CANCION resolved using rule 7 (c -> empty .)
    CANCION         reduce using rule 7 (c -> empty .)

  ! CANCION         [ reduce using rule 9 (d -> empty .) ]


state 25

    (11) vars -> VAR v : . tipo ;
    (133) tipo -> . u y
    (134) u -> . empty
    (135) u -> . LIST
    (140) empty -> .

    LIST            shift and go to state 19
    INT             reduce using rule 140 (empty -> .)
    CHAR            reduce using rule 140 (empty -> .)
    FLOAT           reduce using rule 140 (empty -> .)
    BOOL            reduce using rule 140 (empty -> .)

    u                              shift and go to state 20
    empty                          shift and go to state 21
    tipo                           shift and go to state 33

state 26

    (29) cancion -> CANCION ( . CTEE ) metercancion f bloque

    CTEE            shift and go to state 34


state 27

    (13) funcion -> FUNC tipo ID . meterfuncion ( params ) f bloque
    (14) meterfuncion -> .

    (               reduce using rule 14 (meterfuncion -> .)

    meterfuncion                   shift and go to state 35

state 28

    (136) y -> INT .

    ID              reduce using rule 136 (y -> INT .)
    ;               reduce using rule 136 (y -> INT .)


state 29

    (138) y -> FLOAT .

    ID              reduce using rule 138 (y -> FLOAT .)
    ;               reduce using rule 138 (y -> FLOAT .)


state 30

    (137) y -> CHAR .

    ID              reduce using rule 137 (y -> CHAR .)
    ;               reduce using rule 137 (y -> CHAR .)


state 31

    (133) tipo -> u y .

    ID              reduce using rule 133 (tipo -> u y .)
    ;               reduce using rule 133 (tipo -> u y .)


state 32

    (139) y -> BOOL .

    ID              reduce using rule 139 (y -> BOOL .)
    ;               reduce using rule 139 (y -> BOOL .)


state 33

    (11) vars -> VAR v : tipo . ;

    ;               shift and go to state 36


state 34

    (29) cancion -> CANCION ( CTEE . ) metercancion f bloque

    )               shift and go to state 37


state 35

    (13) funcion -> FUNC tipo ID meterfuncion . ( params ) f bloque

    (               shift and go to state 38


state 36

    (11) vars -> VAR v : tipo ; .

    VAR             reduce using rule 11 (vars -> VAR v : tipo ; .)
    FUNC            reduce using rule 11 (vars -> VAR v : tipo ; .)
    CANCION         reduce using rule 11 (vars -> VAR v : tipo ; .)
    {               reduce using rule 11 (vars -> VAR v : tipo ; .)


state 37

    (29) cancion -> CANCION ( CTEE ) . metercancion f bloque
    (30) metercancion -> .

    VAR             reduce using rule 30 (metercancion -> .)
    {               reduce using rule 30 (metercancion -> .)

    metercancion                   shift and go to state 39

state 38

    (13) funcion -> FUNC tipo ID meterfuncion ( . params ) f bloque
    (19) params -> . empty
    (20) params -> . tipo ID meterparams h
    (140) empty -> .
    (133) tipo -> . u y
    (134) u -> . empty
    (135) u -> . LIST

    )               reduce using rule 140 (empty -> .)
    INT             reduce using rule 140 (empty -> .)
    CHAR            reduce using rule 140 (empty -> .)
    FLOAT           reduce using rule 140 (empty -> .)
    BOOL            reduce using rule 140 (empty -> .)
    LIST            shift and go to state 19

    tipo                           shift and go to state 40
    params                         shift and go to state 41
    u                              shift and go to state 20
    empty                          shift and go to state 42

state 39

    (29) cancion -> CANCION ( CTEE ) metercancion . f bloque
    (15) f -> . empty
    (16) f -> . vars g
    (140) empty -> .
    (11) vars -> . VAR v : tipo ;

    {               reduce using rule 140 (empty -> .)
    VAR             shift and go to state 5

    vars                           shift and go to state 43
    f                              shift and go to state 44
    empty                          shift and go to state 45

state 40

    (20) params -> tipo . ID meterparams h

    ID              shift and go to state 46


state 41

    (13) funcion -> FUNC tipo ID meterfuncion ( params . ) f bloque

    )               shift and go to state 47


state 42

    (19) params -> empty .
    (134) u -> empty .

    )               reduce using rule 19 (params -> empty .)
    INT             reduce using rule 134 (u -> empty .)
    CHAR            reduce using rule 134 (u -> empty .)
    FLOAT           reduce using rule 134 (u -> empty .)
    BOOL            reduce using rule 134 (u -> empty .)


state 43

    (16) f -> vars . g
    (17) g -> . empty
    (18) g -> . f
    (140) empty -> .
    (15) f -> . empty
    (16) f -> . vars g
    (11) vars -> . VAR v : tipo ;

    {               reduce using rule 140 (empty -> .)
    VAR             shift and go to state 5

    g                              shift and go to state 48
    f                              shift and go to state 49
    vars                           shift and go to state 43
    empty                          shift and go to state 50

state 44

    (29) cancion -> CANCION ( CTEE ) metercancion f . bloque
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 52

state 45

    (15) f -> empty .

    {               reduce using rule 15 (f -> empty .)


state 46

    (20) params -> tipo ID . meterparams h
    (21) meterparams -> .

    ,               reduce using rule 21 (meterparams -> .)
    )               reduce using rule 21 (meterparams -> .)

    meterparams                    shift and go to state 53

state 47

    (13) funcion -> FUNC tipo ID meterfuncion ( params ) . f bloque
    (15) f -> . empty
    (16) f -> . vars g
    (140) empty -> .
    (11) vars -> . VAR v : tipo ;

    {               reduce using rule 140 (empty -> .)
    VAR             shift and go to state 5

    vars                           shift and go to state 43
    f                              shift and go to state 54
    empty                          shift and go to state 45

state 48

    (16) f -> vars g .

    {               reduce using rule 16 (f -> vars g .)


state 49

    (18) g -> f .

    {               reduce using rule 18 (g -> f .)


state 50

    (17) g -> empty .
    (15) f -> empty .

  ! reduce/reduce conflict for { resolved using rule 15 (f -> empty .)
    {               reduce using rule 15 (f -> empty .)

  ! {               [ reduce using rule 17 (g -> empty .) ]


state 51

    (28) bloque -> { . i }
    (24) i -> . empty
    (25) i -> . estatuto j
    (140) empty -> .
    (31) estatuto -> . asignacion
    (32) estatuto -> . if
    (33) estatuto -> . for
    (34) estatuto -> . return
    (35) estatuto -> . while
    (36) estatuto -> . play
    (37) estatuto -> . print
    (38) asignacion -> . ID = neur8 k ;
    (43) if -> . IF ( expresion ) neur13 bloque l ;
    (49) for -> . FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (132) return -> . RETURN ( expresion ) ;
    (122) while -> . WHILE ( neur16 expresion ) neur13 bloque neur17 ;
    (125) play -> . PLAY ( NOTA , CTEE ) ;
    (126) print -> . PRINT expresion ;

    }               reduce using rule 140 (empty -> .)
    ID              shift and go to state 67
    IF              shift and go to state 68
    FOR             shift and go to state 66
    RETURN          shift and go to state 55
    WHILE           shift and go to state 56
    PLAY            shift and go to state 63
    PRINT           shift and go to state 57

    if                             shift and go to state 58
    for                            shift and go to state 59
    estatuto                       shift and go to state 60
    print                          shift and go to state 61
    empty                          shift and go to state 62
    play                           shift and go to state 64
    return                         shift and go to state 65
    asignacion                     shift and go to state 69
    i                              shift and go to state 70
    while                          shift and go to state 71

state 52

    (29) cancion -> CANCION ( CTEE ) metercancion f bloque .

    $end            reduce using rule 29 (cancion -> CANCION ( CTEE ) metercancion f bloque .)


state 53

    (20) params -> tipo ID meterparams . h
    (22) h -> . empty
    (23) h -> . , params
    (140) empty -> .

    ,               shift and go to state 73
    )               reduce using rule 140 (empty -> .)

    h                              shift and go to state 72
    empty                          shift and go to state 74

state 54

    (13) funcion -> FUNC tipo ID meterfuncion ( params ) f . bloque
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 75

state 55

    (132) return -> RETURN . ( expresion ) ;

    (               shift and go to state 76


state 56

    (122) while -> WHILE . ( neur16 expresion ) neur13 bloque neur17 ;

    (               shift and go to state 77


state 57

    (126) print -> PRINT . expresion ;
    (54) expresion -> . m subexpresion
    (55) m -> . empty
    (56) m -> . NOT
    (140) empty -> .

    NOT             shift and go to state 80
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTEE            reduce using rule 140 (empty -> .)
    CTEF            reduce using rule 140 (empty -> .)
    CTEBOOL         reduce using rule 140 (empty -> .)
    CTECHAR         reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)

    expresion                      shift and go to state 78
    m                              shift and go to state 79
    empty                          shift and go to state 81

state 58

    (32) estatuto -> if .

    ID              reduce using rule 32 (estatuto -> if .)
    IF              reduce using rule 32 (estatuto -> if .)
    FOR             reduce using rule 32 (estatuto -> if .)
    RETURN          reduce using rule 32 (estatuto -> if .)
    WHILE           reduce using rule 32 (estatuto -> if .)
    PLAY            reduce using rule 32 (estatuto -> if .)
    PRINT           reduce using rule 32 (estatuto -> if .)
    }               reduce using rule 32 (estatuto -> if .)


state 59

    (33) estatuto -> for .

    ID              reduce using rule 33 (estatuto -> for .)
    IF              reduce using rule 33 (estatuto -> for .)
    FOR             reduce using rule 33 (estatuto -> for .)
    RETURN          reduce using rule 33 (estatuto -> for .)
    WHILE           reduce using rule 33 (estatuto -> for .)
    PLAY            reduce using rule 33 (estatuto -> for .)
    PRINT           reduce using rule 33 (estatuto -> for .)
    }               reduce using rule 33 (estatuto -> for .)


state 60

    (25) i -> estatuto . j
    (26) j -> . empty
    (27) j -> . i
    (140) empty -> .
    (24) i -> . empty
    (25) i -> . estatuto j
    (31) estatuto -> . asignacion
    (32) estatuto -> . if
    (33) estatuto -> . for
    (34) estatuto -> . return
    (35) estatuto -> . while
    (36) estatuto -> . play
    (37) estatuto -> . print
    (38) asignacion -> . ID = neur8 k ;
    (43) if -> . IF ( expresion ) neur13 bloque l ;
    (49) for -> . FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (132) return -> . RETURN ( expresion ) ;
    (122) while -> . WHILE ( neur16 expresion ) neur13 bloque neur17 ;
    (125) play -> . PLAY ( NOTA , CTEE ) ;
    (126) print -> . PRINT expresion ;

    }               reduce using rule 140 (empty -> .)
    ID              shift and go to state 67
    IF              shift and go to state 68
    FOR             shift and go to state 66
    RETURN          shift and go to state 55
    WHILE           shift and go to state 56
    PLAY            shift and go to state 63
    PRINT           shift and go to state 57

    if                             shift and go to state 58
    for                            shift and go to state 59
    estatuto                       shift and go to state 60
    print                          shift and go to state 61
    empty                          shift and go to state 82
    play                           shift and go to state 64
    return                         shift and go to state 65
    asignacion                     shift and go to state 69
    i                              shift and go to state 83
    j                              shift and go to state 84
    while                          shift and go to state 71

state 61

    (37) estatuto -> print .

    ID              reduce using rule 37 (estatuto -> print .)
    IF              reduce using rule 37 (estatuto -> print .)
    FOR             reduce using rule 37 (estatuto -> print .)
    RETURN          reduce using rule 37 (estatuto -> print .)
    WHILE           reduce using rule 37 (estatuto -> print .)
    PLAY            reduce using rule 37 (estatuto -> print .)
    PRINT           reduce using rule 37 (estatuto -> print .)
    }               reduce using rule 37 (estatuto -> print .)


state 62

    (24) i -> empty .

    }               reduce using rule 24 (i -> empty .)


state 63

    (125) play -> PLAY . ( NOTA , CTEE ) ;

    (               shift and go to state 85


state 64

    (36) estatuto -> play .

    ID              reduce using rule 36 (estatuto -> play .)
    IF              reduce using rule 36 (estatuto -> play .)
    FOR             reduce using rule 36 (estatuto -> play .)
    RETURN          reduce using rule 36 (estatuto -> play .)
    WHILE           reduce using rule 36 (estatuto -> play .)
    PLAY            reduce using rule 36 (estatuto -> play .)
    PRINT           reduce using rule 36 (estatuto -> play .)
    }               reduce using rule 36 (estatuto -> play .)


state 65

    (34) estatuto -> return .

    ID              reduce using rule 34 (estatuto -> return .)
    IF              reduce using rule 34 (estatuto -> return .)
    FOR             reduce using rule 34 (estatuto -> return .)
    RETURN          reduce using rule 34 (estatuto -> return .)
    WHILE           reduce using rule 34 (estatuto -> return .)
    PLAY            reduce using rule 34 (estatuto -> return .)
    PRINT           reduce using rule 34 (estatuto -> return .)
    }               reduce using rule 34 (estatuto -> return .)


state 66

    (49) for -> FOR . ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20

    (               shift and go to state 86


state 67

    (38) asignacion -> ID . = neur8 k ;

    =               shift and go to state 87


state 68

    (43) if -> IF . ( expresion ) neur13 bloque l ;

    (               shift and go to state 88


state 69

    (31) estatuto -> asignacion .

    ID              reduce using rule 31 (estatuto -> asignacion .)
    IF              reduce using rule 31 (estatuto -> asignacion .)
    FOR             reduce using rule 31 (estatuto -> asignacion .)
    RETURN          reduce using rule 31 (estatuto -> asignacion .)
    WHILE           reduce using rule 31 (estatuto -> asignacion .)
    PLAY            reduce using rule 31 (estatuto -> asignacion .)
    PRINT           reduce using rule 31 (estatuto -> asignacion .)
    }               reduce using rule 31 (estatuto -> asignacion .)


state 70

    (28) bloque -> { i . }

    }               shift and go to state 89


state 71

    (35) estatuto -> while .

    ID              reduce using rule 35 (estatuto -> while .)
    IF              reduce using rule 35 (estatuto -> while .)
    FOR             reduce using rule 35 (estatuto -> while .)
    RETURN          reduce using rule 35 (estatuto -> while .)
    WHILE           reduce using rule 35 (estatuto -> while .)
    PLAY            reduce using rule 35 (estatuto -> while .)
    PRINT           reduce using rule 35 (estatuto -> while .)
    }               reduce using rule 35 (estatuto -> while .)


state 72

    (20) params -> tipo ID meterparams h .

    )               reduce using rule 20 (params -> tipo ID meterparams h .)


state 73

    (23) h -> , . params
    (19) params -> . empty
    (20) params -> . tipo ID meterparams h
    (140) empty -> .
    (133) tipo -> . u y
    (134) u -> . empty
    (135) u -> . LIST

    )               reduce using rule 140 (empty -> .)
    INT             reduce using rule 140 (empty -> .)
    CHAR            reduce using rule 140 (empty -> .)
    FLOAT           reduce using rule 140 (empty -> .)
    BOOL            reduce using rule 140 (empty -> .)
    LIST            shift and go to state 19

    tipo                           shift and go to state 40
    u                              shift and go to state 20
    params                         shift and go to state 90
    empty                          shift and go to state 42

state 74

    (22) h -> empty .

    )               reduce using rule 22 (h -> empty .)


state 75

    (13) funcion -> FUNC tipo ID meterfuncion ( params ) f bloque .

    FUNC            reduce using rule 13 (funcion -> FUNC tipo ID meterfuncion ( params ) f bloque .)
    CANCION         reduce using rule 13 (funcion -> FUNC tipo ID meterfuncion ( params ) f bloque .)


state 76

    (132) return -> RETURN ( . expresion ) ;
    (54) expresion -> . m subexpresion
    (55) m -> . empty
    (56) m -> . NOT
    (140) empty -> .

    NOT             shift and go to state 80
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTEE            reduce using rule 140 (empty -> .)
    CTEF            reduce using rule 140 (empty -> .)
    CTEBOOL         reduce using rule 140 (empty -> .)
    CTECHAR         reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)

    expresion                      shift and go to state 91
    m                              shift and go to state 79
    empty                          shift and go to state 81

state 77

    (122) while -> WHILE ( . neur16 expresion ) neur13 bloque neur17 ;
    (123) neur16 -> .

    NOT             reduce using rule 123 (neur16 -> .)
    (               reduce using rule 123 (neur16 -> .)
    ID              reduce using rule 123 (neur16 -> .)
    CTEE            reduce using rule 123 (neur16 -> .)
    CTEF            reduce using rule 123 (neur16 -> .)
    CTEBOOL         reduce using rule 123 (neur16 -> .)
    CTECHAR         reduce using rule 123 (neur16 -> .)
    CALL            reduce using rule 123 (neur16 -> .)

    neur16                         shift and go to state 92

state 78

    (126) print -> PRINT expresion . ;

    ;               shift and go to state 93


state 79

    (54) expresion -> m . subexpresion
    (57) subexpresion -> . exp neur10 o
    (64) exp -> . nexp p neur12
    (79) nexp -> . termino neur5 q
    (86) termino -> . factor neur4 n
    (93) factor -> . ( neur6 expresion ) neur7
    (94) factor -> . varcte neur1
    (98) varcte -> . ID r neurVar
    (99) varcte -> . CTEE neurCteE
    (100) varcte -> . CTEF neurCteF
    (101) varcte -> . CTEBOOL neurCteB
    (102) varcte -> . callfunc
    (103) varcte -> . CTECHAR neurCteCh
    (127) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 97
    ID              shift and go to state 102
    CTEE            shift and go to state 107
    CTEF            shift and go to state 105
    CTEBOOL         shift and go to state 103
    CTECHAR         shift and go to state 95
    CALL            shift and go to state 100

    termino                        shift and go to state 94
    varcte                         shift and go to state 96
    nexp                           shift and go to state 98
    factor                         shift and go to state 99
    subexpresion                   shift and go to state 101
    callfunc                       shift and go to state 104
    exp                            shift and go to state 106

state 80

    (56) m -> NOT .

    (               reduce using rule 56 (m -> NOT .)
    ID              reduce using rule 56 (m -> NOT .)
    CTEE            reduce using rule 56 (m -> NOT .)
    CTEF            reduce using rule 56 (m -> NOT .)
    CTEBOOL         reduce using rule 56 (m -> NOT .)
    CTECHAR         reduce using rule 56 (m -> NOT .)
    CALL            reduce using rule 56 (m -> NOT .)


state 81

    (55) m -> empty .

    (               reduce using rule 55 (m -> empty .)
    ID              reduce using rule 55 (m -> empty .)
    CTEE            reduce using rule 55 (m -> empty .)
    CTEF            reduce using rule 55 (m -> empty .)
    CTEBOOL         reduce using rule 55 (m -> empty .)
    CTECHAR         reduce using rule 55 (m -> empty .)
    CALL            reduce using rule 55 (m -> empty .)


state 82

    (26) j -> empty .
    (24) i -> empty .

  ! reduce/reduce conflict for } resolved using rule 24 (i -> empty .)
    }               reduce using rule 24 (i -> empty .)

  ! }               [ reduce using rule 26 (j -> empty .) ]


state 83

    (27) j -> i .

    }               reduce using rule 27 (j -> i .)


state 84

    (25) i -> estatuto j .

    }               reduce using rule 25 (i -> estatuto j .)


state 85

    (125) play -> PLAY ( . NOTA , CTEE ) ;

    NOTA            shift and go to state 108


state 86

    (49) for -> FOR ( . asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (38) asignacion -> . ID = neur8 k ;

    ID              shift and go to state 67

    asignacion                     shift and go to state 109

state 87

    (38) asignacion -> ID = . neur8 k ;
    (39) neur8 -> .

    NEW             reduce using rule 39 (neur8 -> .)
    NOT             reduce using rule 39 (neur8 -> .)
    (               reduce using rule 39 (neur8 -> .)
    ID              reduce using rule 39 (neur8 -> .)
    CTEE            reduce using rule 39 (neur8 -> .)
    CTEF            reduce using rule 39 (neur8 -> .)
    CTEBOOL         reduce using rule 39 (neur8 -> .)
    CTECHAR         reduce using rule 39 (neur8 -> .)
    CALL            reduce using rule 39 (neur8 -> .)

    neur8                          shift and go to state 110

state 88

    (43) if -> IF ( . expresion ) neur13 bloque l ;
    (54) expresion -> . m subexpresion
    (55) m -> . empty
    (56) m -> . NOT
    (140) empty -> .

    NOT             shift and go to state 80
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTEE            reduce using rule 140 (empty -> .)
    CTEF            reduce using rule 140 (empty -> .)
    CTEBOOL         reduce using rule 140 (empty -> .)
    CTECHAR         reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)

    expresion                      shift and go to state 111
    m                              shift and go to state 79
    empty                          shift and go to state 81

state 89

    (28) bloque -> { i } .

    ELSE            reduce using rule 28 (bloque -> { i } .)
    ;               reduce using rule 28 (bloque -> { i } .)
    $end            reduce using rule 28 (bloque -> { i } .)
    FUNC            reduce using rule 28 (bloque -> { i } .)
    CANCION         reduce using rule 28 (bloque -> { i } .)


state 90

    (23) h -> , params .

    )               reduce using rule 23 (h -> , params .)


state 91

    (132) return -> RETURN ( expresion . ) ;

    )               shift and go to state 112


state 92

    (122) while -> WHILE ( neur16 . expresion ) neur13 bloque neur17 ;
    (54) expresion -> . m subexpresion
    (55) m -> . empty
    (56) m -> . NOT
    (140) empty -> .

    NOT             shift and go to state 80
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTEE            reduce using rule 140 (empty -> .)
    CTEF            reduce using rule 140 (empty -> .)
    CTEBOOL         reduce using rule 140 (empty -> .)
    CTECHAR         reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)

    expresion                      shift and go to state 113
    m                              shift and go to state 79
    empty                          shift and go to state 81

state 93

    (126) print -> PRINT expresion ; .

    ID              reduce using rule 126 (print -> PRINT expresion ; .)
    IF              reduce using rule 126 (print -> PRINT expresion ; .)
    FOR             reduce using rule 126 (print -> PRINT expresion ; .)
    RETURN          reduce using rule 126 (print -> PRINT expresion ; .)
    WHILE           reduce using rule 126 (print -> PRINT expresion ; .)
    PLAY            reduce using rule 126 (print -> PRINT expresion ; .)
    PRINT           reduce using rule 126 (print -> PRINT expresion ; .)
    }               reduce using rule 126 (print -> PRINT expresion ; .)


state 94

    (79) nexp -> termino . neur5 q
    (80) neur5 -> .

    +               reduce using rule 80 (neur5 -> .)
    -               reduce using rule 80 (neur5 -> .)
    EQ              reduce using rule 80 (neur5 -> .)
    NOTEQ           reduce using rule 80 (neur5 -> .)
    >               reduce using rule 80 (neur5 -> .)
    <               reduce using rule 80 (neur5 -> .)
    MTHANEQ         reduce using rule 80 (neur5 -> .)
    LTHANEQ         reduce using rule 80 (neur5 -> .)
    AND             reduce using rule 80 (neur5 -> .)
    OR              reduce using rule 80 (neur5 -> .)
    ;               reduce using rule 80 (neur5 -> .)
    )               reduce using rule 80 (neur5 -> .)
    ,               reduce using rule 80 (neur5 -> .)

    neur5                          shift and go to state 114

state 95

    (103) varcte -> CTECHAR . neurCteCh
    (108) neurCteCh -> .

    *               reduce using rule 108 (neurCteCh -> .)
    /               reduce using rule 108 (neurCteCh -> .)
    +               reduce using rule 108 (neurCteCh -> .)
    -               reduce using rule 108 (neurCteCh -> .)
    EQ              reduce using rule 108 (neurCteCh -> .)
    NOTEQ           reduce using rule 108 (neurCteCh -> .)
    >               reduce using rule 108 (neurCteCh -> .)
    <               reduce using rule 108 (neurCteCh -> .)
    MTHANEQ         reduce using rule 108 (neurCteCh -> .)
    LTHANEQ         reduce using rule 108 (neurCteCh -> .)
    AND             reduce using rule 108 (neurCteCh -> .)
    OR              reduce using rule 108 (neurCteCh -> .)
    ;               reduce using rule 108 (neurCteCh -> .)
    )               reduce using rule 108 (neurCteCh -> .)
    ,               reduce using rule 108 (neurCteCh -> .)

    neurCteCh                      shift and go to state 115

state 96

    (94) factor -> varcte . neur1
    (97) neur1 -> .

    *               reduce using rule 97 (neur1 -> .)
    /               reduce using rule 97 (neur1 -> .)
    +               reduce using rule 97 (neur1 -> .)
    -               reduce using rule 97 (neur1 -> .)
    EQ              reduce using rule 97 (neur1 -> .)
    NOTEQ           reduce using rule 97 (neur1 -> .)
    >               reduce using rule 97 (neur1 -> .)
    <               reduce using rule 97 (neur1 -> .)
    MTHANEQ         reduce using rule 97 (neur1 -> .)
    LTHANEQ         reduce using rule 97 (neur1 -> .)
    AND             reduce using rule 97 (neur1 -> .)
    OR              reduce using rule 97 (neur1 -> .)
    ;               reduce using rule 97 (neur1 -> .)
    )               reduce using rule 97 (neur1 -> .)
    ,               reduce using rule 97 (neur1 -> .)

    neur1                          shift and go to state 116

state 97

    (93) factor -> ( . neur6 expresion ) neur7
    (95) neur6 -> .

    NOT             reduce using rule 95 (neur6 -> .)
    (               reduce using rule 95 (neur6 -> .)
    ID              reduce using rule 95 (neur6 -> .)
    CTEE            reduce using rule 95 (neur6 -> .)
    CTEF            reduce using rule 95 (neur6 -> .)
    CTEBOOL         reduce using rule 95 (neur6 -> .)
    CTECHAR         reduce using rule 95 (neur6 -> .)
    CALL            reduce using rule 95 (neur6 -> .)

    neur6                          shift and go to state 117

state 98

    (64) exp -> nexp . p neur12
    (66) p -> . empty
    (67) p -> . EQ neur11_1 nexp
    (68) p -> . NOTEQ neur11_2 nexp
    (69) p -> . > neur11_3 nexp
    (70) p -> . < neur11_4 nexp
    (71) p -> . MTHANEQ neur11_5 nexp
    (72) p -> . LTHANEQ neur11_6 nexp
    (140) empty -> .

    EQ              shift and go to state 122
    NOTEQ           shift and go to state 121
    >               shift and go to state 125
    <               shift and go to state 123
    MTHANEQ         shift and go to state 118
    LTHANEQ         shift and go to state 120
    AND             reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)

    p                              shift and go to state 119
    empty                          shift and go to state 124

state 99

    (86) termino -> factor . neur4 n
    (87) neur4 -> .

    *               reduce using rule 87 (neur4 -> .)
    /               reduce using rule 87 (neur4 -> .)
    +               reduce using rule 87 (neur4 -> .)
    -               reduce using rule 87 (neur4 -> .)
    EQ              reduce using rule 87 (neur4 -> .)
    NOTEQ           reduce using rule 87 (neur4 -> .)
    >               reduce using rule 87 (neur4 -> .)
    <               reduce using rule 87 (neur4 -> .)
    MTHANEQ         reduce using rule 87 (neur4 -> .)
    LTHANEQ         reduce using rule 87 (neur4 -> .)
    AND             reduce using rule 87 (neur4 -> .)
    OR              reduce using rule 87 (neur4 -> .)
    ;               reduce using rule 87 (neur4 -> .)
    )               reduce using rule 87 (neur4 -> .)
    ,               reduce using rule 87 (neur4 -> .)

    neur4                          shift and go to state 126

state 100

    (127) callfunc -> CALL . ID ( s ) ;

    ID              shift and go to state 127


state 101

    (54) expresion -> m subexpresion .

    )               reduce using rule 54 (expresion -> m subexpresion .)
    ;               reduce using rule 54 (expresion -> m subexpresion .)
    ,               reduce using rule 54 (expresion -> m subexpresion .)


state 102

    (98) varcte -> ID . r neurVar
    (109) r -> . empty
    (110) r -> . oplista
    (140) empty -> .
    (111) oplista -> . ID . x

    *               reduce using rule 140 (empty -> .)
    /               reduce using rule 140 (empty -> .)
    +               reduce using rule 140 (empty -> .)
    -               reduce using rule 140 (empty -> .)
    EQ              reduce using rule 140 (empty -> .)
    NOTEQ           reduce using rule 140 (empty -> .)
    >               reduce using rule 140 (empty -> .)
    <               reduce using rule 140 (empty -> .)
    MTHANEQ         reduce using rule 140 (empty -> .)
    LTHANEQ         reduce using rule 140 (empty -> .)
    AND             reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)
    ID              shift and go to state 130

    oplista                        shift and go to state 128
    r                              shift and go to state 129
    empty                          shift and go to state 131

state 103

    (101) varcte -> CTEBOOL . neurCteB
    (107) neurCteB -> .

    *               reduce using rule 107 (neurCteB -> .)
    /               reduce using rule 107 (neurCteB -> .)
    +               reduce using rule 107 (neurCteB -> .)
    -               reduce using rule 107 (neurCteB -> .)
    EQ              reduce using rule 107 (neurCteB -> .)
    NOTEQ           reduce using rule 107 (neurCteB -> .)
    >               reduce using rule 107 (neurCteB -> .)
    <               reduce using rule 107 (neurCteB -> .)
    MTHANEQ         reduce using rule 107 (neurCteB -> .)
    LTHANEQ         reduce using rule 107 (neurCteB -> .)
    AND             reduce using rule 107 (neurCteB -> .)
    OR              reduce using rule 107 (neurCteB -> .)
    ;               reduce using rule 107 (neurCteB -> .)
    )               reduce using rule 107 (neurCteB -> .)
    ,               reduce using rule 107 (neurCteB -> .)

    neurCteB                       shift and go to state 132

state 104

    (102) varcte -> callfunc .

    *               reduce using rule 102 (varcte -> callfunc .)
    /               reduce using rule 102 (varcte -> callfunc .)
    +               reduce using rule 102 (varcte -> callfunc .)
    -               reduce using rule 102 (varcte -> callfunc .)
    AND             reduce using rule 102 (varcte -> callfunc .)
    OR              reduce using rule 102 (varcte -> callfunc .)
    ;               reduce using rule 102 (varcte -> callfunc .)
    )               reduce using rule 102 (varcte -> callfunc .)
    ,               reduce using rule 102 (varcte -> callfunc .)
    EQ              reduce using rule 102 (varcte -> callfunc .)
    NOTEQ           reduce using rule 102 (varcte -> callfunc .)
    >               reduce using rule 102 (varcte -> callfunc .)
    <               reduce using rule 102 (varcte -> callfunc .)
    MTHANEQ         reduce using rule 102 (varcte -> callfunc .)
    LTHANEQ         reduce using rule 102 (varcte -> callfunc .)


state 105

    (100) varcte -> CTEF . neurCteF
    (106) neurCteF -> .

    *               reduce using rule 106 (neurCteF -> .)
    /               reduce using rule 106 (neurCteF -> .)
    +               reduce using rule 106 (neurCteF -> .)
    -               reduce using rule 106 (neurCteF -> .)
    EQ              reduce using rule 106 (neurCteF -> .)
    NOTEQ           reduce using rule 106 (neurCteF -> .)
    >               reduce using rule 106 (neurCteF -> .)
    <               reduce using rule 106 (neurCteF -> .)
    MTHANEQ         reduce using rule 106 (neurCteF -> .)
    LTHANEQ         reduce using rule 106 (neurCteF -> .)
    AND             reduce using rule 106 (neurCteF -> .)
    OR              reduce using rule 106 (neurCteF -> .)
    ;               reduce using rule 106 (neurCteF -> .)
    )               reduce using rule 106 (neurCteF -> .)
    ,               reduce using rule 106 (neurCteF -> .)

    neurCteF                       shift and go to state 133

state 106

    (57) subexpresion -> exp . neur10 o
    (58) neur10 -> .

    AND             reduce using rule 58 (neur10 -> .)
    OR              reduce using rule 58 (neur10 -> .)
    ;               reduce using rule 58 (neur10 -> .)
    )               reduce using rule 58 (neur10 -> .)
    ,               reduce using rule 58 (neur10 -> .)

    neur10                         shift and go to state 134

state 107

    (99) varcte -> CTEE . neurCteE
    (105) neurCteE -> .

    *               reduce using rule 105 (neurCteE -> .)
    /               reduce using rule 105 (neurCteE -> .)
    +               reduce using rule 105 (neurCteE -> .)
    -               reduce using rule 105 (neurCteE -> .)
    EQ              reduce using rule 105 (neurCteE -> .)
    NOTEQ           reduce using rule 105 (neurCteE -> .)
    >               reduce using rule 105 (neurCteE -> .)
    <               reduce using rule 105 (neurCteE -> .)
    MTHANEQ         reduce using rule 105 (neurCteE -> .)
    LTHANEQ         reduce using rule 105 (neurCteE -> .)
    AND             reduce using rule 105 (neurCteE -> .)
    OR              reduce using rule 105 (neurCteE -> .)
    ;               reduce using rule 105 (neurCteE -> .)
    )               reduce using rule 105 (neurCteE -> .)
    ,               reduce using rule 105 (neurCteE -> .)

    neurCteE                       shift and go to state 135

state 108

    (125) play -> PLAY ( NOTA . , CTEE ) ;

    ,               shift and go to state 136


state 109

    (49) for -> FOR ( asignacion . neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (50) neur18 -> .

    NOT             reduce using rule 50 (neur18 -> .)
    (               reduce using rule 50 (neur18 -> .)
    ID              reduce using rule 50 (neur18 -> .)
    CTEE            reduce using rule 50 (neur18 -> .)
    CTEF            reduce using rule 50 (neur18 -> .)
    CTEBOOL         reduce using rule 50 (neur18 -> .)
    CTECHAR         reduce using rule 50 (neur18 -> .)
    CALL            reduce using rule 50 (neur18 -> .)

    neur18                         shift and go to state 137

state 110

    (38) asignacion -> ID = neur8 . k ;
    (40) k -> . expresion
    (41) k -> . asiglista
    (54) expresion -> . m subexpresion
    (42) asiglista -> . NEW LIST ( )
    (55) m -> . empty
    (56) m -> . NOT
    (140) empty -> .

    NEW             shift and go to state 141
    NOT             shift and go to state 80
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTEE            reduce using rule 140 (empty -> .)
    CTEF            reduce using rule 140 (empty -> .)
    CTEBOOL         reduce using rule 140 (empty -> .)
    CTECHAR         reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)

    expresion                      shift and go to state 138
    k                              shift and go to state 139
    m                              shift and go to state 79
    asiglista                      shift and go to state 140
    empty                          shift and go to state 81

state 111

    (43) if -> IF ( expresion . ) neur13 bloque l ;

    )               shift and go to state 142


state 112

    (132) return -> RETURN ( expresion ) . ;

    ;               shift and go to state 143


state 113

    (122) while -> WHILE ( neur16 expresion . ) neur13 bloque neur17 ;

    )               shift and go to state 144


state 114

    (79) nexp -> termino neur5 . q
    (81) q -> . empty
    (82) q -> . + neur3_1 nexp
    (83) q -> . - neur3_2 nexp
    (140) empty -> .

    +               shift and go to state 145
    -               shift and go to state 146
    EQ              reduce using rule 140 (empty -> .)
    NOTEQ           reduce using rule 140 (empty -> .)
    >               reduce using rule 140 (empty -> .)
    <               reduce using rule 140 (empty -> .)
    MTHANEQ         reduce using rule 140 (empty -> .)
    LTHANEQ         reduce using rule 140 (empty -> .)
    AND             reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)

    q                              shift and go to state 147
    empty                          shift and go to state 148

state 115

    (103) varcte -> CTECHAR neurCteCh .

    *               reduce using rule 103 (varcte -> CTECHAR neurCteCh .)
    /               reduce using rule 103 (varcte -> CTECHAR neurCteCh .)
    +               reduce using rule 103 (varcte -> CTECHAR neurCteCh .)
    -               reduce using rule 103 (varcte -> CTECHAR neurCteCh .)
    AND             reduce using rule 103 (varcte -> CTECHAR neurCteCh .)
    OR              reduce using rule 103 (varcte -> CTECHAR neurCteCh .)
    ;               reduce using rule 103 (varcte -> CTECHAR neurCteCh .)
    )               reduce using rule 103 (varcte -> CTECHAR neurCteCh .)
    ,               reduce using rule 103 (varcte -> CTECHAR neurCteCh .)
    EQ              reduce using rule 103 (varcte -> CTECHAR neurCteCh .)
    NOTEQ           reduce using rule 103 (varcte -> CTECHAR neurCteCh .)
    >               reduce using rule 103 (varcte -> CTECHAR neurCteCh .)
    <               reduce using rule 103 (varcte -> CTECHAR neurCteCh .)
    MTHANEQ         reduce using rule 103 (varcte -> CTECHAR neurCteCh .)
    LTHANEQ         reduce using rule 103 (varcte -> CTECHAR neurCteCh .)


state 116

    (94) factor -> varcte neur1 .

    *               reduce using rule 94 (factor -> varcte neur1 .)
    /               reduce using rule 94 (factor -> varcte neur1 .)
    +               reduce using rule 94 (factor -> varcte neur1 .)
    -               reduce using rule 94 (factor -> varcte neur1 .)
    AND             reduce using rule 94 (factor -> varcte neur1 .)
    OR              reduce using rule 94 (factor -> varcte neur1 .)
    ;               reduce using rule 94 (factor -> varcte neur1 .)
    )               reduce using rule 94 (factor -> varcte neur1 .)
    ,               reduce using rule 94 (factor -> varcte neur1 .)
    EQ              reduce using rule 94 (factor -> varcte neur1 .)
    NOTEQ           reduce using rule 94 (factor -> varcte neur1 .)
    >               reduce using rule 94 (factor -> varcte neur1 .)
    <               reduce using rule 94 (factor -> varcte neur1 .)
    MTHANEQ         reduce using rule 94 (factor -> varcte neur1 .)
    LTHANEQ         reduce using rule 94 (factor -> varcte neur1 .)


state 117

    (93) factor -> ( neur6 . expresion ) neur7
    (54) expresion -> . m subexpresion
    (55) m -> . empty
    (56) m -> . NOT
    (140) empty -> .

    NOT             shift and go to state 80
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTEE            reduce using rule 140 (empty -> .)
    CTEF            reduce using rule 140 (empty -> .)
    CTEBOOL         reduce using rule 140 (empty -> .)
    CTECHAR         reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)

    expresion                      shift and go to state 149
    m                              shift and go to state 79
    empty                          shift and go to state 81

state 118

    (71) p -> MTHANEQ . neur11_5 nexp
    (77) neur11_5 -> .

    (               reduce using rule 77 (neur11_5 -> .)
    ID              reduce using rule 77 (neur11_5 -> .)
    CTEE            reduce using rule 77 (neur11_5 -> .)
    CTEF            reduce using rule 77 (neur11_5 -> .)
    CTEBOOL         reduce using rule 77 (neur11_5 -> .)
    CTECHAR         reduce using rule 77 (neur11_5 -> .)
    CALL            reduce using rule 77 (neur11_5 -> .)

    neur11_5                       shift and go to state 150

state 119

    (64) exp -> nexp p . neur12
    (65) neur12 -> .

    AND             reduce using rule 65 (neur12 -> .)
    OR              reduce using rule 65 (neur12 -> .)
    ;               reduce using rule 65 (neur12 -> .)
    )               reduce using rule 65 (neur12 -> .)
    ,               reduce using rule 65 (neur12 -> .)

    neur12                         shift and go to state 151

state 120

    (72) p -> LTHANEQ . neur11_6 nexp
    (78) neur11_6 -> .

    (               reduce using rule 78 (neur11_6 -> .)
    ID              reduce using rule 78 (neur11_6 -> .)
    CTEE            reduce using rule 78 (neur11_6 -> .)
    CTEF            reduce using rule 78 (neur11_6 -> .)
    CTEBOOL         reduce using rule 78 (neur11_6 -> .)
    CTECHAR         reduce using rule 78 (neur11_6 -> .)
    CALL            reduce using rule 78 (neur11_6 -> .)

    neur11_6                       shift and go to state 152

state 121

    (68) p -> NOTEQ . neur11_2 nexp
    (74) neur11_2 -> .

    (               reduce using rule 74 (neur11_2 -> .)
    ID              reduce using rule 74 (neur11_2 -> .)
    CTEE            reduce using rule 74 (neur11_2 -> .)
    CTEF            reduce using rule 74 (neur11_2 -> .)
    CTEBOOL         reduce using rule 74 (neur11_2 -> .)
    CTECHAR         reduce using rule 74 (neur11_2 -> .)
    CALL            reduce using rule 74 (neur11_2 -> .)

    neur11_2                       shift and go to state 153

state 122

    (67) p -> EQ . neur11_1 nexp
    (73) neur11_1 -> .

    (               reduce using rule 73 (neur11_1 -> .)
    ID              reduce using rule 73 (neur11_1 -> .)
    CTEE            reduce using rule 73 (neur11_1 -> .)
    CTEF            reduce using rule 73 (neur11_1 -> .)
    CTEBOOL         reduce using rule 73 (neur11_1 -> .)
    CTECHAR         reduce using rule 73 (neur11_1 -> .)
    CALL            reduce using rule 73 (neur11_1 -> .)

    neur11_1                       shift and go to state 154

state 123

    (70) p -> < . neur11_4 nexp
    (76) neur11_4 -> .

    (               reduce using rule 76 (neur11_4 -> .)
    ID              reduce using rule 76 (neur11_4 -> .)
    CTEE            reduce using rule 76 (neur11_4 -> .)
    CTEF            reduce using rule 76 (neur11_4 -> .)
    CTEBOOL         reduce using rule 76 (neur11_4 -> .)
    CTECHAR         reduce using rule 76 (neur11_4 -> .)
    CALL            reduce using rule 76 (neur11_4 -> .)

    neur11_4                       shift and go to state 155

state 124

    (66) p -> empty .

    AND             reduce using rule 66 (p -> empty .)
    OR              reduce using rule 66 (p -> empty .)
    ;               reduce using rule 66 (p -> empty .)
    )               reduce using rule 66 (p -> empty .)
    ,               reduce using rule 66 (p -> empty .)


state 125

    (69) p -> > . neur11_3 nexp
    (75) neur11_3 -> .

    (               reduce using rule 75 (neur11_3 -> .)
    ID              reduce using rule 75 (neur11_3 -> .)
    CTEE            reduce using rule 75 (neur11_3 -> .)
    CTEF            reduce using rule 75 (neur11_3 -> .)
    CTEBOOL         reduce using rule 75 (neur11_3 -> .)
    CTECHAR         reduce using rule 75 (neur11_3 -> .)
    CALL            reduce using rule 75 (neur11_3 -> .)

    neur11_3                       shift and go to state 156

state 126

    (86) termino -> factor neur4 . n
    (88) n -> . empty
    (89) n -> . * neur2_1 termino
    (90) n -> . / neur2_2 termino
    (140) empty -> .

    *               shift and go to state 157
    /               shift and go to state 158
    +               reduce using rule 140 (empty -> .)
    -               reduce using rule 140 (empty -> .)
    EQ              reduce using rule 140 (empty -> .)
    NOTEQ           reduce using rule 140 (empty -> .)
    >               reduce using rule 140 (empty -> .)
    <               reduce using rule 140 (empty -> .)
    MTHANEQ         reduce using rule 140 (empty -> .)
    LTHANEQ         reduce using rule 140 (empty -> .)
    AND             reduce using rule 140 (empty -> .)
    OR              reduce using rule 140 (empty -> .)
    ;               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)

    n                              shift and go to state 159
    empty                          shift and go to state 160

state 127

    (127) callfunc -> CALL ID . ( s ) ;

    (               shift and go to state 161


state 128

    (110) r -> oplista .

    *               reduce using rule 110 (r -> oplista .)
    /               reduce using rule 110 (r -> oplista .)
    +               reduce using rule 110 (r -> oplista .)
    -               reduce using rule 110 (r -> oplista .)
    EQ              reduce using rule 110 (r -> oplista .)
    NOTEQ           reduce using rule 110 (r -> oplista .)
    >               reduce using rule 110 (r -> oplista .)
    <               reduce using rule 110 (r -> oplista .)
    MTHANEQ         reduce using rule 110 (r -> oplista .)
    LTHANEQ         reduce using rule 110 (r -> oplista .)
    AND             reduce using rule 110 (r -> oplista .)
    OR              reduce using rule 110 (r -> oplista .)
    ;               reduce using rule 110 (r -> oplista .)
    )               reduce using rule 110 (r -> oplista .)
    ,               reduce using rule 110 (r -> oplista .)


state 129

    (98) varcte -> ID r . neurVar
    (104) neurVar -> .

    *               reduce using rule 104 (neurVar -> .)
    /               reduce using rule 104 (neurVar -> .)
    +               reduce using rule 104 (neurVar -> .)
    -               reduce using rule 104 (neurVar -> .)
    EQ              reduce using rule 104 (neurVar -> .)
    NOTEQ           reduce using rule 104 (neurVar -> .)
    >               reduce using rule 104 (neurVar -> .)
    <               reduce using rule 104 (neurVar -> .)
    MTHANEQ         reduce using rule 104 (neurVar -> .)
    LTHANEQ         reduce using rule 104 (neurVar -> .)
    AND             reduce using rule 104 (neurVar -> .)
    OR              reduce using rule 104 (neurVar -> .)
    ;               reduce using rule 104 (neurVar -> .)
    )               reduce using rule 104 (neurVar -> .)
    ,               reduce using rule 104 (neurVar -> .)

    neurVar                        shift and go to state 162

state 130

    (111) oplista -> ID . . x

    .               shift and go to state 163


state 131

    (109) r -> empty .

    *               reduce using rule 109 (r -> empty .)
    /               reduce using rule 109 (r -> empty .)
    +               reduce using rule 109 (r -> empty .)
    -               reduce using rule 109 (r -> empty .)
    EQ              reduce using rule 109 (r -> empty .)
    NOTEQ           reduce using rule 109 (r -> empty .)
    >               reduce using rule 109 (r -> empty .)
    <               reduce using rule 109 (r -> empty .)
    MTHANEQ         reduce using rule 109 (r -> empty .)
    LTHANEQ         reduce using rule 109 (r -> empty .)
    AND             reduce using rule 109 (r -> empty .)
    OR              reduce using rule 109 (r -> empty .)
    ;               reduce using rule 109 (r -> empty .)
    )               reduce using rule 109 (r -> empty .)
    ,               reduce using rule 109 (r -> empty .)


state 132

    (101) varcte -> CTEBOOL neurCteB .

    *               reduce using rule 101 (varcte -> CTEBOOL neurCteB .)
    /               reduce using rule 101 (varcte -> CTEBOOL neurCteB .)
    +               reduce using rule 101 (varcte -> CTEBOOL neurCteB .)
    -               reduce using rule 101 (varcte -> CTEBOOL neurCteB .)
    AND             reduce using rule 101 (varcte -> CTEBOOL neurCteB .)
    OR              reduce using rule 101 (varcte -> CTEBOOL neurCteB .)
    ;               reduce using rule 101 (varcte -> CTEBOOL neurCteB .)
    )               reduce using rule 101 (varcte -> CTEBOOL neurCteB .)
    ,               reduce using rule 101 (varcte -> CTEBOOL neurCteB .)
    EQ              reduce using rule 101 (varcte -> CTEBOOL neurCteB .)
    NOTEQ           reduce using rule 101 (varcte -> CTEBOOL neurCteB .)
    >               reduce using rule 101 (varcte -> CTEBOOL neurCteB .)
    <               reduce using rule 101 (varcte -> CTEBOOL neurCteB .)
    MTHANEQ         reduce using rule 101 (varcte -> CTEBOOL neurCteB .)
    LTHANEQ         reduce using rule 101 (varcte -> CTEBOOL neurCteB .)


state 133

    (100) varcte -> CTEF neurCteF .

    *               reduce using rule 100 (varcte -> CTEF neurCteF .)
    /               reduce using rule 100 (varcte -> CTEF neurCteF .)
    +               reduce using rule 100 (varcte -> CTEF neurCteF .)
    -               reduce using rule 100 (varcte -> CTEF neurCteF .)
    AND             reduce using rule 100 (varcte -> CTEF neurCteF .)
    OR              reduce using rule 100 (varcte -> CTEF neurCteF .)
    ;               reduce using rule 100 (varcte -> CTEF neurCteF .)
    )               reduce using rule 100 (varcte -> CTEF neurCteF .)
    ,               reduce using rule 100 (varcte -> CTEF neurCteF .)
    EQ              reduce using rule 100 (varcte -> CTEF neurCteF .)
    NOTEQ           reduce using rule 100 (varcte -> CTEF neurCteF .)
    >               reduce using rule 100 (varcte -> CTEF neurCteF .)
    <               reduce using rule 100 (varcte -> CTEF neurCteF .)
    MTHANEQ         reduce using rule 100 (varcte -> CTEF neurCteF .)
    LTHANEQ         reduce using rule 100 (varcte -> CTEF neurCteF .)


state 134

    (57) subexpresion -> exp neur10 . o
    (59) o -> . empty
    (60) o -> . AND neur9_1 subexpresion
    (61) o -> . OR neur9_2 subexpresion
    (140) empty -> .

    AND             shift and go to state 164
    OR              shift and go to state 166
    ;               reduce using rule 140 (empty -> .)
    )               reduce using rule 140 (empty -> .)
    ,               reduce using rule 140 (empty -> .)

    o                              shift and go to state 165
    empty                          shift and go to state 167

state 135

    (99) varcte -> CTEE neurCteE .

    *               reduce using rule 99 (varcte -> CTEE neurCteE .)
    /               reduce using rule 99 (varcte -> CTEE neurCteE .)
    +               reduce using rule 99 (varcte -> CTEE neurCteE .)
    -               reduce using rule 99 (varcte -> CTEE neurCteE .)
    AND             reduce using rule 99 (varcte -> CTEE neurCteE .)
    OR              reduce using rule 99 (varcte -> CTEE neurCteE .)
    ;               reduce using rule 99 (varcte -> CTEE neurCteE .)
    )               reduce using rule 99 (varcte -> CTEE neurCteE .)
    ,               reduce using rule 99 (varcte -> CTEE neurCteE .)
    EQ              reduce using rule 99 (varcte -> CTEE neurCteE .)
    NOTEQ           reduce using rule 99 (varcte -> CTEE neurCteE .)
    >               reduce using rule 99 (varcte -> CTEE neurCteE .)
    <               reduce using rule 99 (varcte -> CTEE neurCteE .)
    MTHANEQ         reduce using rule 99 (varcte -> CTEE neurCteE .)
    LTHANEQ         reduce using rule 99 (varcte -> CTEE neurCteE .)


state 136

    (125) play -> PLAY ( NOTA , . CTEE ) ;

    CTEE            shift and go to state 168


state 137

    (49) for -> FOR ( asignacion neur18 . expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (54) expresion -> . m subexpresion
    (55) m -> . empty
    (56) m -> . NOT
    (140) empty -> .

    NOT             shift and go to state 80
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTEE            reduce using rule 140 (empty -> .)
    CTEF            reduce using rule 140 (empty -> .)
    CTEBOOL         reduce using rule 140 (empty -> .)
    CTECHAR         reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)

    expresion                      shift and go to state 169
    m                              shift and go to state 79
    empty                          shift and go to state 81

state 138

    (40) k -> expresion .

    ;               reduce using rule 40 (k -> expresion .)


state 139

    (38) asignacion -> ID = neur8 k . ;

    ;               shift and go to state 170


state 140

    (41) k -> asiglista .

    ;               reduce using rule 41 (k -> asiglista .)


state 141

    (42) asiglista -> NEW . LIST ( )

    LIST            shift and go to state 171


state 142

    (43) if -> IF ( expresion ) . neur13 bloque l ;
    (44) neur13 -> .

    {               reduce using rule 44 (neur13 -> .)

    neur13                         shift and go to state 172

state 143

    (132) return -> RETURN ( expresion ) ; .

    ID              reduce using rule 132 (return -> RETURN ( expresion ) ; .)
    IF              reduce using rule 132 (return -> RETURN ( expresion ) ; .)
    FOR             reduce using rule 132 (return -> RETURN ( expresion ) ; .)
    RETURN          reduce using rule 132 (return -> RETURN ( expresion ) ; .)
    WHILE           reduce using rule 132 (return -> RETURN ( expresion ) ; .)
    PLAY            reduce using rule 132 (return -> RETURN ( expresion ) ; .)
    PRINT           reduce using rule 132 (return -> RETURN ( expresion ) ; .)
    }               reduce using rule 132 (return -> RETURN ( expresion ) ; .)


state 144

    (122) while -> WHILE ( neur16 expresion ) . neur13 bloque neur17 ;
    (44) neur13 -> .

    {               reduce using rule 44 (neur13 -> .)

    neur13                         shift and go to state 173

state 145

    (82) q -> + . neur3_1 nexp
    (84) neur3_1 -> .

    (               reduce using rule 84 (neur3_1 -> .)
    ID              reduce using rule 84 (neur3_1 -> .)
    CTEE            reduce using rule 84 (neur3_1 -> .)
    CTEF            reduce using rule 84 (neur3_1 -> .)
    CTEBOOL         reduce using rule 84 (neur3_1 -> .)
    CTECHAR         reduce using rule 84 (neur3_1 -> .)
    CALL            reduce using rule 84 (neur3_1 -> .)

    neur3_1                        shift and go to state 174

state 146

    (83) q -> - . neur3_2 nexp
    (85) neur3_2 -> .

    (               reduce using rule 85 (neur3_2 -> .)
    ID              reduce using rule 85 (neur3_2 -> .)
    CTEE            reduce using rule 85 (neur3_2 -> .)
    CTEF            reduce using rule 85 (neur3_2 -> .)
    CTEBOOL         reduce using rule 85 (neur3_2 -> .)
    CTECHAR         reduce using rule 85 (neur3_2 -> .)
    CALL            reduce using rule 85 (neur3_2 -> .)

    neur3_2                        shift and go to state 175

state 147

    (79) nexp -> termino neur5 q .

    EQ              reduce using rule 79 (nexp -> termino neur5 q .)
    NOTEQ           reduce using rule 79 (nexp -> termino neur5 q .)
    >               reduce using rule 79 (nexp -> termino neur5 q .)
    <               reduce using rule 79 (nexp -> termino neur5 q .)
    MTHANEQ         reduce using rule 79 (nexp -> termino neur5 q .)
    LTHANEQ         reduce using rule 79 (nexp -> termino neur5 q .)
    AND             reduce using rule 79 (nexp -> termino neur5 q .)
    OR              reduce using rule 79 (nexp -> termino neur5 q .)
    ;               reduce using rule 79 (nexp -> termino neur5 q .)
    )               reduce using rule 79 (nexp -> termino neur5 q .)
    ,               reduce using rule 79 (nexp -> termino neur5 q .)


state 148

    (81) q -> empty .

    EQ              reduce using rule 81 (q -> empty .)
    NOTEQ           reduce using rule 81 (q -> empty .)
    >               reduce using rule 81 (q -> empty .)
    <               reduce using rule 81 (q -> empty .)
    MTHANEQ         reduce using rule 81 (q -> empty .)
    LTHANEQ         reduce using rule 81 (q -> empty .)
    AND             reduce using rule 81 (q -> empty .)
    OR              reduce using rule 81 (q -> empty .)
    ;               reduce using rule 81 (q -> empty .)
    )               reduce using rule 81 (q -> empty .)
    ,               reduce using rule 81 (q -> empty .)


state 149

    (93) factor -> ( neur6 expresion . ) neur7

    )               shift and go to state 176


state 150

    (71) p -> MTHANEQ neur11_5 . nexp
    (79) nexp -> . termino neur5 q
    (86) termino -> . factor neur4 n
    (93) factor -> . ( neur6 expresion ) neur7
    (94) factor -> . varcte neur1
    (98) varcte -> . ID r neurVar
    (99) varcte -> . CTEE neurCteE
    (100) varcte -> . CTEF neurCteF
    (101) varcte -> . CTEBOOL neurCteB
    (102) varcte -> . callfunc
    (103) varcte -> . CTECHAR neurCteCh
    (127) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 97
    ID              shift and go to state 102
    CTEE            shift and go to state 107
    CTEF            shift and go to state 105
    CTEBOOL         shift and go to state 103
    CTECHAR         shift and go to state 95
    CALL            shift and go to state 100

    varcte                         shift and go to state 96
    callfunc                       shift and go to state 104
    nexp                           shift and go to state 177
    termino                        shift and go to state 94
    factor                         shift and go to state 99

state 151

    (64) exp -> nexp p neur12 .

    AND             reduce using rule 64 (exp -> nexp p neur12 .)
    OR              reduce using rule 64 (exp -> nexp p neur12 .)
    ;               reduce using rule 64 (exp -> nexp p neur12 .)
    )               reduce using rule 64 (exp -> nexp p neur12 .)
    ,               reduce using rule 64 (exp -> nexp p neur12 .)


state 152

    (72) p -> LTHANEQ neur11_6 . nexp
    (79) nexp -> . termino neur5 q
    (86) termino -> . factor neur4 n
    (93) factor -> . ( neur6 expresion ) neur7
    (94) factor -> . varcte neur1
    (98) varcte -> . ID r neurVar
    (99) varcte -> . CTEE neurCteE
    (100) varcte -> . CTEF neurCteF
    (101) varcte -> . CTEBOOL neurCteB
    (102) varcte -> . callfunc
    (103) varcte -> . CTECHAR neurCteCh
    (127) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 97
    ID              shift and go to state 102
    CTEE            shift and go to state 107
    CTEF            shift and go to state 105
    CTEBOOL         shift and go to state 103
    CTECHAR         shift and go to state 95
    CALL            shift and go to state 100

    varcte                         shift and go to state 96
    callfunc                       shift and go to state 104
    nexp                           shift and go to state 178
    termino                        shift and go to state 94
    factor                         shift and go to state 99

state 153

    (68) p -> NOTEQ neur11_2 . nexp
    (79) nexp -> . termino neur5 q
    (86) termino -> . factor neur4 n
    (93) factor -> . ( neur6 expresion ) neur7
    (94) factor -> . varcte neur1
    (98) varcte -> . ID r neurVar
    (99) varcte -> . CTEE neurCteE
    (100) varcte -> . CTEF neurCteF
    (101) varcte -> . CTEBOOL neurCteB
    (102) varcte -> . callfunc
    (103) varcte -> . CTECHAR neurCteCh
    (127) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 97
    ID              shift and go to state 102
    CTEE            shift and go to state 107
    CTEF            shift and go to state 105
    CTEBOOL         shift and go to state 103
    CTECHAR         shift and go to state 95
    CALL            shift and go to state 100

    varcte                         shift and go to state 96
    callfunc                       shift and go to state 104
    nexp                           shift and go to state 179
    termino                        shift and go to state 94
    factor                         shift and go to state 99

state 154

    (67) p -> EQ neur11_1 . nexp
    (79) nexp -> . termino neur5 q
    (86) termino -> . factor neur4 n
    (93) factor -> . ( neur6 expresion ) neur7
    (94) factor -> . varcte neur1
    (98) varcte -> . ID r neurVar
    (99) varcte -> . CTEE neurCteE
    (100) varcte -> . CTEF neurCteF
    (101) varcte -> . CTEBOOL neurCteB
    (102) varcte -> . callfunc
    (103) varcte -> . CTECHAR neurCteCh
    (127) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 97
    ID              shift and go to state 102
    CTEE            shift and go to state 107
    CTEF            shift and go to state 105
    CTEBOOL         shift and go to state 103
    CTECHAR         shift and go to state 95
    CALL            shift and go to state 100

    varcte                         shift and go to state 96
    callfunc                       shift and go to state 104
    nexp                           shift and go to state 180
    termino                        shift and go to state 94
    factor                         shift and go to state 99

state 155

    (70) p -> < neur11_4 . nexp
    (79) nexp -> . termino neur5 q
    (86) termino -> . factor neur4 n
    (93) factor -> . ( neur6 expresion ) neur7
    (94) factor -> . varcte neur1
    (98) varcte -> . ID r neurVar
    (99) varcte -> . CTEE neurCteE
    (100) varcte -> . CTEF neurCteF
    (101) varcte -> . CTEBOOL neurCteB
    (102) varcte -> . callfunc
    (103) varcte -> . CTECHAR neurCteCh
    (127) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 97
    ID              shift and go to state 102
    CTEE            shift and go to state 107
    CTEF            shift and go to state 105
    CTEBOOL         shift and go to state 103
    CTECHAR         shift and go to state 95
    CALL            shift and go to state 100

    varcte                         shift and go to state 96
    callfunc                       shift and go to state 104
    nexp                           shift and go to state 181
    termino                        shift and go to state 94
    factor                         shift and go to state 99

state 156

    (69) p -> > neur11_3 . nexp
    (79) nexp -> . termino neur5 q
    (86) termino -> . factor neur4 n
    (93) factor -> . ( neur6 expresion ) neur7
    (94) factor -> . varcte neur1
    (98) varcte -> . ID r neurVar
    (99) varcte -> . CTEE neurCteE
    (100) varcte -> . CTEF neurCteF
    (101) varcte -> . CTEBOOL neurCteB
    (102) varcte -> . callfunc
    (103) varcte -> . CTECHAR neurCteCh
    (127) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 97
    ID              shift and go to state 102
    CTEE            shift and go to state 107
    CTEF            shift and go to state 105
    CTEBOOL         shift and go to state 103
    CTECHAR         shift and go to state 95
    CALL            shift and go to state 100

    varcte                         shift and go to state 96
    nexp                           shift and go to state 182
    callfunc                       shift and go to state 104
    termino                        shift and go to state 94
    factor                         shift and go to state 99

state 157

    (89) n -> * . neur2_1 termino
    (91) neur2_1 -> .

    (               reduce using rule 91 (neur2_1 -> .)
    ID              reduce using rule 91 (neur2_1 -> .)
    CTEE            reduce using rule 91 (neur2_1 -> .)
    CTEF            reduce using rule 91 (neur2_1 -> .)
    CTEBOOL         reduce using rule 91 (neur2_1 -> .)
    CTECHAR         reduce using rule 91 (neur2_1 -> .)
    CALL            reduce using rule 91 (neur2_1 -> .)

    neur2_1                        shift and go to state 183

state 158

    (90) n -> / . neur2_2 termino
    (92) neur2_2 -> .

    (               reduce using rule 92 (neur2_2 -> .)
    ID              reduce using rule 92 (neur2_2 -> .)
    CTEE            reduce using rule 92 (neur2_2 -> .)
    CTEF            reduce using rule 92 (neur2_2 -> .)
    CTEBOOL         reduce using rule 92 (neur2_2 -> .)
    CTECHAR         reduce using rule 92 (neur2_2 -> .)
    CALL            reduce using rule 92 (neur2_2 -> .)

    neur2_2                        shift and go to state 184

state 159

    (86) termino -> factor neur4 n .

    +               reduce using rule 86 (termino -> factor neur4 n .)
    -               reduce using rule 86 (termino -> factor neur4 n .)
    EQ              reduce using rule 86 (termino -> factor neur4 n .)
    NOTEQ           reduce using rule 86 (termino -> factor neur4 n .)
    >               reduce using rule 86 (termino -> factor neur4 n .)
    <               reduce using rule 86 (termino -> factor neur4 n .)
    MTHANEQ         reduce using rule 86 (termino -> factor neur4 n .)
    LTHANEQ         reduce using rule 86 (termino -> factor neur4 n .)
    AND             reduce using rule 86 (termino -> factor neur4 n .)
    OR              reduce using rule 86 (termino -> factor neur4 n .)
    ;               reduce using rule 86 (termino -> factor neur4 n .)
    )               reduce using rule 86 (termino -> factor neur4 n .)
    ,               reduce using rule 86 (termino -> factor neur4 n .)


state 160

    (88) n -> empty .

    +               reduce using rule 88 (n -> empty .)
    -               reduce using rule 88 (n -> empty .)
    EQ              reduce using rule 88 (n -> empty .)
    NOTEQ           reduce using rule 88 (n -> empty .)
    >               reduce using rule 88 (n -> empty .)
    <               reduce using rule 88 (n -> empty .)
    MTHANEQ         reduce using rule 88 (n -> empty .)
    LTHANEQ         reduce using rule 88 (n -> empty .)
    AND             reduce using rule 88 (n -> empty .)
    OR              reduce using rule 88 (n -> empty .)
    ;               reduce using rule 88 (n -> empty .)
    )               reduce using rule 88 (n -> empty .)
    ,               reduce using rule 88 (n -> empty .)


state 161

    (127) callfunc -> CALL ID ( . s ) ;
    (128) s -> . empty
    (129) s -> . expresion t
    (140) empty -> .
    (54) expresion -> . m subexpresion
    (55) m -> . empty
    (56) m -> . NOT

    )               reduce using rule 140 (empty -> .)
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTEE            reduce using rule 140 (empty -> .)
    CTEF            reduce using rule 140 (empty -> .)
    CTEBOOL         reduce using rule 140 (empty -> .)
    CTECHAR         reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)
    NOT             shift and go to state 80

    expresion                      shift and go to state 185
    m                              shift and go to state 79
    s                              shift and go to state 186
    empty                          shift and go to state 187

state 162

    (98) varcte -> ID r neurVar .

    *               reduce using rule 98 (varcte -> ID r neurVar .)
    /               reduce using rule 98 (varcte -> ID r neurVar .)
    +               reduce using rule 98 (varcte -> ID r neurVar .)
    -               reduce using rule 98 (varcte -> ID r neurVar .)
    AND             reduce using rule 98 (varcte -> ID r neurVar .)
    OR              reduce using rule 98 (varcte -> ID r neurVar .)
    ;               reduce using rule 98 (varcte -> ID r neurVar .)
    )               reduce using rule 98 (varcte -> ID r neurVar .)
    ,               reduce using rule 98 (varcte -> ID r neurVar .)
    EQ              reduce using rule 98 (varcte -> ID r neurVar .)
    NOTEQ           reduce using rule 98 (varcte -> ID r neurVar .)
    >               reduce using rule 98 (varcte -> ID r neurVar .)
    <               reduce using rule 98 (varcte -> ID r neurVar .)
    MTHANEQ         reduce using rule 98 (varcte -> ID r neurVar .)
    LTHANEQ         reduce using rule 98 (varcte -> ID r neurVar .)


state 163

    (111) oplista -> ID . . x
    (112) x -> . inlistset
    (113) x -> . append
    (114) x -> . length
    (115) x -> . getlist
    (116) x -> . removelist
    (117) inlistset -> . SET ( CTEE , expresion )
    (118) append -> . APPEND ( expresion )
    (119) length -> . LENGTH ( )
    (120) getlist -> . GET ( expresion )
    (121) removelist -> . REMOVE ( expresion )

    SET             shift and go to state 188
    APPEND          shift and go to state 195
    LENGTH          shift and go to state 193
    GET             shift and go to state 190
    REMOVE          shift and go to state 192

    inlistset                      shift and go to state 189
    getlist                        shift and go to state 191
    length                         shift and go to state 194
    x                              shift and go to state 196
    removelist                     shift and go to state 197
    append                         shift and go to state 198

state 164

    (60) o -> AND . neur9_1 subexpresion
    (62) neur9_1 -> .

    (               reduce using rule 62 (neur9_1 -> .)
    ID              reduce using rule 62 (neur9_1 -> .)
    CTEE            reduce using rule 62 (neur9_1 -> .)
    CTEF            reduce using rule 62 (neur9_1 -> .)
    CTEBOOL         reduce using rule 62 (neur9_1 -> .)
    CTECHAR         reduce using rule 62 (neur9_1 -> .)
    CALL            reduce using rule 62 (neur9_1 -> .)

    neur9_1                        shift and go to state 199

state 165

    (57) subexpresion -> exp neur10 o .

    ;               reduce using rule 57 (subexpresion -> exp neur10 o .)
    )               reduce using rule 57 (subexpresion -> exp neur10 o .)
    ,               reduce using rule 57 (subexpresion -> exp neur10 o .)


state 166

    (61) o -> OR . neur9_2 subexpresion
    (63) neur9_2 -> .

    (               reduce using rule 63 (neur9_2 -> .)
    ID              reduce using rule 63 (neur9_2 -> .)
    CTEE            reduce using rule 63 (neur9_2 -> .)
    CTEF            reduce using rule 63 (neur9_2 -> .)
    CTEBOOL         reduce using rule 63 (neur9_2 -> .)
    CTECHAR         reduce using rule 63 (neur9_2 -> .)
    CALL            reduce using rule 63 (neur9_2 -> .)

    neur9_2                        shift and go to state 200

state 167

    (59) o -> empty .

    ;               reduce using rule 59 (o -> empty .)
    )               reduce using rule 59 (o -> empty .)
    ,               reduce using rule 59 (o -> empty .)


state 168

    (125) play -> PLAY ( NOTA , CTEE . ) ;

    )               shift and go to state 201


state 169

    (49) for -> FOR ( asignacion neur18 expresion . ; neur19 asignacion ) neur21 bloque ; neur20

    ;               shift and go to state 202


state 170

    (38) asignacion -> ID = neur8 k ; .

    )               reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    NOT             reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    (               reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    ID              reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CTEE            reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CTEF            reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CTEBOOL         reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CTECHAR         reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CALL            reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    IF              reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    FOR             reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    RETURN          reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    WHILE           reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    PLAY            reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    PRINT           reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    }               reduce using rule 38 (asignacion -> ID = neur8 k ; .)


state 171

    (42) asiglista -> NEW LIST . ( )

    (               shift and go to state 203


state 172

    (43) if -> IF ( expresion ) neur13 . bloque l ;
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 204

state 173

    (122) while -> WHILE ( neur16 expresion ) neur13 . bloque neur17 ;
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 205

state 174

    (82) q -> + neur3_1 . nexp
    (79) nexp -> . termino neur5 q
    (86) termino -> . factor neur4 n
    (93) factor -> . ( neur6 expresion ) neur7
    (94) factor -> . varcte neur1
    (98) varcte -> . ID r neurVar
    (99) varcte -> . CTEE neurCteE
    (100) varcte -> . CTEF neurCteF
    (101) varcte -> . CTEBOOL neurCteB
    (102) varcte -> . callfunc
    (103) varcte -> . CTECHAR neurCteCh
    (127) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 97
    ID              shift and go to state 102
    CTEE            shift and go to state 107
    CTEF            shift and go to state 105
    CTEBOOL         shift and go to state 103
    CTECHAR         shift and go to state 95
    CALL            shift and go to state 100

    varcte                         shift and go to state 96
    callfunc                       shift and go to state 104
    nexp                           shift and go to state 206
    termino                        shift and go to state 94
    factor                         shift and go to state 99

state 175

    (83) q -> - neur3_2 . nexp
    (79) nexp -> . termino neur5 q
    (86) termino -> . factor neur4 n
    (93) factor -> . ( neur6 expresion ) neur7
    (94) factor -> . varcte neur1
    (98) varcte -> . ID r neurVar
    (99) varcte -> . CTEE neurCteE
    (100) varcte -> . CTEF neurCteF
    (101) varcte -> . CTEBOOL neurCteB
    (102) varcte -> . callfunc
    (103) varcte -> . CTECHAR neurCteCh
    (127) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 97
    ID              shift and go to state 102
    CTEE            shift and go to state 107
    CTEF            shift and go to state 105
    CTEBOOL         shift and go to state 103
    CTECHAR         shift and go to state 95
    CALL            shift and go to state 100

    varcte                         shift and go to state 96
    callfunc                       shift and go to state 104
    nexp                           shift and go to state 207
    termino                        shift and go to state 94
    factor                         shift and go to state 99

state 176

    (93) factor -> ( neur6 expresion ) . neur7
    (96) neur7 -> .

    *               reduce using rule 96 (neur7 -> .)
    /               reduce using rule 96 (neur7 -> .)
    +               reduce using rule 96 (neur7 -> .)
    -               reduce using rule 96 (neur7 -> .)
    EQ              reduce using rule 96 (neur7 -> .)
    NOTEQ           reduce using rule 96 (neur7 -> .)
    >               reduce using rule 96 (neur7 -> .)
    <               reduce using rule 96 (neur7 -> .)
    MTHANEQ         reduce using rule 96 (neur7 -> .)
    LTHANEQ         reduce using rule 96 (neur7 -> .)
    AND             reduce using rule 96 (neur7 -> .)
    OR              reduce using rule 96 (neur7 -> .)
    ;               reduce using rule 96 (neur7 -> .)
    )               reduce using rule 96 (neur7 -> .)
    ,               reduce using rule 96 (neur7 -> .)

    neur7                          shift and go to state 208

state 177

    (71) p -> MTHANEQ neur11_5 nexp .

    AND             reduce using rule 71 (p -> MTHANEQ neur11_5 nexp .)
    OR              reduce using rule 71 (p -> MTHANEQ neur11_5 nexp .)
    ;               reduce using rule 71 (p -> MTHANEQ neur11_5 nexp .)
    )               reduce using rule 71 (p -> MTHANEQ neur11_5 nexp .)
    ,               reduce using rule 71 (p -> MTHANEQ neur11_5 nexp .)


state 178

    (72) p -> LTHANEQ neur11_6 nexp .

    AND             reduce using rule 72 (p -> LTHANEQ neur11_6 nexp .)
    OR              reduce using rule 72 (p -> LTHANEQ neur11_6 nexp .)
    ;               reduce using rule 72 (p -> LTHANEQ neur11_6 nexp .)
    )               reduce using rule 72 (p -> LTHANEQ neur11_6 nexp .)
    ,               reduce using rule 72 (p -> LTHANEQ neur11_6 nexp .)


state 179

    (68) p -> NOTEQ neur11_2 nexp .

    AND             reduce using rule 68 (p -> NOTEQ neur11_2 nexp .)
    OR              reduce using rule 68 (p -> NOTEQ neur11_2 nexp .)
    ;               reduce using rule 68 (p -> NOTEQ neur11_2 nexp .)
    )               reduce using rule 68 (p -> NOTEQ neur11_2 nexp .)
    ,               reduce using rule 68 (p -> NOTEQ neur11_2 nexp .)


state 180

    (67) p -> EQ neur11_1 nexp .

    AND             reduce using rule 67 (p -> EQ neur11_1 nexp .)
    OR              reduce using rule 67 (p -> EQ neur11_1 nexp .)
    ;               reduce using rule 67 (p -> EQ neur11_1 nexp .)
    )               reduce using rule 67 (p -> EQ neur11_1 nexp .)
    ,               reduce using rule 67 (p -> EQ neur11_1 nexp .)


state 181

    (70) p -> < neur11_4 nexp .

    AND             reduce using rule 70 (p -> < neur11_4 nexp .)
    OR              reduce using rule 70 (p -> < neur11_4 nexp .)
    ;               reduce using rule 70 (p -> < neur11_4 nexp .)
    )               reduce using rule 70 (p -> < neur11_4 nexp .)
    ,               reduce using rule 70 (p -> < neur11_4 nexp .)


state 182

    (69) p -> > neur11_3 nexp .

    AND             reduce using rule 69 (p -> > neur11_3 nexp .)
    OR              reduce using rule 69 (p -> > neur11_3 nexp .)
    ;               reduce using rule 69 (p -> > neur11_3 nexp .)
    )               reduce using rule 69 (p -> > neur11_3 nexp .)
    ,               reduce using rule 69 (p -> > neur11_3 nexp .)


state 183

    (89) n -> * neur2_1 . termino
    (86) termino -> . factor neur4 n
    (93) factor -> . ( neur6 expresion ) neur7
    (94) factor -> . varcte neur1
    (98) varcte -> . ID r neurVar
    (99) varcte -> . CTEE neurCteE
    (100) varcte -> . CTEF neurCteF
    (101) varcte -> . CTEBOOL neurCteB
    (102) varcte -> . callfunc
    (103) varcte -> . CTECHAR neurCteCh
    (127) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 97
    ID              shift and go to state 102
    CTEE            shift and go to state 107
    CTEF            shift and go to state 105
    CTEBOOL         shift and go to state 103
    CTECHAR         shift and go to state 95
    CALL            shift and go to state 100

    varcte                         shift and go to state 96
    callfunc                       shift and go to state 104
    termino                        shift and go to state 209
    factor                         shift and go to state 99

state 184

    (90) n -> / neur2_2 . termino
    (86) termino -> . factor neur4 n
    (93) factor -> . ( neur6 expresion ) neur7
    (94) factor -> . varcte neur1
    (98) varcte -> . ID r neurVar
    (99) varcte -> . CTEE neurCteE
    (100) varcte -> . CTEF neurCteF
    (101) varcte -> . CTEBOOL neurCteB
    (102) varcte -> . callfunc
    (103) varcte -> . CTECHAR neurCteCh
    (127) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 97
    ID              shift and go to state 102
    CTEE            shift and go to state 107
    CTEF            shift and go to state 105
    CTEBOOL         shift and go to state 103
    CTECHAR         shift and go to state 95
    CALL            shift and go to state 100

    varcte                         shift and go to state 96
    callfunc                       shift and go to state 104
    termino                        shift and go to state 210
    factor                         shift and go to state 99

state 185

    (129) s -> expresion . t
    (130) t -> . empty
    (131) t -> . , s
    (140) empty -> .

    ,               shift and go to state 213
    )               reduce using rule 140 (empty -> .)

    t                              shift and go to state 211
    empty                          shift and go to state 212

state 186

    (127) callfunc -> CALL ID ( s . ) ;

    )               shift and go to state 214


state 187

    (128) s -> empty .
    (55) m -> empty .

    )               reduce using rule 128 (s -> empty .)
    (               reduce using rule 55 (m -> empty .)
    ID              reduce using rule 55 (m -> empty .)
    CTEE            reduce using rule 55 (m -> empty .)
    CTEF            reduce using rule 55 (m -> empty .)
    CTEBOOL         reduce using rule 55 (m -> empty .)
    CTECHAR         reduce using rule 55 (m -> empty .)
    CALL            reduce using rule 55 (m -> empty .)


state 188

    (117) inlistset -> SET . ( CTEE , expresion )

    (               shift and go to state 215


state 189

    (112) x -> inlistset .

    *               reduce using rule 112 (x -> inlistset .)
    /               reduce using rule 112 (x -> inlistset .)
    +               reduce using rule 112 (x -> inlistset .)
    -               reduce using rule 112 (x -> inlistset .)
    EQ              reduce using rule 112 (x -> inlistset .)
    NOTEQ           reduce using rule 112 (x -> inlistset .)
    >               reduce using rule 112 (x -> inlistset .)
    <               reduce using rule 112 (x -> inlistset .)
    MTHANEQ         reduce using rule 112 (x -> inlistset .)
    LTHANEQ         reduce using rule 112 (x -> inlistset .)
    AND             reduce using rule 112 (x -> inlistset .)
    OR              reduce using rule 112 (x -> inlistset .)
    ;               reduce using rule 112 (x -> inlistset .)
    )               reduce using rule 112 (x -> inlistset .)
    ,               reduce using rule 112 (x -> inlistset .)


state 190

    (120) getlist -> GET . ( expresion )

    (               shift and go to state 216


state 191

    (115) x -> getlist .

    *               reduce using rule 115 (x -> getlist .)
    /               reduce using rule 115 (x -> getlist .)
    +               reduce using rule 115 (x -> getlist .)
    -               reduce using rule 115 (x -> getlist .)
    EQ              reduce using rule 115 (x -> getlist .)
    NOTEQ           reduce using rule 115 (x -> getlist .)
    >               reduce using rule 115 (x -> getlist .)
    <               reduce using rule 115 (x -> getlist .)
    MTHANEQ         reduce using rule 115 (x -> getlist .)
    LTHANEQ         reduce using rule 115 (x -> getlist .)
    AND             reduce using rule 115 (x -> getlist .)
    OR              reduce using rule 115 (x -> getlist .)
    ;               reduce using rule 115 (x -> getlist .)
    )               reduce using rule 115 (x -> getlist .)
    ,               reduce using rule 115 (x -> getlist .)


state 192

    (121) removelist -> REMOVE . ( expresion )

    (               shift and go to state 217


state 193

    (119) length -> LENGTH . ( )

    (               shift and go to state 218


state 194

    (114) x -> length .

    *               reduce using rule 114 (x -> length .)
    /               reduce using rule 114 (x -> length .)
    +               reduce using rule 114 (x -> length .)
    -               reduce using rule 114 (x -> length .)
    EQ              reduce using rule 114 (x -> length .)
    NOTEQ           reduce using rule 114 (x -> length .)
    >               reduce using rule 114 (x -> length .)
    <               reduce using rule 114 (x -> length .)
    MTHANEQ         reduce using rule 114 (x -> length .)
    LTHANEQ         reduce using rule 114 (x -> length .)
    AND             reduce using rule 114 (x -> length .)
    OR              reduce using rule 114 (x -> length .)
    ;               reduce using rule 114 (x -> length .)
    )               reduce using rule 114 (x -> length .)
    ,               reduce using rule 114 (x -> length .)


state 195

    (118) append -> APPEND . ( expresion )

    (               shift and go to state 219


state 196

    (111) oplista -> ID . x .

    *               reduce using rule 111 (oplista -> ID . x .)
    /               reduce using rule 111 (oplista -> ID . x .)
    +               reduce using rule 111 (oplista -> ID . x .)
    -               reduce using rule 111 (oplista -> ID . x .)
    EQ              reduce using rule 111 (oplista -> ID . x .)
    NOTEQ           reduce using rule 111 (oplista -> ID . x .)
    >               reduce using rule 111 (oplista -> ID . x .)
    <               reduce using rule 111 (oplista -> ID . x .)
    MTHANEQ         reduce using rule 111 (oplista -> ID . x .)
    LTHANEQ         reduce using rule 111 (oplista -> ID . x .)
    AND             reduce using rule 111 (oplista -> ID . x .)
    OR              reduce using rule 111 (oplista -> ID . x .)
    ;               reduce using rule 111 (oplista -> ID . x .)
    )               reduce using rule 111 (oplista -> ID . x .)
    ,               reduce using rule 111 (oplista -> ID . x .)


state 197

    (116) x -> removelist .

    *               reduce using rule 116 (x -> removelist .)
    /               reduce using rule 116 (x -> removelist .)
    +               reduce using rule 116 (x -> removelist .)
    -               reduce using rule 116 (x -> removelist .)
    EQ              reduce using rule 116 (x -> removelist .)
    NOTEQ           reduce using rule 116 (x -> removelist .)
    >               reduce using rule 116 (x -> removelist .)
    <               reduce using rule 116 (x -> removelist .)
    MTHANEQ         reduce using rule 116 (x -> removelist .)
    LTHANEQ         reduce using rule 116 (x -> removelist .)
    AND             reduce using rule 116 (x -> removelist .)
    OR              reduce using rule 116 (x -> removelist .)
    ;               reduce using rule 116 (x -> removelist .)
    )               reduce using rule 116 (x -> removelist .)
    ,               reduce using rule 116 (x -> removelist .)


state 198

    (113) x -> append .

    *               reduce using rule 113 (x -> append .)
    /               reduce using rule 113 (x -> append .)
    +               reduce using rule 113 (x -> append .)
    -               reduce using rule 113 (x -> append .)
    EQ              reduce using rule 113 (x -> append .)
    NOTEQ           reduce using rule 113 (x -> append .)
    >               reduce using rule 113 (x -> append .)
    <               reduce using rule 113 (x -> append .)
    MTHANEQ         reduce using rule 113 (x -> append .)
    LTHANEQ         reduce using rule 113 (x -> append .)
    AND             reduce using rule 113 (x -> append .)
    OR              reduce using rule 113 (x -> append .)
    ;               reduce using rule 113 (x -> append .)
    )               reduce using rule 113 (x -> append .)
    ,               reduce using rule 113 (x -> append .)


state 199

    (60) o -> AND neur9_1 . subexpresion
    (57) subexpresion -> . exp neur10 o
    (64) exp -> . nexp p neur12
    (79) nexp -> . termino neur5 q
    (86) termino -> . factor neur4 n
    (93) factor -> . ( neur6 expresion ) neur7
    (94) factor -> . varcte neur1
    (98) varcte -> . ID r neurVar
    (99) varcte -> . CTEE neurCteE
    (100) varcte -> . CTEF neurCteF
    (101) varcte -> . CTEBOOL neurCteB
    (102) varcte -> . callfunc
    (103) varcte -> . CTECHAR neurCteCh
    (127) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 97
    ID              shift and go to state 102
    CTEE            shift and go to state 107
    CTEF            shift and go to state 105
    CTEBOOL         shift and go to state 103
    CTECHAR         shift and go to state 95
    CALL            shift and go to state 100

    termino                        shift and go to state 94
    varcte                         shift and go to state 96
    nexp                           shift and go to state 98
    factor                         shift and go to state 99
    subexpresion                   shift and go to state 220
    callfunc                       shift and go to state 104
    exp                            shift and go to state 106

state 200

    (61) o -> OR neur9_2 . subexpresion
    (57) subexpresion -> . exp neur10 o
    (64) exp -> . nexp p neur12
    (79) nexp -> . termino neur5 q
    (86) termino -> . factor neur4 n
    (93) factor -> . ( neur6 expresion ) neur7
    (94) factor -> . varcte neur1
    (98) varcte -> . ID r neurVar
    (99) varcte -> . CTEE neurCteE
    (100) varcte -> . CTEF neurCteF
    (101) varcte -> . CTEBOOL neurCteB
    (102) varcte -> . callfunc
    (103) varcte -> . CTECHAR neurCteCh
    (127) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 97
    ID              shift and go to state 102
    CTEE            shift and go to state 107
    CTEF            shift and go to state 105
    CTEBOOL         shift and go to state 103
    CTECHAR         shift and go to state 95
    CALL            shift and go to state 100

    termino                        shift and go to state 94
    varcte                         shift and go to state 96
    nexp                           shift and go to state 98
    factor                         shift and go to state 99
    subexpresion                   shift and go to state 221
    callfunc                       shift and go to state 104
    exp                            shift and go to state 106

state 201

    (125) play -> PLAY ( NOTA , CTEE ) . ;

    ;               shift and go to state 222


state 202

    (49) for -> FOR ( asignacion neur18 expresion ; . neur19 asignacion ) neur21 bloque ; neur20
    (51) neur19 -> .

    ID              reduce using rule 51 (neur19 -> .)

    neur19                         shift and go to state 223

state 203

    (42) asiglista -> NEW LIST ( . )

    )               shift and go to state 224


state 204

    (43) if -> IF ( expresion ) neur13 bloque . l ;
    (45) l -> . empty neur15
    (46) l -> . ELSE neur14 bloque
    (140) empty -> .

    ELSE            shift and go to state 226
    ;               reduce using rule 140 (empty -> .)

    l                              shift and go to state 225
    empty                          shift and go to state 227

state 205

    (122) while -> WHILE ( neur16 expresion ) neur13 bloque . neur17 ;
    (124) neur17 -> .

    ;               reduce using rule 124 (neur17 -> .)

    neur17                         shift and go to state 228

state 206

    (82) q -> + neur3_1 nexp .

    EQ              reduce using rule 82 (q -> + neur3_1 nexp .)
    NOTEQ           reduce using rule 82 (q -> + neur3_1 nexp .)
    >               reduce using rule 82 (q -> + neur3_1 nexp .)
    <               reduce using rule 82 (q -> + neur3_1 nexp .)
    MTHANEQ         reduce using rule 82 (q -> + neur3_1 nexp .)
    LTHANEQ         reduce using rule 82 (q -> + neur3_1 nexp .)
    AND             reduce using rule 82 (q -> + neur3_1 nexp .)
    OR              reduce using rule 82 (q -> + neur3_1 nexp .)
    ;               reduce using rule 82 (q -> + neur3_1 nexp .)
    )               reduce using rule 82 (q -> + neur3_1 nexp .)
    ,               reduce using rule 82 (q -> + neur3_1 nexp .)


state 207

    (83) q -> - neur3_2 nexp .

    EQ              reduce using rule 83 (q -> - neur3_2 nexp .)
    NOTEQ           reduce using rule 83 (q -> - neur3_2 nexp .)
    >               reduce using rule 83 (q -> - neur3_2 nexp .)
    <               reduce using rule 83 (q -> - neur3_2 nexp .)
    MTHANEQ         reduce using rule 83 (q -> - neur3_2 nexp .)
    LTHANEQ         reduce using rule 83 (q -> - neur3_2 nexp .)
    AND             reduce using rule 83 (q -> - neur3_2 nexp .)
    OR              reduce using rule 83 (q -> - neur3_2 nexp .)
    ;               reduce using rule 83 (q -> - neur3_2 nexp .)
    )               reduce using rule 83 (q -> - neur3_2 nexp .)
    ,               reduce using rule 83 (q -> - neur3_2 nexp .)


state 208

    (93) factor -> ( neur6 expresion ) neur7 .

    *               reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)
    /               reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)
    +               reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)
    -               reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)
    AND             reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)
    OR              reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)
    ;               reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)
    )               reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)
    ,               reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)
    EQ              reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)
    NOTEQ           reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)
    >               reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)
    <               reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)
    MTHANEQ         reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)
    LTHANEQ         reduce using rule 93 (factor -> ( neur6 expresion ) neur7 .)


state 209

    (89) n -> * neur2_1 termino .

    +               reduce using rule 89 (n -> * neur2_1 termino .)
    -               reduce using rule 89 (n -> * neur2_1 termino .)
    EQ              reduce using rule 89 (n -> * neur2_1 termino .)
    NOTEQ           reduce using rule 89 (n -> * neur2_1 termino .)
    >               reduce using rule 89 (n -> * neur2_1 termino .)
    <               reduce using rule 89 (n -> * neur2_1 termino .)
    MTHANEQ         reduce using rule 89 (n -> * neur2_1 termino .)
    LTHANEQ         reduce using rule 89 (n -> * neur2_1 termino .)
    AND             reduce using rule 89 (n -> * neur2_1 termino .)
    OR              reduce using rule 89 (n -> * neur2_1 termino .)
    ;               reduce using rule 89 (n -> * neur2_1 termino .)
    )               reduce using rule 89 (n -> * neur2_1 termino .)
    ,               reduce using rule 89 (n -> * neur2_1 termino .)


state 210

    (90) n -> / neur2_2 termino .

    +               reduce using rule 90 (n -> / neur2_2 termino .)
    -               reduce using rule 90 (n -> / neur2_2 termino .)
    EQ              reduce using rule 90 (n -> / neur2_2 termino .)
    NOTEQ           reduce using rule 90 (n -> / neur2_2 termino .)
    >               reduce using rule 90 (n -> / neur2_2 termino .)
    <               reduce using rule 90 (n -> / neur2_2 termino .)
    MTHANEQ         reduce using rule 90 (n -> / neur2_2 termino .)
    LTHANEQ         reduce using rule 90 (n -> / neur2_2 termino .)
    AND             reduce using rule 90 (n -> / neur2_2 termino .)
    OR              reduce using rule 90 (n -> / neur2_2 termino .)
    ;               reduce using rule 90 (n -> / neur2_2 termino .)
    )               reduce using rule 90 (n -> / neur2_2 termino .)
    ,               reduce using rule 90 (n -> / neur2_2 termino .)


state 211

    (129) s -> expresion t .

    )               reduce using rule 129 (s -> expresion t .)


state 212

    (130) t -> empty .

    )               reduce using rule 130 (t -> empty .)


state 213

    (131) t -> , . s
    (128) s -> . empty
    (129) s -> . expresion t
    (140) empty -> .
    (54) expresion -> . m subexpresion
    (55) m -> . empty
    (56) m -> . NOT

    )               reduce using rule 140 (empty -> .)
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTEE            reduce using rule 140 (empty -> .)
    CTEF            reduce using rule 140 (empty -> .)
    CTEBOOL         reduce using rule 140 (empty -> .)
    CTECHAR         reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)
    NOT             shift and go to state 80

    expresion                      shift and go to state 185
    m                              shift and go to state 79
    s                              shift and go to state 229
    empty                          shift and go to state 187

state 214

    (127) callfunc -> CALL ID ( s ) . ;

    ;               shift and go to state 230


state 215

    (117) inlistset -> SET ( . CTEE , expresion )

    CTEE            shift and go to state 231


state 216

    (120) getlist -> GET ( . expresion )
    (54) expresion -> . m subexpresion
    (55) m -> . empty
    (56) m -> . NOT
    (140) empty -> .

    NOT             shift and go to state 80
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTEE            reduce using rule 140 (empty -> .)
    CTEF            reduce using rule 140 (empty -> .)
    CTEBOOL         reduce using rule 140 (empty -> .)
    CTECHAR         reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)

    expresion                      shift and go to state 232
    m                              shift and go to state 79
    empty                          shift and go to state 81

state 217

    (121) removelist -> REMOVE ( . expresion )
    (54) expresion -> . m subexpresion
    (55) m -> . empty
    (56) m -> . NOT
    (140) empty -> .

    NOT             shift and go to state 80
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTEE            reduce using rule 140 (empty -> .)
    CTEF            reduce using rule 140 (empty -> .)
    CTEBOOL         reduce using rule 140 (empty -> .)
    CTECHAR         reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)

    expresion                      shift and go to state 233
    m                              shift and go to state 79
    empty                          shift and go to state 81

state 218

    (119) length -> LENGTH ( . )

    )               shift and go to state 234


state 219

    (118) append -> APPEND ( . expresion )
    (54) expresion -> . m subexpresion
    (55) m -> . empty
    (56) m -> . NOT
    (140) empty -> .

    NOT             shift and go to state 80
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTEE            reduce using rule 140 (empty -> .)
    CTEF            reduce using rule 140 (empty -> .)
    CTEBOOL         reduce using rule 140 (empty -> .)
    CTECHAR         reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)

    expresion                      shift and go to state 235
    m                              shift and go to state 79
    empty                          shift and go to state 81

state 220

    (60) o -> AND neur9_1 subexpresion .

    ;               reduce using rule 60 (o -> AND neur9_1 subexpresion .)
    )               reduce using rule 60 (o -> AND neur9_1 subexpresion .)
    ,               reduce using rule 60 (o -> AND neur9_1 subexpresion .)


state 221

    (61) o -> OR neur9_2 subexpresion .

    ;               reduce using rule 61 (o -> OR neur9_2 subexpresion .)
    )               reduce using rule 61 (o -> OR neur9_2 subexpresion .)
    ,               reduce using rule 61 (o -> OR neur9_2 subexpresion .)


state 222

    (125) play -> PLAY ( NOTA , CTEE ) ; .

    ID              reduce using rule 125 (play -> PLAY ( NOTA , CTEE ) ; .)
    IF              reduce using rule 125 (play -> PLAY ( NOTA , CTEE ) ; .)
    FOR             reduce using rule 125 (play -> PLAY ( NOTA , CTEE ) ; .)
    RETURN          reduce using rule 125 (play -> PLAY ( NOTA , CTEE ) ; .)
    WHILE           reduce using rule 125 (play -> PLAY ( NOTA , CTEE ) ; .)
    PLAY            reduce using rule 125 (play -> PLAY ( NOTA , CTEE ) ; .)
    PRINT           reduce using rule 125 (play -> PLAY ( NOTA , CTEE ) ; .)
    }               reduce using rule 125 (play -> PLAY ( NOTA , CTEE ) ; .)


state 223

    (49) for -> FOR ( asignacion neur18 expresion ; neur19 . asignacion ) neur21 bloque ; neur20
    (38) asignacion -> . ID = neur8 k ;

    ID              shift and go to state 67

    asignacion                     shift and go to state 236

state 224

    (42) asiglista -> NEW LIST ( ) .

    ;               reduce using rule 42 (asiglista -> NEW LIST ( ) .)


state 225

    (43) if -> IF ( expresion ) neur13 bloque l . ;

    ;               shift and go to state 237


state 226

    (46) l -> ELSE . neur14 bloque
    (47) neur14 -> .

    {               reduce using rule 47 (neur14 -> .)

    neur14                         shift and go to state 238

state 227

    (45) l -> empty . neur15
    (48) neur15 -> .

    ;               reduce using rule 48 (neur15 -> .)

    neur15                         shift and go to state 239

state 228

    (122) while -> WHILE ( neur16 expresion ) neur13 bloque neur17 . ;

    ;               shift and go to state 240


state 229

    (131) t -> , s .

    )               reduce using rule 131 (t -> , s .)


state 230

    (127) callfunc -> CALL ID ( s ) ; .

    *               reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)
    /               reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)
    +               reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)
    -               reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)
    AND             reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)
    OR              reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)
    ;               reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)
    )               reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)
    ,               reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)
    EQ              reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)
    NOTEQ           reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)
    >               reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)
    <               reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)
    MTHANEQ         reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)
    LTHANEQ         reduce using rule 127 (callfunc -> CALL ID ( s ) ; .)


state 231

    (117) inlistset -> SET ( CTEE . , expresion )

    ,               shift and go to state 241


state 232

    (120) getlist -> GET ( expresion . )

    )               shift and go to state 242


state 233

    (121) removelist -> REMOVE ( expresion . )

    )               shift and go to state 243


state 234

    (119) length -> LENGTH ( ) .

    *               reduce using rule 119 (length -> LENGTH ( ) .)
    /               reduce using rule 119 (length -> LENGTH ( ) .)
    +               reduce using rule 119 (length -> LENGTH ( ) .)
    -               reduce using rule 119 (length -> LENGTH ( ) .)
    EQ              reduce using rule 119 (length -> LENGTH ( ) .)
    NOTEQ           reduce using rule 119 (length -> LENGTH ( ) .)
    >               reduce using rule 119 (length -> LENGTH ( ) .)
    <               reduce using rule 119 (length -> LENGTH ( ) .)
    MTHANEQ         reduce using rule 119 (length -> LENGTH ( ) .)
    LTHANEQ         reduce using rule 119 (length -> LENGTH ( ) .)
    AND             reduce using rule 119 (length -> LENGTH ( ) .)
    OR              reduce using rule 119 (length -> LENGTH ( ) .)
    ;               reduce using rule 119 (length -> LENGTH ( ) .)
    )               reduce using rule 119 (length -> LENGTH ( ) .)
    ,               reduce using rule 119 (length -> LENGTH ( ) .)


state 235

    (118) append -> APPEND ( expresion . )

    )               shift and go to state 244


state 236

    (49) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion . ) neur21 bloque ; neur20

    )               shift and go to state 245


state 237

    (43) if -> IF ( expresion ) neur13 bloque l ; .

    ID              reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)
    IF              reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)
    FOR             reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)
    RETURN          reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)
    WHILE           reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)
    PLAY            reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)
    PRINT           reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)
    }               reduce using rule 43 (if -> IF ( expresion ) neur13 bloque l ; .)


state 238

    (46) l -> ELSE neur14 . bloque
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 246

state 239

    (45) l -> empty neur15 .

    ;               reduce using rule 45 (l -> empty neur15 .)


state 240

    (122) while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .

    ID              reduce using rule 122 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)
    IF              reduce using rule 122 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)
    FOR             reduce using rule 122 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)
    RETURN          reduce using rule 122 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)
    WHILE           reduce using rule 122 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)
    PLAY            reduce using rule 122 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)
    PRINT           reduce using rule 122 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)
    }               reduce using rule 122 (while -> WHILE ( neur16 expresion ) neur13 bloque neur17 ; .)


state 241

    (117) inlistset -> SET ( CTEE , . expresion )
    (54) expresion -> . m subexpresion
    (55) m -> . empty
    (56) m -> . NOT
    (140) empty -> .

    NOT             shift and go to state 80
    (               reduce using rule 140 (empty -> .)
    ID              reduce using rule 140 (empty -> .)
    CTEE            reduce using rule 140 (empty -> .)
    CTEF            reduce using rule 140 (empty -> .)
    CTEBOOL         reduce using rule 140 (empty -> .)
    CTECHAR         reduce using rule 140 (empty -> .)
    CALL            reduce using rule 140 (empty -> .)

    expresion                      shift and go to state 247
    m                              shift and go to state 79
    empty                          shift and go to state 81

state 242

    (120) getlist -> GET ( expresion ) .

    *               reduce using rule 120 (getlist -> GET ( expresion ) .)
    /               reduce using rule 120 (getlist -> GET ( expresion ) .)
    +               reduce using rule 120 (getlist -> GET ( expresion ) .)
    -               reduce using rule 120 (getlist -> GET ( expresion ) .)
    EQ              reduce using rule 120 (getlist -> GET ( expresion ) .)
    NOTEQ           reduce using rule 120 (getlist -> GET ( expresion ) .)
    >               reduce using rule 120 (getlist -> GET ( expresion ) .)
    <               reduce using rule 120 (getlist -> GET ( expresion ) .)
    MTHANEQ         reduce using rule 120 (getlist -> GET ( expresion ) .)
    LTHANEQ         reduce using rule 120 (getlist -> GET ( expresion ) .)
    AND             reduce using rule 120 (getlist -> GET ( expresion ) .)
    OR              reduce using rule 120 (getlist -> GET ( expresion ) .)
    ;               reduce using rule 120 (getlist -> GET ( expresion ) .)
    )               reduce using rule 120 (getlist -> GET ( expresion ) .)
    ,               reduce using rule 120 (getlist -> GET ( expresion ) .)


state 243

    (121) removelist -> REMOVE ( expresion ) .

    *               reduce using rule 121 (removelist -> REMOVE ( expresion ) .)
    /               reduce using rule 121 (removelist -> REMOVE ( expresion ) .)
    +               reduce using rule 121 (removelist -> REMOVE ( expresion ) .)
    -               reduce using rule 121 (removelist -> REMOVE ( expresion ) .)
    EQ              reduce using rule 121 (removelist -> REMOVE ( expresion ) .)
    NOTEQ           reduce using rule 121 (removelist -> REMOVE ( expresion ) .)
    >               reduce using rule 121 (removelist -> REMOVE ( expresion ) .)
    <               reduce using rule 121 (removelist -> REMOVE ( expresion ) .)
    MTHANEQ         reduce using rule 121 (removelist -> REMOVE ( expresion ) .)
    LTHANEQ         reduce using rule 121 (removelist -> REMOVE ( expresion ) .)
    AND             reduce using rule 121 (removelist -> REMOVE ( expresion ) .)
    OR              reduce using rule 121 (removelist -> REMOVE ( expresion ) .)
    ;               reduce using rule 121 (removelist -> REMOVE ( expresion ) .)
    )               reduce using rule 121 (removelist -> REMOVE ( expresion ) .)
    ,               reduce using rule 121 (removelist -> REMOVE ( expresion ) .)


state 244

    (118) append -> APPEND ( expresion ) .

    *               reduce using rule 118 (append -> APPEND ( expresion ) .)
    /               reduce using rule 118 (append -> APPEND ( expresion ) .)
    +               reduce using rule 118 (append -> APPEND ( expresion ) .)
    -               reduce using rule 118 (append -> APPEND ( expresion ) .)
    EQ              reduce using rule 118 (append -> APPEND ( expresion ) .)
    NOTEQ           reduce using rule 118 (append -> APPEND ( expresion ) .)
    >               reduce using rule 118 (append -> APPEND ( expresion ) .)
    <               reduce using rule 118 (append -> APPEND ( expresion ) .)
    MTHANEQ         reduce using rule 118 (append -> APPEND ( expresion ) .)
    LTHANEQ         reduce using rule 118 (append -> APPEND ( expresion ) .)
    AND             reduce using rule 118 (append -> APPEND ( expresion ) .)
    OR              reduce using rule 118 (append -> APPEND ( expresion ) .)
    ;               reduce using rule 118 (append -> APPEND ( expresion ) .)
    )               reduce using rule 118 (append -> APPEND ( expresion ) .)
    ,               reduce using rule 118 (append -> APPEND ( expresion ) .)


state 245

    (49) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) . neur21 bloque ; neur20
    (52) neur21 -> .

    {               reduce using rule 52 (neur21 -> .)

    neur21                         shift and go to state 248

state 246

    (46) l -> ELSE neur14 bloque .

    ;               reduce using rule 46 (l -> ELSE neur14 bloque .)


state 247

    (117) inlistset -> SET ( CTEE , expresion . )

    )               shift and go to state 249


state 248

    (49) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 . bloque ; neur20
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 250

state 249

    (117) inlistset -> SET ( CTEE , expresion ) .

    *               reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)
    /               reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)
    +               reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)
    -               reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)
    EQ              reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)
    NOTEQ           reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)
    >               reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)
    <               reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)
    MTHANEQ         reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)
    LTHANEQ         reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)
    AND             reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)
    OR              reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)
    ;               reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)
    )               reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)
    ,               reduce using rule 117 (inlistset -> SET ( CTEE , expresion ) .)


state 250

    (49) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque . ; neur20

    ;               shift and go to state 251


state 251

    (49) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; . neur20
    (53) neur20 -> .

    ID              reduce using rule 53 (neur20 -> .)
    IF              reduce using rule 53 (neur20 -> .)
    FOR             reduce using rule 53 (neur20 -> .)
    RETURN          reduce using rule 53 (neur20 -> .)
    WHILE           reduce using rule 53 (neur20 -> .)
    PLAY            reduce using rule 53 (neur20 -> .)
    PRINT           reduce using rule 53 (neur20 -> .)
    }               reduce using rule 53 (neur20 -> .)

    neur20                         shift and go to state 252

state 252

    (49) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .

    ID              reduce using rule 49 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    IF              reduce using rule 49 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    FOR             reduce using rule 49 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    RETURN          reduce using rule 49 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    WHILE           reduce using rule 49 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    PLAY            reduce using rule 49 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    PRINT           reduce using rule 49 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    }               reduce using rule 49 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 13 resolved using rule (a -> empty)
WARNING: rejected rule (b -> empty) in state 13
WARNING: reduce/reduce conflict in state 24 resolved using rule (c -> empty)
WARNING: rejected rule (d -> empty) in state 24
WARNING: reduce/reduce conflict in state 50 resolved using rule (f -> empty)
WARNING: rejected rule (g -> empty) in state 50
WARNING: reduce/reduce conflict in state 82 resolved using rule (i -> empty)
WARNING: rejected rule (j -> empty) in state 82
WARNING: Rule (b -> empty) is never reduced
WARNING: Rule (d -> empty) is never reduced
WARNING: Rule (g -> empty) is never reduced
WARNING: Rule (j -> empty) is never reduced
