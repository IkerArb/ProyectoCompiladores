Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programa
Rule 1     programa -> creadirprocglobal a c cancion
Rule 2     creadirprocglobal -> <empty>
Rule 3     a -> empty
Rule 4     a -> vars b
Rule 5     b -> empty
Rule 6     b -> a
Rule 7     c -> empty
Rule 8     c -> funcion d
Rule 9     d -> empty
Rule 10    d -> c
Rule 11    vars -> VAR v : tipo ;
Rule 12    v -> ID
Rule 13    funcion -> FUNC tipo ID meterfuncion ( params ) f bloque
Rule 14    meterfuncion -> <empty>
Rule 15    f -> empty
Rule 16    f -> vars g
Rule 17    g -> empty
Rule 18    g -> f
Rule 19    params -> empty
Rule 20    params -> tipo ID meterparams h
Rule 21    meterparams -> <empty>
Rule 22    h -> empty
Rule 23    h -> , params
Rule 24    i -> empty
Rule 25    i -> estatuto j
Rule 26    j -> empty
Rule 27    j -> i
Rule 28    bloque -> { i }
Rule 29    cancion -> CANCION ( CTEE ) metercancion f bloque
Rule 30    metercancion -> <empty>
Rule 31    estatuto -> asignacion
Rule 32    estatuto -> if
Rule 33    estatuto -> for
Rule 34    estatuto -> return
Rule 35    estatuto -> while
Rule 36    estatuto -> play
Rule 37    estatuto -> print
Rule 38    asignacion -> ID = neur8 k ;
Rule 39    neur8 -> <empty>
Rule 40    k -> expresion
Rule 41    k -> asiglista
Rule 42    asiglista -> NEW LIST ( )
Rule 43    if -> IF ( expresion ) bloque l ;
Rule 44    l -> empty
Rule 45    l -> ELSE bloque
Rule 46    for -> FOR ( asignacion expresion asignacion ) bloque ;
Rule 47    expresion -> m subexpresion
Rule 48    m -> empty
Rule 49    m -> NOT
Rule 50    subexpresion -> exp neur10 o
Rule 51    neur10 -> <empty>
Rule 52    o -> empty
Rule 53    o -> AND neur9_1 subexpresion
Rule 54    o -> OR neur9_2 subexpresion
Rule 55    neur9_1 -> <empty>
Rule 56    neur9_2 -> <empty>
Rule 57    exp -> nexp neur12 p
Rule 58    neur12 -> <empty>
Rule 59    p -> empty
Rule 60    p -> EQ neur11_1 nexp
Rule 61    p -> NOTEQ neur11_2 nexp
Rule 62    p -> > neur11_3 nexp
Rule 63    p -> < neur11_4 nexp
Rule 64    p -> MTHANEQ neur11_5 nexp
Rule 65    p -> LTHANEQ neur11_6 nexp
Rule 66    neur11_1 -> <empty>
Rule 67    neur11_2 -> <empty>
Rule 68    neur11_3 -> <empty>
Rule 69    neur11_4 -> <empty>
Rule 70    neur11_5 -> <empty>
Rule 71    neur11_6 -> <empty>
Rule 72    nexp -> termino neur5 q
Rule 73    neur5 -> <empty>
Rule 74    q -> empty
Rule 75    q -> + neur3_1 nexp
Rule 76    q -> - neur3_2 nexp
Rule 77    neur3_1 -> <empty>
Rule 78    neur3_2 -> <empty>
Rule 79    termino -> factor neur4 n
Rule 80    neur4 -> <empty>
Rule 81    n -> empty
Rule 82    n -> * neur2_1 termino
Rule 83    n -> / neur2_2 termino
Rule 84    neur2_1 -> <empty>
Rule 85    neur2_2 -> <empty>
Rule 86    factor -> ( neur6 expresion ) neur7
Rule 87    factor -> varcte neur1
Rule 88    neur6 -> <empty>
Rule 89    neur7 -> <empty>
Rule 90    neur1 -> <empty>
Rule 91    varcte -> ID r neurVar
Rule 92    varcte -> CTEE neurCteE
Rule 93    varcte -> CTEF neurCteF
Rule 94    varcte -> CTEBOOL neurCteB
Rule 95    varcte -> callfunc
Rule 96    varcte -> CTECHAR neurCteCh
Rule 97    neurVar -> <empty>
Rule 98    neurCteE -> <empty>
Rule 99    neurCteF -> <empty>
Rule 100   neurCteB -> <empty>
Rule 101   neurCteCh -> <empty>
Rule 102   r -> empty
Rule 103   r -> oplista
Rule 104   oplista -> ID . x
Rule 105   x -> inlistset
Rule 106   x -> append
Rule 107   x -> length
Rule 108   x -> getlist
Rule 109   x -> removelist
Rule 110   inlistset -> SET ( CTEE , expresion )
Rule 111   append -> APPEND ( expresion )
Rule 112   length -> LENGTH ( )
Rule 113   getlist -> GET ( expresion )
Rule 114   removelist -> REMOVE ( expresion )
Rule 115   while -> WHILE ( expresion ) bloque ;
Rule 116   play -> PLAY ( NOTA , CTEE ) ;
Rule 117   print -> PRINT expresion ;
Rule 118   callfunc -> CALL ID ( s ) ;
Rule 119   s -> empty
Rule 120   s -> expresion t
Rule 121   t -> empty
Rule 122   t -> , s
Rule 123   return -> RETURN ( expresion ) ;
Rule 124   tipo -> u y
Rule 125   u -> empty
Rule 126   u -> LIST
Rule 127   y -> INT
Rule 128   y -> CHAR
Rule 129   y -> FLOAT
Rule 130   y -> BOOL
Rule 131   empty -> <empty>

Terminals, with rules where they appear

(                    : 13 29 42 43 46 86 110 111 112 113 114 115 116 118 123
)                    : 13 29 42 43 46 86 110 111 112 113 114 115 116 118 123
*                    : 82
+                    : 75
,                    : 23 110 116 122
-                    : 76
.                    : 104
/                    : 83
:                    : 11
;                    : 11 38 43 46 115 116 117 118 123
<                    : 63
=                    : 38
>                    : 62
AND                  : 53
APPEND               : 111
BOOL                 : 130
CALL                 : 118
CANCION              : 29
CHAR                 : 128
CTEBOOL              : 94
CTECHAR              : 96
CTEE                 : 29 92 110 116
CTEF                 : 93
ELSE                 : 45
EQ                   : 60
FLOAT                : 129
FOR                  : 46
FUNC                 : 13
GET                  : 113
ID                   : 12 13 20 38 91 104 118
IF                   : 43
INT                  : 127
LENGTH               : 112
LIST                 : 42 126
LTHANEQ              : 65
MTHANEQ              : 64
NEW                  : 42
NOT                  : 49
NOTA                 : 116
NOTEQ                : 61
OR                   : 54
PLAY                 : 116
PRINT                : 117
REMOVE               : 114
RETURN               : 123
SET                  : 110
VAR                  : 11
WHILE                : 115
error                : 
{                    : 28
}                    : 28

Nonterminals, with rules where they appear

a                    : 1 6
append               : 106
asiglista            : 41
asignacion           : 31 46 46
b                    : 4
bloque               : 13 29 43 45 46 115
c                    : 1 10
callfunc             : 95
cancion              : 1
creadirprocglobal    : 1
d                    : 8
empty                : 3 5 7 9 15 17 19 22 24 26 44 48 52 59 74 81 102 119 121 125
estatuto             : 25
exp                  : 50
expresion            : 40 43 46 86 110 111 113 114 115 117 120 123
f                    : 13 18 29
factor               : 79
for                  : 33
funcion              : 8
g                    : 16
getlist              : 108
h                    : 20
i                    : 27 28
if                   : 32
inlistset            : 105
j                    : 25
k                    : 38
l                    : 43
length               : 107
m                    : 47
metercancion         : 29
meterfuncion         : 13
meterparams          : 20
n                    : 79
neur1                : 87
neur10               : 50
neur11_1             : 60
neur11_2             : 61
neur11_3             : 62
neur11_4             : 63
neur11_5             : 64
neur11_6             : 65
neur12               : 57
neur2_1              : 82
neur2_2              : 83
neur3_1              : 75
neur3_2              : 76
neur4                : 79
neur5                : 72
neur6                : 86
neur7                : 86
neur8                : 38
neur9_1              : 53
neur9_2              : 54
neurCteB             : 94
neurCteCh            : 96
neurCteE             : 92
neurCteF             : 93
neurVar              : 91
nexp                 : 57 60 61 62 63 64 65 75 76
o                    : 50
oplista              : 103
p                    : 57
params               : 13 23
play                 : 36
print                : 37
programa             : 0
q                    : 72
r                    : 91
removelist           : 109
return               : 34
s                    : 118 122
subexpresion         : 47 53 54
t                    : 120
termino              : 72 82 83
tipo                 : 11 13 20
u                    : 124
v                    : 11
varcte               : 87
vars                 : 4 16
while                : 35
x                    : 104
y                    : 124

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . creadirprocglobal a c cancion
    (2) creadirprocglobal -> .

    VAR             reduce using rule 2 (creadirprocglobal -> .)
    FUNC            reduce using rule 2 (creadirprocglobal -> .)
    CANCION         reduce using rule 2 (creadirprocglobal -> .)

    programa                       shift and go to state 1
    creadirprocglobal              shift and go to state 2

state 1

    (0) S' -> programa .



state 2

    (1) programa -> creadirprocglobal . a c cancion
    (3) a -> . empty
    (4) a -> . vars b
    (131) empty -> .
    (11) vars -> . VAR v : tipo ;

    FUNC            reduce using rule 131 (empty -> .)
    CANCION         reduce using rule 131 (empty -> .)
    VAR             shift and go to state 5

    a                              shift and go to state 3
    vars                           shift and go to state 4
    empty                          shift and go to state 6

state 3

    (1) programa -> creadirprocglobal a . c cancion
    (7) c -> . empty
    (8) c -> . funcion d
    (131) empty -> .
    (13) funcion -> . FUNC tipo ID meterfuncion ( params ) f bloque

    CANCION         reduce using rule 131 (empty -> .)
    FUNC            shift and go to state 8

    c                              shift and go to state 7
    empty                          shift and go to state 9
    funcion                        shift and go to state 10

state 4

    (4) a -> vars . b
    (5) b -> . empty
    (6) b -> . a
    (131) empty -> .
    (3) a -> . empty
    (4) a -> . vars b
    (11) vars -> . VAR v : tipo ;

    FUNC            reduce using rule 131 (empty -> .)
    CANCION         reduce using rule 131 (empty -> .)
    VAR             shift and go to state 5

    a                              shift and go to state 11
    b                              shift and go to state 12
    vars                           shift and go to state 4
    empty                          shift and go to state 13

state 5

    (11) vars -> VAR . v : tipo ;
    (12) v -> . ID

    ID              shift and go to state 15

    v                              shift and go to state 14

state 6

    (3) a -> empty .

    FUNC            reduce using rule 3 (a -> empty .)
    CANCION         reduce using rule 3 (a -> empty .)


state 7

    (1) programa -> creadirprocglobal a c . cancion
    (29) cancion -> . CANCION ( CTEE ) metercancion f bloque

    CANCION         shift and go to state 16

    cancion                        shift and go to state 17

state 8

    (13) funcion -> FUNC . tipo ID meterfuncion ( params ) f bloque
    (124) tipo -> . u y
    (125) u -> . empty
    (126) u -> . LIST
    (131) empty -> .

    LIST            shift and go to state 19
    INT             reduce using rule 131 (empty -> .)
    CHAR            reduce using rule 131 (empty -> .)
    FLOAT           reduce using rule 131 (empty -> .)
    BOOL            reduce using rule 131 (empty -> .)

    tipo                           shift and go to state 18
    u                              shift and go to state 20
    empty                          shift and go to state 21

state 9

    (7) c -> empty .

    CANCION         reduce using rule 7 (c -> empty .)


state 10

    (8) c -> funcion . d
    (9) d -> . empty
    (10) d -> . c
    (131) empty -> .
    (7) c -> . empty
    (8) c -> . funcion d
    (13) funcion -> . FUNC tipo ID meterfuncion ( params ) f bloque

    CANCION         reduce using rule 131 (empty -> .)
    FUNC            shift and go to state 8

    c                              shift and go to state 22
    d                              shift and go to state 23
    empty                          shift and go to state 24
    funcion                        shift and go to state 10

state 11

    (6) b -> a .

    FUNC            reduce using rule 6 (b -> a .)
    CANCION         reduce using rule 6 (b -> a .)


state 12

    (4) a -> vars b .

    FUNC            reduce using rule 4 (a -> vars b .)
    CANCION         reduce using rule 4 (a -> vars b .)


state 13

    (5) b -> empty .
    (3) a -> empty .

  ! reduce/reduce conflict for FUNC resolved using rule 3 (a -> empty .)
  ! reduce/reduce conflict for CANCION resolved using rule 3 (a -> empty .)
    FUNC            reduce using rule 3 (a -> empty .)
    CANCION         reduce using rule 3 (a -> empty .)

  ! FUNC            [ reduce using rule 5 (b -> empty .) ]
  ! CANCION         [ reduce using rule 5 (b -> empty .) ]


state 14

    (11) vars -> VAR v . : tipo ;

    :               shift and go to state 25


state 15

    (12) v -> ID .

    :               reduce using rule 12 (v -> ID .)


state 16

    (29) cancion -> CANCION . ( CTEE ) metercancion f bloque

    (               shift and go to state 26


state 17

    (1) programa -> creadirprocglobal a c cancion .

    $end            reduce using rule 1 (programa -> creadirprocglobal a c cancion .)


state 18

    (13) funcion -> FUNC tipo . ID meterfuncion ( params ) f bloque

    ID              shift and go to state 27


state 19

    (126) u -> LIST .

    INT             reduce using rule 126 (u -> LIST .)
    CHAR            reduce using rule 126 (u -> LIST .)
    FLOAT           reduce using rule 126 (u -> LIST .)
    BOOL            reduce using rule 126 (u -> LIST .)


state 20

    (124) tipo -> u . y
    (127) y -> . INT
    (128) y -> . CHAR
    (129) y -> . FLOAT
    (130) y -> . BOOL

    INT             shift and go to state 28
    CHAR            shift and go to state 30
    FLOAT           shift and go to state 29
    BOOL            shift and go to state 32

    y                              shift and go to state 31

state 21

    (125) u -> empty .

    INT             reduce using rule 125 (u -> empty .)
    CHAR            reduce using rule 125 (u -> empty .)
    FLOAT           reduce using rule 125 (u -> empty .)
    BOOL            reduce using rule 125 (u -> empty .)


state 22

    (10) d -> c .

    CANCION         reduce using rule 10 (d -> c .)


state 23

    (8) c -> funcion d .

    CANCION         reduce using rule 8 (c -> funcion d .)


state 24

    (9) d -> empty .
    (7) c -> empty .

  ! reduce/reduce conflict for CANCION resolved using rule 7 (c -> empty .)
    CANCION         reduce using rule 7 (c -> empty .)

  ! CANCION         [ reduce using rule 9 (d -> empty .) ]


state 25

    (11) vars -> VAR v : . tipo ;
    (124) tipo -> . u y
    (125) u -> . empty
    (126) u -> . LIST
    (131) empty -> .

    LIST            shift and go to state 19
    INT             reduce using rule 131 (empty -> .)
    CHAR            reduce using rule 131 (empty -> .)
    FLOAT           reduce using rule 131 (empty -> .)
    BOOL            reduce using rule 131 (empty -> .)

    u                              shift and go to state 20
    empty                          shift and go to state 21
    tipo                           shift and go to state 33

state 26

    (29) cancion -> CANCION ( . CTEE ) metercancion f bloque

    CTEE            shift and go to state 34


state 27

    (13) funcion -> FUNC tipo ID . meterfuncion ( params ) f bloque
    (14) meterfuncion -> .

    (               reduce using rule 14 (meterfuncion -> .)

    meterfuncion                   shift and go to state 35

state 28

    (127) y -> INT .

    ID              reduce using rule 127 (y -> INT .)
    ;               reduce using rule 127 (y -> INT .)


state 29

    (129) y -> FLOAT .

    ID              reduce using rule 129 (y -> FLOAT .)
    ;               reduce using rule 129 (y -> FLOAT .)


state 30

    (128) y -> CHAR .

    ID              reduce using rule 128 (y -> CHAR .)
    ;               reduce using rule 128 (y -> CHAR .)


state 31

    (124) tipo -> u y .

    ID              reduce using rule 124 (tipo -> u y .)
    ;               reduce using rule 124 (tipo -> u y .)


state 32

    (130) y -> BOOL .

    ID              reduce using rule 130 (y -> BOOL .)
    ;               reduce using rule 130 (y -> BOOL .)


state 33

    (11) vars -> VAR v : tipo . ;

    ;               shift and go to state 36


state 34

    (29) cancion -> CANCION ( CTEE . ) metercancion f bloque

    )               shift and go to state 37


state 35

    (13) funcion -> FUNC tipo ID meterfuncion . ( params ) f bloque

    (               shift and go to state 38


state 36

    (11) vars -> VAR v : tipo ; .

    VAR             reduce using rule 11 (vars -> VAR v : tipo ; .)
    FUNC            reduce using rule 11 (vars -> VAR v : tipo ; .)
    CANCION         reduce using rule 11 (vars -> VAR v : tipo ; .)
    {               reduce using rule 11 (vars -> VAR v : tipo ; .)


state 37

    (29) cancion -> CANCION ( CTEE ) . metercancion f bloque
    (30) metercancion -> .

    VAR             reduce using rule 30 (metercancion -> .)
    {               reduce using rule 30 (metercancion -> .)

    metercancion                   shift and go to state 39

state 38

    (13) funcion -> FUNC tipo ID meterfuncion ( . params ) f bloque
    (19) params -> . empty
    (20) params -> . tipo ID meterparams h
    (131) empty -> .
    (124) tipo -> . u y
    (125) u -> . empty
    (126) u -> . LIST

    )               reduce using rule 131 (empty -> .)
    INT             reduce using rule 131 (empty -> .)
    CHAR            reduce using rule 131 (empty -> .)
    FLOAT           reduce using rule 131 (empty -> .)
    BOOL            reduce using rule 131 (empty -> .)
    LIST            shift and go to state 19

    tipo                           shift and go to state 40
    params                         shift and go to state 41
    u                              shift and go to state 20
    empty                          shift and go to state 42

state 39

    (29) cancion -> CANCION ( CTEE ) metercancion . f bloque
    (15) f -> . empty
    (16) f -> . vars g
    (131) empty -> .
    (11) vars -> . VAR v : tipo ;

    {               reduce using rule 131 (empty -> .)
    VAR             shift and go to state 5

    vars                           shift and go to state 43
    f                              shift and go to state 44
    empty                          shift and go to state 45

state 40

    (20) params -> tipo . ID meterparams h

    ID              shift and go to state 46


state 41

    (13) funcion -> FUNC tipo ID meterfuncion ( params . ) f bloque

    )               shift and go to state 47


state 42

    (19) params -> empty .
    (125) u -> empty .

    )               reduce using rule 19 (params -> empty .)
    INT             reduce using rule 125 (u -> empty .)
    CHAR            reduce using rule 125 (u -> empty .)
    FLOAT           reduce using rule 125 (u -> empty .)
    BOOL            reduce using rule 125 (u -> empty .)


state 43

    (16) f -> vars . g
    (17) g -> . empty
    (18) g -> . f
    (131) empty -> .
    (15) f -> . empty
    (16) f -> . vars g
    (11) vars -> . VAR v : tipo ;

    {               reduce using rule 131 (empty -> .)
    VAR             shift and go to state 5

    g                              shift and go to state 48
    f                              shift and go to state 49
    vars                           shift and go to state 43
    empty                          shift and go to state 50

state 44

    (29) cancion -> CANCION ( CTEE ) metercancion f . bloque
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 52

state 45

    (15) f -> empty .

    {               reduce using rule 15 (f -> empty .)


state 46

    (20) params -> tipo ID . meterparams h
    (21) meterparams -> .

    ,               reduce using rule 21 (meterparams -> .)
    )               reduce using rule 21 (meterparams -> .)

    meterparams                    shift and go to state 53

state 47

    (13) funcion -> FUNC tipo ID meterfuncion ( params ) . f bloque
    (15) f -> . empty
    (16) f -> . vars g
    (131) empty -> .
    (11) vars -> . VAR v : tipo ;

    {               reduce using rule 131 (empty -> .)
    VAR             shift and go to state 5

    vars                           shift and go to state 43
    f                              shift and go to state 54
    empty                          shift and go to state 45

state 48

    (16) f -> vars g .

    {               reduce using rule 16 (f -> vars g .)


state 49

    (18) g -> f .

    {               reduce using rule 18 (g -> f .)


state 50

    (17) g -> empty .
    (15) f -> empty .

  ! reduce/reduce conflict for { resolved using rule 15 (f -> empty .)
    {               reduce using rule 15 (f -> empty .)

  ! {               [ reduce using rule 17 (g -> empty .) ]


state 51

    (28) bloque -> { . i }
    (24) i -> . empty
    (25) i -> . estatuto j
    (131) empty -> .
    (31) estatuto -> . asignacion
    (32) estatuto -> . if
    (33) estatuto -> . for
    (34) estatuto -> . return
    (35) estatuto -> . while
    (36) estatuto -> . play
    (37) estatuto -> . print
    (38) asignacion -> . ID = neur8 k ;
    (43) if -> . IF ( expresion ) bloque l ;
    (46) for -> . FOR ( asignacion expresion asignacion ) bloque ;
    (123) return -> . RETURN ( expresion ) ;
    (115) while -> . WHILE ( expresion ) bloque ;
    (116) play -> . PLAY ( NOTA , CTEE ) ;
    (117) print -> . PRINT expresion ;

    }               reduce using rule 131 (empty -> .)
    ID              shift and go to state 67
    IF              shift and go to state 68
    FOR             shift and go to state 66
    RETURN          shift and go to state 55
    WHILE           shift and go to state 57
    PLAY            shift and go to state 56
    PRINT           shift and go to state 58

    play                           shift and go to state 64
    return                         shift and go to state 65
    for                            shift and go to state 60
    asignacion                     shift and go to state 69
    i                              shift and go to state 70
    estatuto                       shift and go to state 61
    while                          shift and go to state 71
    print                          shift and go to state 62
    empty                          shift and go to state 63
    if                             shift and go to state 59

state 52

    (29) cancion -> CANCION ( CTEE ) metercancion f bloque .

    $end            reduce using rule 29 (cancion -> CANCION ( CTEE ) metercancion f bloque .)


state 53

    (20) params -> tipo ID meterparams . h
    (22) h -> . empty
    (23) h -> . , params
    (131) empty -> .

    ,               shift and go to state 73
    )               reduce using rule 131 (empty -> .)

    h                              shift and go to state 72
    empty                          shift and go to state 74

state 54

    (13) funcion -> FUNC tipo ID meterfuncion ( params ) f . bloque
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 75

state 55

    (123) return -> RETURN . ( expresion ) ;

    (               shift and go to state 76


state 56

    (116) play -> PLAY . ( NOTA , CTEE ) ;

    (               shift and go to state 77


state 57

    (115) while -> WHILE . ( expresion ) bloque ;

    (               shift and go to state 78


state 58

    (117) print -> PRINT . expresion ;
    (47) expresion -> . m subexpresion
    (48) m -> . empty
    (49) m -> . NOT
    (131) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTEE            reduce using rule 131 (empty -> .)
    CTEF            reduce using rule 131 (empty -> .)
    CTEBOOL         reduce using rule 131 (empty -> .)
    CTECHAR         reduce using rule 131 (empty -> .)
    CALL            reduce using rule 131 (empty -> .)

    expresion                      shift and go to state 79
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 59

    (32) estatuto -> if .

    ID              reduce using rule 32 (estatuto -> if .)
    IF              reduce using rule 32 (estatuto -> if .)
    FOR             reduce using rule 32 (estatuto -> if .)
    RETURN          reduce using rule 32 (estatuto -> if .)
    WHILE           reduce using rule 32 (estatuto -> if .)
    PLAY            reduce using rule 32 (estatuto -> if .)
    PRINT           reduce using rule 32 (estatuto -> if .)
    }               reduce using rule 32 (estatuto -> if .)


state 60

    (33) estatuto -> for .

    ID              reduce using rule 33 (estatuto -> for .)
    IF              reduce using rule 33 (estatuto -> for .)
    FOR             reduce using rule 33 (estatuto -> for .)
    RETURN          reduce using rule 33 (estatuto -> for .)
    WHILE           reduce using rule 33 (estatuto -> for .)
    PLAY            reduce using rule 33 (estatuto -> for .)
    PRINT           reduce using rule 33 (estatuto -> for .)
    }               reduce using rule 33 (estatuto -> for .)


state 61

    (25) i -> estatuto . j
    (26) j -> . empty
    (27) j -> . i
    (131) empty -> .
    (24) i -> . empty
    (25) i -> . estatuto j
    (31) estatuto -> . asignacion
    (32) estatuto -> . if
    (33) estatuto -> . for
    (34) estatuto -> . return
    (35) estatuto -> . while
    (36) estatuto -> . play
    (37) estatuto -> . print
    (38) asignacion -> . ID = neur8 k ;
    (43) if -> . IF ( expresion ) bloque l ;
    (46) for -> . FOR ( asignacion expresion asignacion ) bloque ;
    (123) return -> . RETURN ( expresion ) ;
    (115) while -> . WHILE ( expresion ) bloque ;
    (116) play -> . PLAY ( NOTA , CTEE ) ;
    (117) print -> . PRINT expresion ;

    }               reduce using rule 131 (empty -> .)
    ID              shift and go to state 67
    IF              shift and go to state 68
    FOR             shift and go to state 66
    RETURN          shift and go to state 55
    WHILE           shift and go to state 57
    PLAY            shift and go to state 56
    PRINT           shift and go to state 58

    play                           shift and go to state 64
    j                              shift and go to state 85
    return                         shift and go to state 65
    for                            shift and go to state 60
    asignacion                     shift and go to state 69
    i                              shift and go to state 84
    estatuto                       shift and go to state 61
    while                          shift and go to state 71
    print                          shift and go to state 62
    empty                          shift and go to state 83
    if                             shift and go to state 59

state 62

    (37) estatuto -> print .

    ID              reduce using rule 37 (estatuto -> print .)
    IF              reduce using rule 37 (estatuto -> print .)
    FOR             reduce using rule 37 (estatuto -> print .)
    RETURN          reduce using rule 37 (estatuto -> print .)
    WHILE           reduce using rule 37 (estatuto -> print .)
    PLAY            reduce using rule 37 (estatuto -> print .)
    PRINT           reduce using rule 37 (estatuto -> print .)
    }               reduce using rule 37 (estatuto -> print .)


state 63

    (24) i -> empty .

    }               reduce using rule 24 (i -> empty .)


state 64

    (36) estatuto -> play .

    ID              reduce using rule 36 (estatuto -> play .)
    IF              reduce using rule 36 (estatuto -> play .)
    FOR             reduce using rule 36 (estatuto -> play .)
    RETURN          reduce using rule 36 (estatuto -> play .)
    WHILE           reduce using rule 36 (estatuto -> play .)
    PLAY            reduce using rule 36 (estatuto -> play .)
    PRINT           reduce using rule 36 (estatuto -> play .)
    }               reduce using rule 36 (estatuto -> play .)


state 65

    (34) estatuto -> return .

    ID              reduce using rule 34 (estatuto -> return .)
    IF              reduce using rule 34 (estatuto -> return .)
    FOR             reduce using rule 34 (estatuto -> return .)
    RETURN          reduce using rule 34 (estatuto -> return .)
    WHILE           reduce using rule 34 (estatuto -> return .)
    PLAY            reduce using rule 34 (estatuto -> return .)
    PRINT           reduce using rule 34 (estatuto -> return .)
    }               reduce using rule 34 (estatuto -> return .)


state 66

    (46) for -> FOR . ( asignacion expresion asignacion ) bloque ;

    (               shift and go to state 86


state 67

    (38) asignacion -> ID . = neur8 k ;

    =               shift and go to state 87


state 68

    (43) if -> IF . ( expresion ) bloque l ;

    (               shift and go to state 88


state 69

    (31) estatuto -> asignacion .

    ID              reduce using rule 31 (estatuto -> asignacion .)
    IF              reduce using rule 31 (estatuto -> asignacion .)
    FOR             reduce using rule 31 (estatuto -> asignacion .)
    RETURN          reduce using rule 31 (estatuto -> asignacion .)
    WHILE           reduce using rule 31 (estatuto -> asignacion .)
    PLAY            reduce using rule 31 (estatuto -> asignacion .)
    PRINT           reduce using rule 31 (estatuto -> asignacion .)
    }               reduce using rule 31 (estatuto -> asignacion .)


state 70

    (28) bloque -> { i . }

    }               shift and go to state 89


state 71

    (35) estatuto -> while .

    ID              reduce using rule 35 (estatuto -> while .)
    IF              reduce using rule 35 (estatuto -> while .)
    FOR             reduce using rule 35 (estatuto -> while .)
    RETURN          reduce using rule 35 (estatuto -> while .)
    WHILE           reduce using rule 35 (estatuto -> while .)
    PLAY            reduce using rule 35 (estatuto -> while .)
    PRINT           reduce using rule 35 (estatuto -> while .)
    }               reduce using rule 35 (estatuto -> while .)


state 72

    (20) params -> tipo ID meterparams h .

    )               reduce using rule 20 (params -> tipo ID meterparams h .)


state 73

    (23) h -> , . params
    (19) params -> . empty
    (20) params -> . tipo ID meterparams h
    (131) empty -> .
    (124) tipo -> . u y
    (125) u -> . empty
    (126) u -> . LIST

    )               reduce using rule 131 (empty -> .)
    INT             reduce using rule 131 (empty -> .)
    CHAR            reduce using rule 131 (empty -> .)
    FLOAT           reduce using rule 131 (empty -> .)
    BOOL            reduce using rule 131 (empty -> .)
    LIST            shift and go to state 19

    tipo                           shift and go to state 40
    u                              shift and go to state 20
    params                         shift and go to state 90
    empty                          shift and go to state 42

state 74

    (22) h -> empty .

    )               reduce using rule 22 (h -> empty .)


state 75

    (13) funcion -> FUNC tipo ID meterfuncion ( params ) f bloque .

    FUNC            reduce using rule 13 (funcion -> FUNC tipo ID meterfuncion ( params ) f bloque .)
    CANCION         reduce using rule 13 (funcion -> FUNC tipo ID meterfuncion ( params ) f bloque .)


state 76

    (123) return -> RETURN ( . expresion ) ;
    (47) expresion -> . m subexpresion
    (48) m -> . empty
    (49) m -> . NOT
    (131) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTEE            reduce using rule 131 (empty -> .)
    CTEF            reduce using rule 131 (empty -> .)
    CTEBOOL         reduce using rule 131 (empty -> .)
    CTECHAR         reduce using rule 131 (empty -> .)
    CALL            reduce using rule 131 (empty -> .)

    expresion                      shift and go to state 91
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 77

    (116) play -> PLAY ( . NOTA , CTEE ) ;

    NOTA            shift and go to state 92


state 78

    (115) while -> WHILE ( . expresion ) bloque ;
    (47) expresion -> . m subexpresion
    (48) m -> . empty
    (49) m -> . NOT
    (131) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTEE            reduce using rule 131 (empty -> .)
    CTEF            reduce using rule 131 (empty -> .)
    CTEBOOL         reduce using rule 131 (empty -> .)
    CTECHAR         reduce using rule 131 (empty -> .)
    CALL            reduce using rule 131 (empty -> .)

    expresion                      shift and go to state 93
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 79

    (117) print -> PRINT expresion . ;

    ;               shift and go to state 94


state 80

    (47) expresion -> m . subexpresion
    (50) subexpresion -> . exp neur10 o
    (57) exp -> . nexp neur12 p
    (72) nexp -> . termino neur5 q
    (79) termino -> . factor neur4 n
    (86) factor -> . ( neur6 expresion ) neur7
    (87) factor -> . varcte neur1
    (91) varcte -> . ID r neurVar
    (92) varcte -> . CTEE neurCteE
    (93) varcte -> . CTEF neurCteF
    (94) varcte -> . CTEBOOL neurCteB
    (95) varcte -> . callfunc
    (96) varcte -> . CTECHAR neurCteCh
    (118) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    termino                        shift and go to state 95
    varcte                         shift and go to state 97
    nexp                           shift and go to state 99
    factor                         shift and go to state 100
    subexpresion                   shift and go to state 102
    callfunc                       shift and go to state 105
    exp                            shift and go to state 107

state 81

    (49) m -> NOT .

    (               reduce using rule 49 (m -> NOT .)
    ID              reduce using rule 49 (m -> NOT .)
    CTEE            reduce using rule 49 (m -> NOT .)
    CTEF            reduce using rule 49 (m -> NOT .)
    CTEBOOL         reduce using rule 49 (m -> NOT .)
    CTECHAR         reduce using rule 49 (m -> NOT .)
    CALL            reduce using rule 49 (m -> NOT .)


state 82

    (48) m -> empty .

    (               reduce using rule 48 (m -> empty .)
    ID              reduce using rule 48 (m -> empty .)
    CTEE            reduce using rule 48 (m -> empty .)
    CTEF            reduce using rule 48 (m -> empty .)
    CTEBOOL         reduce using rule 48 (m -> empty .)
    CTECHAR         reduce using rule 48 (m -> empty .)
    CALL            reduce using rule 48 (m -> empty .)


state 83

    (26) j -> empty .
    (24) i -> empty .

  ! reduce/reduce conflict for } resolved using rule 24 (i -> empty .)
    }               reduce using rule 24 (i -> empty .)

  ! }               [ reduce using rule 26 (j -> empty .) ]


state 84

    (27) j -> i .

    }               reduce using rule 27 (j -> i .)


state 85

    (25) i -> estatuto j .

    }               reduce using rule 25 (i -> estatuto j .)


state 86

    (46) for -> FOR ( . asignacion expresion asignacion ) bloque ;
    (38) asignacion -> . ID = neur8 k ;

    ID              shift and go to state 67

    asignacion                     shift and go to state 109

state 87

    (38) asignacion -> ID = . neur8 k ;
    (39) neur8 -> .

    NEW             reduce using rule 39 (neur8 -> .)
    NOT             reduce using rule 39 (neur8 -> .)
    (               reduce using rule 39 (neur8 -> .)
    ID              reduce using rule 39 (neur8 -> .)
    CTEE            reduce using rule 39 (neur8 -> .)
    CTEF            reduce using rule 39 (neur8 -> .)
    CTEBOOL         reduce using rule 39 (neur8 -> .)
    CTECHAR         reduce using rule 39 (neur8 -> .)
    CALL            reduce using rule 39 (neur8 -> .)

    neur8                          shift and go to state 110

state 88

    (43) if -> IF ( . expresion ) bloque l ;
    (47) expresion -> . m subexpresion
    (48) m -> . empty
    (49) m -> . NOT
    (131) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTEE            reduce using rule 131 (empty -> .)
    CTEF            reduce using rule 131 (empty -> .)
    CTEBOOL         reduce using rule 131 (empty -> .)
    CTECHAR         reduce using rule 131 (empty -> .)
    CALL            reduce using rule 131 (empty -> .)

    expresion                      shift and go to state 111
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 89

    (28) bloque -> { i } .

    $end            reduce using rule 28 (bloque -> { i } .)
    ;               reduce using rule 28 (bloque -> { i } .)
    ELSE            reduce using rule 28 (bloque -> { i } .)
    FUNC            reduce using rule 28 (bloque -> { i } .)
    CANCION         reduce using rule 28 (bloque -> { i } .)


state 90

    (23) h -> , params .

    )               reduce using rule 23 (h -> , params .)


state 91

    (123) return -> RETURN ( expresion . ) ;

    )               shift and go to state 112


state 92

    (116) play -> PLAY ( NOTA . , CTEE ) ;

    ,               shift and go to state 113


state 93

    (115) while -> WHILE ( expresion . ) bloque ;

    )               shift and go to state 114


state 94

    (117) print -> PRINT expresion ; .

    ID              reduce using rule 117 (print -> PRINT expresion ; .)
    IF              reduce using rule 117 (print -> PRINT expresion ; .)
    FOR             reduce using rule 117 (print -> PRINT expresion ; .)
    RETURN          reduce using rule 117 (print -> PRINT expresion ; .)
    WHILE           reduce using rule 117 (print -> PRINT expresion ; .)
    PLAY            reduce using rule 117 (print -> PRINT expresion ; .)
    PRINT           reduce using rule 117 (print -> PRINT expresion ; .)
    }               reduce using rule 117 (print -> PRINT expresion ; .)


state 95

    (72) nexp -> termino . neur5 q
    (73) neur5 -> .

    +               reduce using rule 73 (neur5 -> .)
    -               reduce using rule 73 (neur5 -> .)
    EQ              reduce using rule 73 (neur5 -> .)
    NOTEQ           reduce using rule 73 (neur5 -> .)
    >               reduce using rule 73 (neur5 -> .)
    <               reduce using rule 73 (neur5 -> .)
    MTHANEQ         reduce using rule 73 (neur5 -> .)
    LTHANEQ         reduce using rule 73 (neur5 -> .)
    AND             reduce using rule 73 (neur5 -> .)
    OR              reduce using rule 73 (neur5 -> .)
    ;               reduce using rule 73 (neur5 -> .)
    )               reduce using rule 73 (neur5 -> .)
    ID              reduce using rule 73 (neur5 -> .)
    ,               reduce using rule 73 (neur5 -> .)

    neur5                          shift and go to state 115

state 96

    (96) varcte -> CTECHAR . neurCteCh
    (101) neurCteCh -> .

    *               reduce using rule 101 (neurCteCh -> .)
    /               reduce using rule 101 (neurCteCh -> .)
    +               reduce using rule 101 (neurCteCh -> .)
    -               reduce using rule 101 (neurCteCh -> .)
    EQ              reduce using rule 101 (neurCteCh -> .)
    NOTEQ           reduce using rule 101 (neurCteCh -> .)
    >               reduce using rule 101 (neurCteCh -> .)
    <               reduce using rule 101 (neurCteCh -> .)
    MTHANEQ         reduce using rule 101 (neurCteCh -> .)
    LTHANEQ         reduce using rule 101 (neurCteCh -> .)
    AND             reduce using rule 101 (neurCteCh -> .)
    OR              reduce using rule 101 (neurCteCh -> .)
    ;               reduce using rule 101 (neurCteCh -> .)
    )               reduce using rule 101 (neurCteCh -> .)
    ID              reduce using rule 101 (neurCteCh -> .)
    ,               reduce using rule 101 (neurCteCh -> .)

    neurCteCh                      shift and go to state 116

state 97

    (87) factor -> varcte . neur1
    (90) neur1 -> .

    *               reduce using rule 90 (neur1 -> .)
    /               reduce using rule 90 (neur1 -> .)
    +               reduce using rule 90 (neur1 -> .)
    -               reduce using rule 90 (neur1 -> .)
    EQ              reduce using rule 90 (neur1 -> .)
    NOTEQ           reduce using rule 90 (neur1 -> .)
    >               reduce using rule 90 (neur1 -> .)
    <               reduce using rule 90 (neur1 -> .)
    MTHANEQ         reduce using rule 90 (neur1 -> .)
    LTHANEQ         reduce using rule 90 (neur1 -> .)
    AND             reduce using rule 90 (neur1 -> .)
    OR              reduce using rule 90 (neur1 -> .)
    ;               reduce using rule 90 (neur1 -> .)
    )               reduce using rule 90 (neur1 -> .)
    ID              reduce using rule 90 (neur1 -> .)
    ,               reduce using rule 90 (neur1 -> .)

    neur1                          shift and go to state 117

state 98

    (86) factor -> ( . neur6 expresion ) neur7
    (88) neur6 -> .

    NOT             reduce using rule 88 (neur6 -> .)
    (               reduce using rule 88 (neur6 -> .)
    ID              reduce using rule 88 (neur6 -> .)
    CTEE            reduce using rule 88 (neur6 -> .)
    CTEF            reduce using rule 88 (neur6 -> .)
    CTEBOOL         reduce using rule 88 (neur6 -> .)
    CTECHAR         reduce using rule 88 (neur6 -> .)
    CALL            reduce using rule 88 (neur6 -> .)

    neur6                          shift and go to state 118

state 99

    (57) exp -> nexp . neur12 p
    (58) neur12 -> .

    EQ              reduce using rule 58 (neur12 -> .)
    NOTEQ           reduce using rule 58 (neur12 -> .)
    >               reduce using rule 58 (neur12 -> .)
    <               reduce using rule 58 (neur12 -> .)
    MTHANEQ         reduce using rule 58 (neur12 -> .)
    LTHANEQ         reduce using rule 58 (neur12 -> .)
    AND             reduce using rule 58 (neur12 -> .)
    OR              reduce using rule 58 (neur12 -> .)
    ;               reduce using rule 58 (neur12 -> .)
    )               reduce using rule 58 (neur12 -> .)
    ID              reduce using rule 58 (neur12 -> .)
    ,               reduce using rule 58 (neur12 -> .)

    neur12                         shift and go to state 119

state 100

    (79) termino -> factor . neur4 n
    (80) neur4 -> .

    *               reduce using rule 80 (neur4 -> .)
    /               reduce using rule 80 (neur4 -> .)
    +               reduce using rule 80 (neur4 -> .)
    -               reduce using rule 80 (neur4 -> .)
    EQ              reduce using rule 80 (neur4 -> .)
    NOTEQ           reduce using rule 80 (neur4 -> .)
    >               reduce using rule 80 (neur4 -> .)
    <               reduce using rule 80 (neur4 -> .)
    MTHANEQ         reduce using rule 80 (neur4 -> .)
    LTHANEQ         reduce using rule 80 (neur4 -> .)
    AND             reduce using rule 80 (neur4 -> .)
    OR              reduce using rule 80 (neur4 -> .)
    ;               reduce using rule 80 (neur4 -> .)
    )               reduce using rule 80 (neur4 -> .)
    ID              reduce using rule 80 (neur4 -> .)
    ,               reduce using rule 80 (neur4 -> .)

    neur4                          shift and go to state 120

state 101

    (118) callfunc -> CALL . ID ( s ) ;

    ID              shift and go to state 121


state 102

    (47) expresion -> m subexpresion .

    ,               reduce using rule 47 (expresion -> m subexpresion .)
    )               reduce using rule 47 (expresion -> m subexpresion .)
    ID              reduce using rule 47 (expresion -> m subexpresion .)
    ;               reduce using rule 47 (expresion -> m subexpresion .)


state 103

    (91) varcte -> ID . r neurVar
    (102) r -> . empty
    (103) r -> . oplista
    (131) empty -> .
    (104) oplista -> . ID . x

  ! shift/reduce conflict for ID resolved as shift
    *               reduce using rule 131 (empty -> .)
    /               reduce using rule 131 (empty -> .)
    +               reduce using rule 131 (empty -> .)
    -               reduce using rule 131 (empty -> .)
    EQ              reduce using rule 131 (empty -> .)
    NOTEQ           reduce using rule 131 (empty -> .)
    >               reduce using rule 131 (empty -> .)
    <               reduce using rule 131 (empty -> .)
    MTHANEQ         reduce using rule 131 (empty -> .)
    LTHANEQ         reduce using rule 131 (empty -> .)
    AND             reduce using rule 131 (empty -> .)
    OR              reduce using rule 131 (empty -> .)
    ;               reduce using rule 131 (empty -> .)
    )               reduce using rule 131 (empty -> .)
    ,               reduce using rule 131 (empty -> .)
    ID              shift and go to state 124

  ! ID              [ reduce using rule 131 (empty -> .) ]

    oplista                        shift and go to state 122
    r                              shift and go to state 123
    empty                          shift and go to state 125

state 104

    (94) varcte -> CTEBOOL . neurCteB
    (100) neurCteB -> .

    *               reduce using rule 100 (neurCteB -> .)
    /               reduce using rule 100 (neurCteB -> .)
    +               reduce using rule 100 (neurCteB -> .)
    -               reduce using rule 100 (neurCteB -> .)
    EQ              reduce using rule 100 (neurCteB -> .)
    NOTEQ           reduce using rule 100 (neurCteB -> .)
    >               reduce using rule 100 (neurCteB -> .)
    <               reduce using rule 100 (neurCteB -> .)
    MTHANEQ         reduce using rule 100 (neurCteB -> .)
    LTHANEQ         reduce using rule 100 (neurCteB -> .)
    AND             reduce using rule 100 (neurCteB -> .)
    OR              reduce using rule 100 (neurCteB -> .)
    ;               reduce using rule 100 (neurCteB -> .)
    )               reduce using rule 100 (neurCteB -> .)
    ID              reduce using rule 100 (neurCteB -> .)
    ,               reduce using rule 100 (neurCteB -> .)

    neurCteB                       shift and go to state 126

state 105

    (95) varcte -> callfunc .

    *               reduce using rule 95 (varcte -> callfunc .)
    /               reduce using rule 95 (varcte -> callfunc .)
    +               reduce using rule 95 (varcte -> callfunc .)
    -               reduce using rule 95 (varcte -> callfunc .)
    AND             reduce using rule 95 (varcte -> callfunc .)
    OR              reduce using rule 95 (varcte -> callfunc .)
    ;               reduce using rule 95 (varcte -> callfunc .)
    )               reduce using rule 95 (varcte -> callfunc .)
    ID              reduce using rule 95 (varcte -> callfunc .)
    ,               reduce using rule 95 (varcte -> callfunc .)
    EQ              reduce using rule 95 (varcte -> callfunc .)
    NOTEQ           reduce using rule 95 (varcte -> callfunc .)
    >               reduce using rule 95 (varcte -> callfunc .)
    <               reduce using rule 95 (varcte -> callfunc .)
    MTHANEQ         reduce using rule 95 (varcte -> callfunc .)
    LTHANEQ         reduce using rule 95 (varcte -> callfunc .)


state 106

    (93) varcte -> CTEF . neurCteF
    (99) neurCteF -> .

    *               reduce using rule 99 (neurCteF -> .)
    /               reduce using rule 99 (neurCteF -> .)
    +               reduce using rule 99 (neurCteF -> .)
    -               reduce using rule 99 (neurCteF -> .)
    EQ              reduce using rule 99 (neurCteF -> .)
    NOTEQ           reduce using rule 99 (neurCteF -> .)
    >               reduce using rule 99 (neurCteF -> .)
    <               reduce using rule 99 (neurCteF -> .)
    MTHANEQ         reduce using rule 99 (neurCteF -> .)
    LTHANEQ         reduce using rule 99 (neurCteF -> .)
    AND             reduce using rule 99 (neurCteF -> .)
    OR              reduce using rule 99 (neurCteF -> .)
    ;               reduce using rule 99 (neurCteF -> .)
    )               reduce using rule 99 (neurCteF -> .)
    ID              reduce using rule 99 (neurCteF -> .)
    ,               reduce using rule 99 (neurCteF -> .)

    neurCteF                       shift and go to state 127

state 107

    (50) subexpresion -> exp . neur10 o
    (51) neur10 -> .

    AND             reduce using rule 51 (neur10 -> .)
    OR              reduce using rule 51 (neur10 -> .)
    ;               reduce using rule 51 (neur10 -> .)
    )               reduce using rule 51 (neur10 -> .)
    ID              reduce using rule 51 (neur10 -> .)
    ,               reduce using rule 51 (neur10 -> .)

    neur10                         shift and go to state 128

state 108

    (92) varcte -> CTEE . neurCteE
    (98) neurCteE -> .

    *               reduce using rule 98 (neurCteE -> .)
    /               reduce using rule 98 (neurCteE -> .)
    +               reduce using rule 98 (neurCteE -> .)
    -               reduce using rule 98 (neurCteE -> .)
    EQ              reduce using rule 98 (neurCteE -> .)
    NOTEQ           reduce using rule 98 (neurCteE -> .)
    >               reduce using rule 98 (neurCteE -> .)
    <               reduce using rule 98 (neurCteE -> .)
    MTHANEQ         reduce using rule 98 (neurCteE -> .)
    LTHANEQ         reduce using rule 98 (neurCteE -> .)
    AND             reduce using rule 98 (neurCteE -> .)
    OR              reduce using rule 98 (neurCteE -> .)
    ;               reduce using rule 98 (neurCteE -> .)
    )               reduce using rule 98 (neurCteE -> .)
    ID              reduce using rule 98 (neurCteE -> .)
    ,               reduce using rule 98 (neurCteE -> .)

    neurCteE                       shift and go to state 129

state 109

    (46) for -> FOR ( asignacion . expresion asignacion ) bloque ;
    (47) expresion -> . m subexpresion
    (48) m -> . empty
    (49) m -> . NOT
    (131) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTEE            reduce using rule 131 (empty -> .)
    CTEF            reduce using rule 131 (empty -> .)
    CTEBOOL         reduce using rule 131 (empty -> .)
    CTECHAR         reduce using rule 131 (empty -> .)
    CALL            reduce using rule 131 (empty -> .)

    expresion                      shift and go to state 130
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 110

    (38) asignacion -> ID = neur8 . k ;
    (40) k -> . expresion
    (41) k -> . asiglista
    (47) expresion -> . m subexpresion
    (42) asiglista -> . NEW LIST ( )
    (48) m -> . empty
    (49) m -> . NOT
    (131) empty -> .

    NEW             shift and go to state 134
    NOT             shift and go to state 81
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTEE            reduce using rule 131 (empty -> .)
    CTEF            reduce using rule 131 (empty -> .)
    CTEBOOL         reduce using rule 131 (empty -> .)
    CTECHAR         reduce using rule 131 (empty -> .)
    CALL            reduce using rule 131 (empty -> .)

    expresion                      shift and go to state 131
    k                              shift and go to state 132
    m                              shift and go to state 80
    asiglista                      shift and go to state 133
    empty                          shift and go to state 82

state 111

    (43) if -> IF ( expresion . ) bloque l ;

    )               shift and go to state 135


state 112

    (123) return -> RETURN ( expresion ) . ;

    ;               shift and go to state 136


state 113

    (116) play -> PLAY ( NOTA , . CTEE ) ;

    CTEE            shift and go to state 137


state 114

    (115) while -> WHILE ( expresion ) . bloque ;
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 138

state 115

    (72) nexp -> termino neur5 . q
    (74) q -> . empty
    (75) q -> . + neur3_1 nexp
    (76) q -> . - neur3_2 nexp
    (131) empty -> .

    +               shift and go to state 139
    -               shift and go to state 140
    EQ              reduce using rule 131 (empty -> .)
    NOTEQ           reduce using rule 131 (empty -> .)
    >               reduce using rule 131 (empty -> .)
    <               reduce using rule 131 (empty -> .)
    MTHANEQ         reduce using rule 131 (empty -> .)
    LTHANEQ         reduce using rule 131 (empty -> .)
    AND             reduce using rule 131 (empty -> .)
    OR              reduce using rule 131 (empty -> .)
    ;               reduce using rule 131 (empty -> .)
    )               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    ,               reduce using rule 131 (empty -> .)

    q                              shift and go to state 141
    empty                          shift and go to state 142

state 116

    (96) varcte -> CTECHAR neurCteCh .

    *               reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    /               reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    +               reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    -               reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    AND             reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    OR              reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    ;               reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    )               reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    ID              reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    ,               reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    EQ              reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    NOTEQ           reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    >               reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    <               reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    MTHANEQ         reduce using rule 96 (varcte -> CTECHAR neurCteCh .)
    LTHANEQ         reduce using rule 96 (varcte -> CTECHAR neurCteCh .)


state 117

    (87) factor -> varcte neur1 .

    *               reduce using rule 87 (factor -> varcte neur1 .)
    /               reduce using rule 87 (factor -> varcte neur1 .)
    +               reduce using rule 87 (factor -> varcte neur1 .)
    -               reduce using rule 87 (factor -> varcte neur1 .)
    EQ              reduce using rule 87 (factor -> varcte neur1 .)
    NOTEQ           reduce using rule 87 (factor -> varcte neur1 .)
    >               reduce using rule 87 (factor -> varcte neur1 .)
    <               reduce using rule 87 (factor -> varcte neur1 .)
    MTHANEQ         reduce using rule 87 (factor -> varcte neur1 .)
    LTHANEQ         reduce using rule 87 (factor -> varcte neur1 .)
    AND             reduce using rule 87 (factor -> varcte neur1 .)
    OR              reduce using rule 87 (factor -> varcte neur1 .)
    ;               reduce using rule 87 (factor -> varcte neur1 .)
    )               reduce using rule 87 (factor -> varcte neur1 .)
    ID              reduce using rule 87 (factor -> varcte neur1 .)
    ,               reduce using rule 87 (factor -> varcte neur1 .)


state 118

    (86) factor -> ( neur6 . expresion ) neur7
    (47) expresion -> . m subexpresion
    (48) m -> . empty
    (49) m -> . NOT
    (131) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTEE            reduce using rule 131 (empty -> .)
    CTEF            reduce using rule 131 (empty -> .)
    CTEBOOL         reduce using rule 131 (empty -> .)
    CTECHAR         reduce using rule 131 (empty -> .)
    CALL            reduce using rule 131 (empty -> .)

    expresion                      shift and go to state 143
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 119

    (57) exp -> nexp neur12 . p
    (59) p -> . empty
    (60) p -> . EQ neur11_1 nexp
    (61) p -> . NOTEQ neur11_2 nexp
    (62) p -> . > neur11_3 nexp
    (63) p -> . < neur11_4 nexp
    (64) p -> . MTHANEQ neur11_5 nexp
    (65) p -> . LTHANEQ neur11_6 nexp
    (131) empty -> .

    EQ              shift and go to state 148
    NOTEQ           shift and go to state 147
    >               shift and go to state 151
    <               shift and go to state 149
    MTHANEQ         shift and go to state 144
    LTHANEQ         shift and go to state 146
    AND             reduce using rule 131 (empty -> .)
    OR              reduce using rule 131 (empty -> .)
    ;               reduce using rule 131 (empty -> .)
    )               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    ,               reduce using rule 131 (empty -> .)

    p                              shift and go to state 145
    empty                          shift and go to state 150

state 120

    (79) termino -> factor neur4 . n
    (81) n -> . empty
    (82) n -> . * neur2_1 termino
    (83) n -> . / neur2_2 termino
    (131) empty -> .

    *               shift and go to state 152
    /               shift and go to state 153
    +               reduce using rule 131 (empty -> .)
    -               reduce using rule 131 (empty -> .)
    EQ              reduce using rule 131 (empty -> .)
    NOTEQ           reduce using rule 131 (empty -> .)
    >               reduce using rule 131 (empty -> .)
    <               reduce using rule 131 (empty -> .)
    MTHANEQ         reduce using rule 131 (empty -> .)
    LTHANEQ         reduce using rule 131 (empty -> .)
    AND             reduce using rule 131 (empty -> .)
    OR              reduce using rule 131 (empty -> .)
    ;               reduce using rule 131 (empty -> .)
    )               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    ,               reduce using rule 131 (empty -> .)

    n                              shift and go to state 154
    empty                          shift and go to state 155

state 121

    (118) callfunc -> CALL ID . ( s ) ;

    (               shift and go to state 156


state 122

    (103) r -> oplista .

    *               reduce using rule 103 (r -> oplista .)
    /               reduce using rule 103 (r -> oplista .)
    +               reduce using rule 103 (r -> oplista .)
    -               reduce using rule 103 (r -> oplista .)
    EQ              reduce using rule 103 (r -> oplista .)
    NOTEQ           reduce using rule 103 (r -> oplista .)
    >               reduce using rule 103 (r -> oplista .)
    <               reduce using rule 103 (r -> oplista .)
    MTHANEQ         reduce using rule 103 (r -> oplista .)
    LTHANEQ         reduce using rule 103 (r -> oplista .)
    AND             reduce using rule 103 (r -> oplista .)
    OR              reduce using rule 103 (r -> oplista .)
    ;               reduce using rule 103 (r -> oplista .)
    )               reduce using rule 103 (r -> oplista .)
    ID              reduce using rule 103 (r -> oplista .)
    ,               reduce using rule 103 (r -> oplista .)


state 123

    (91) varcte -> ID r . neurVar
    (97) neurVar -> .

    *               reduce using rule 97 (neurVar -> .)
    /               reduce using rule 97 (neurVar -> .)
    +               reduce using rule 97 (neurVar -> .)
    -               reduce using rule 97 (neurVar -> .)
    EQ              reduce using rule 97 (neurVar -> .)
    NOTEQ           reduce using rule 97 (neurVar -> .)
    >               reduce using rule 97 (neurVar -> .)
    <               reduce using rule 97 (neurVar -> .)
    MTHANEQ         reduce using rule 97 (neurVar -> .)
    LTHANEQ         reduce using rule 97 (neurVar -> .)
    AND             reduce using rule 97 (neurVar -> .)
    OR              reduce using rule 97 (neurVar -> .)
    ;               reduce using rule 97 (neurVar -> .)
    )               reduce using rule 97 (neurVar -> .)
    ID              reduce using rule 97 (neurVar -> .)
    ,               reduce using rule 97 (neurVar -> .)

    neurVar                        shift and go to state 157

state 124

    (104) oplista -> ID . . x

    .               shift and go to state 158


state 125

    (102) r -> empty .

    *               reduce using rule 102 (r -> empty .)
    /               reduce using rule 102 (r -> empty .)
    +               reduce using rule 102 (r -> empty .)
    -               reduce using rule 102 (r -> empty .)
    EQ              reduce using rule 102 (r -> empty .)
    NOTEQ           reduce using rule 102 (r -> empty .)
    >               reduce using rule 102 (r -> empty .)
    <               reduce using rule 102 (r -> empty .)
    MTHANEQ         reduce using rule 102 (r -> empty .)
    LTHANEQ         reduce using rule 102 (r -> empty .)
    AND             reduce using rule 102 (r -> empty .)
    OR              reduce using rule 102 (r -> empty .)
    ;               reduce using rule 102 (r -> empty .)
    )               reduce using rule 102 (r -> empty .)
    ID              reduce using rule 102 (r -> empty .)
    ,               reduce using rule 102 (r -> empty .)


state 126

    (94) varcte -> CTEBOOL neurCteB .

    *               reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    /               reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    +               reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    -               reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    AND             reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    OR              reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    ;               reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    )               reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    ID              reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    ,               reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    EQ              reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    NOTEQ           reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    >               reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    <               reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    MTHANEQ         reduce using rule 94 (varcte -> CTEBOOL neurCteB .)
    LTHANEQ         reduce using rule 94 (varcte -> CTEBOOL neurCteB .)


state 127

    (93) varcte -> CTEF neurCteF .

    *               reduce using rule 93 (varcte -> CTEF neurCteF .)
    /               reduce using rule 93 (varcte -> CTEF neurCteF .)
    +               reduce using rule 93 (varcte -> CTEF neurCteF .)
    -               reduce using rule 93 (varcte -> CTEF neurCteF .)
    AND             reduce using rule 93 (varcte -> CTEF neurCteF .)
    OR              reduce using rule 93 (varcte -> CTEF neurCteF .)
    ;               reduce using rule 93 (varcte -> CTEF neurCteF .)
    )               reduce using rule 93 (varcte -> CTEF neurCteF .)
    ID              reduce using rule 93 (varcte -> CTEF neurCteF .)
    ,               reduce using rule 93 (varcte -> CTEF neurCteF .)
    EQ              reduce using rule 93 (varcte -> CTEF neurCteF .)
    NOTEQ           reduce using rule 93 (varcte -> CTEF neurCteF .)
    >               reduce using rule 93 (varcte -> CTEF neurCteF .)
    <               reduce using rule 93 (varcte -> CTEF neurCteF .)
    MTHANEQ         reduce using rule 93 (varcte -> CTEF neurCteF .)
    LTHANEQ         reduce using rule 93 (varcte -> CTEF neurCteF .)


state 128

    (50) subexpresion -> exp neur10 . o
    (52) o -> . empty
    (53) o -> . AND neur9_1 subexpresion
    (54) o -> . OR neur9_2 subexpresion
    (131) empty -> .

    AND             shift and go to state 159
    OR              shift and go to state 161
    ;               reduce using rule 131 (empty -> .)
    )               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    ,               reduce using rule 131 (empty -> .)

    o                              shift and go to state 160
    empty                          shift and go to state 162

state 129

    (92) varcte -> CTEE neurCteE .

    *               reduce using rule 92 (varcte -> CTEE neurCteE .)
    /               reduce using rule 92 (varcte -> CTEE neurCteE .)
    +               reduce using rule 92 (varcte -> CTEE neurCteE .)
    -               reduce using rule 92 (varcte -> CTEE neurCteE .)
    AND             reduce using rule 92 (varcte -> CTEE neurCteE .)
    OR              reduce using rule 92 (varcte -> CTEE neurCteE .)
    ;               reduce using rule 92 (varcte -> CTEE neurCteE .)
    )               reduce using rule 92 (varcte -> CTEE neurCteE .)
    ID              reduce using rule 92 (varcte -> CTEE neurCteE .)
    ,               reduce using rule 92 (varcte -> CTEE neurCteE .)
    EQ              reduce using rule 92 (varcte -> CTEE neurCteE .)
    NOTEQ           reduce using rule 92 (varcte -> CTEE neurCteE .)
    >               reduce using rule 92 (varcte -> CTEE neurCteE .)
    <               reduce using rule 92 (varcte -> CTEE neurCteE .)
    MTHANEQ         reduce using rule 92 (varcte -> CTEE neurCteE .)
    LTHANEQ         reduce using rule 92 (varcte -> CTEE neurCteE .)


state 130

    (46) for -> FOR ( asignacion expresion . asignacion ) bloque ;
    (38) asignacion -> . ID = neur8 k ;

    ID              shift and go to state 67

    asignacion                     shift and go to state 163

state 131

    (40) k -> expresion .

    ;               reduce using rule 40 (k -> expresion .)


state 132

    (38) asignacion -> ID = neur8 k . ;

    ;               shift and go to state 164


state 133

    (41) k -> asiglista .

    ;               reduce using rule 41 (k -> asiglista .)


state 134

    (42) asiglista -> NEW . LIST ( )

    LIST            shift and go to state 165


state 135

    (43) if -> IF ( expresion ) . bloque l ;
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 166

state 136

    (123) return -> RETURN ( expresion ) ; .

    ID              reduce using rule 123 (return -> RETURN ( expresion ) ; .)
    IF              reduce using rule 123 (return -> RETURN ( expresion ) ; .)
    FOR             reduce using rule 123 (return -> RETURN ( expresion ) ; .)
    RETURN          reduce using rule 123 (return -> RETURN ( expresion ) ; .)
    WHILE           reduce using rule 123 (return -> RETURN ( expresion ) ; .)
    PLAY            reduce using rule 123 (return -> RETURN ( expresion ) ; .)
    PRINT           reduce using rule 123 (return -> RETURN ( expresion ) ; .)
    }               reduce using rule 123 (return -> RETURN ( expresion ) ; .)


state 137

    (116) play -> PLAY ( NOTA , CTEE . ) ;

    )               shift and go to state 167


state 138

    (115) while -> WHILE ( expresion ) bloque . ;

    ;               shift and go to state 168


state 139

    (75) q -> + . neur3_1 nexp
    (77) neur3_1 -> .

    (               reduce using rule 77 (neur3_1 -> .)
    ID              reduce using rule 77 (neur3_1 -> .)
    CTEE            reduce using rule 77 (neur3_1 -> .)
    CTEF            reduce using rule 77 (neur3_1 -> .)
    CTEBOOL         reduce using rule 77 (neur3_1 -> .)
    CTECHAR         reduce using rule 77 (neur3_1 -> .)
    CALL            reduce using rule 77 (neur3_1 -> .)

    neur3_1                        shift and go to state 169

state 140

    (76) q -> - . neur3_2 nexp
    (78) neur3_2 -> .

    (               reduce using rule 78 (neur3_2 -> .)
    ID              reduce using rule 78 (neur3_2 -> .)
    CTEE            reduce using rule 78 (neur3_2 -> .)
    CTEF            reduce using rule 78 (neur3_2 -> .)
    CTEBOOL         reduce using rule 78 (neur3_2 -> .)
    CTECHAR         reduce using rule 78 (neur3_2 -> .)
    CALL            reduce using rule 78 (neur3_2 -> .)

    neur3_2                        shift and go to state 170

state 141

    (72) nexp -> termino neur5 q .

    EQ              reduce using rule 72 (nexp -> termino neur5 q .)
    NOTEQ           reduce using rule 72 (nexp -> termino neur5 q .)
    >               reduce using rule 72 (nexp -> termino neur5 q .)
    <               reduce using rule 72 (nexp -> termino neur5 q .)
    MTHANEQ         reduce using rule 72 (nexp -> termino neur5 q .)
    LTHANEQ         reduce using rule 72 (nexp -> termino neur5 q .)
    AND             reduce using rule 72 (nexp -> termino neur5 q .)
    OR              reduce using rule 72 (nexp -> termino neur5 q .)
    ;               reduce using rule 72 (nexp -> termino neur5 q .)
    )               reduce using rule 72 (nexp -> termino neur5 q .)
    ID              reduce using rule 72 (nexp -> termino neur5 q .)
    ,               reduce using rule 72 (nexp -> termino neur5 q .)


state 142

    (74) q -> empty .

    EQ              reduce using rule 74 (q -> empty .)
    NOTEQ           reduce using rule 74 (q -> empty .)
    >               reduce using rule 74 (q -> empty .)
    <               reduce using rule 74 (q -> empty .)
    MTHANEQ         reduce using rule 74 (q -> empty .)
    LTHANEQ         reduce using rule 74 (q -> empty .)
    AND             reduce using rule 74 (q -> empty .)
    OR              reduce using rule 74 (q -> empty .)
    ;               reduce using rule 74 (q -> empty .)
    )               reduce using rule 74 (q -> empty .)
    ID              reduce using rule 74 (q -> empty .)
    ,               reduce using rule 74 (q -> empty .)


state 143

    (86) factor -> ( neur6 expresion . ) neur7

    )               shift and go to state 171


state 144

    (64) p -> MTHANEQ . neur11_5 nexp
    (70) neur11_5 -> .

    (               reduce using rule 70 (neur11_5 -> .)
    ID              reduce using rule 70 (neur11_5 -> .)
    CTEE            reduce using rule 70 (neur11_5 -> .)
    CTEF            reduce using rule 70 (neur11_5 -> .)
    CTEBOOL         reduce using rule 70 (neur11_5 -> .)
    CTECHAR         reduce using rule 70 (neur11_5 -> .)
    CALL            reduce using rule 70 (neur11_5 -> .)

    neur11_5                       shift and go to state 172

state 145

    (57) exp -> nexp neur12 p .

    AND             reduce using rule 57 (exp -> nexp neur12 p .)
    OR              reduce using rule 57 (exp -> nexp neur12 p .)
    ;               reduce using rule 57 (exp -> nexp neur12 p .)
    )               reduce using rule 57 (exp -> nexp neur12 p .)
    ID              reduce using rule 57 (exp -> nexp neur12 p .)
    ,               reduce using rule 57 (exp -> nexp neur12 p .)


state 146

    (65) p -> LTHANEQ . neur11_6 nexp
    (71) neur11_6 -> .

    (               reduce using rule 71 (neur11_6 -> .)
    ID              reduce using rule 71 (neur11_6 -> .)
    CTEE            reduce using rule 71 (neur11_6 -> .)
    CTEF            reduce using rule 71 (neur11_6 -> .)
    CTEBOOL         reduce using rule 71 (neur11_6 -> .)
    CTECHAR         reduce using rule 71 (neur11_6 -> .)
    CALL            reduce using rule 71 (neur11_6 -> .)

    neur11_6                       shift and go to state 173

state 147

    (61) p -> NOTEQ . neur11_2 nexp
    (67) neur11_2 -> .

    (               reduce using rule 67 (neur11_2 -> .)
    ID              reduce using rule 67 (neur11_2 -> .)
    CTEE            reduce using rule 67 (neur11_2 -> .)
    CTEF            reduce using rule 67 (neur11_2 -> .)
    CTEBOOL         reduce using rule 67 (neur11_2 -> .)
    CTECHAR         reduce using rule 67 (neur11_2 -> .)
    CALL            reduce using rule 67 (neur11_2 -> .)

    neur11_2                       shift and go to state 174

state 148

    (60) p -> EQ . neur11_1 nexp
    (66) neur11_1 -> .

    (               reduce using rule 66 (neur11_1 -> .)
    ID              reduce using rule 66 (neur11_1 -> .)
    CTEE            reduce using rule 66 (neur11_1 -> .)
    CTEF            reduce using rule 66 (neur11_1 -> .)
    CTEBOOL         reduce using rule 66 (neur11_1 -> .)
    CTECHAR         reduce using rule 66 (neur11_1 -> .)
    CALL            reduce using rule 66 (neur11_1 -> .)

    neur11_1                       shift and go to state 175

state 149

    (63) p -> < . neur11_4 nexp
    (69) neur11_4 -> .

    (               reduce using rule 69 (neur11_4 -> .)
    ID              reduce using rule 69 (neur11_4 -> .)
    CTEE            reduce using rule 69 (neur11_4 -> .)
    CTEF            reduce using rule 69 (neur11_4 -> .)
    CTEBOOL         reduce using rule 69 (neur11_4 -> .)
    CTECHAR         reduce using rule 69 (neur11_4 -> .)
    CALL            reduce using rule 69 (neur11_4 -> .)

    neur11_4                       shift and go to state 176

state 150

    (59) p -> empty .

    AND             reduce using rule 59 (p -> empty .)
    OR              reduce using rule 59 (p -> empty .)
    ;               reduce using rule 59 (p -> empty .)
    )               reduce using rule 59 (p -> empty .)
    ID              reduce using rule 59 (p -> empty .)
    ,               reduce using rule 59 (p -> empty .)


state 151

    (62) p -> > . neur11_3 nexp
    (68) neur11_3 -> .

    (               reduce using rule 68 (neur11_3 -> .)
    ID              reduce using rule 68 (neur11_3 -> .)
    CTEE            reduce using rule 68 (neur11_3 -> .)
    CTEF            reduce using rule 68 (neur11_3 -> .)
    CTEBOOL         reduce using rule 68 (neur11_3 -> .)
    CTECHAR         reduce using rule 68 (neur11_3 -> .)
    CALL            reduce using rule 68 (neur11_3 -> .)

    neur11_3                       shift and go to state 177

state 152

    (82) n -> * . neur2_1 termino
    (84) neur2_1 -> .

    (               reduce using rule 84 (neur2_1 -> .)
    ID              reduce using rule 84 (neur2_1 -> .)
    CTEE            reduce using rule 84 (neur2_1 -> .)
    CTEF            reduce using rule 84 (neur2_1 -> .)
    CTEBOOL         reduce using rule 84 (neur2_1 -> .)
    CTECHAR         reduce using rule 84 (neur2_1 -> .)
    CALL            reduce using rule 84 (neur2_1 -> .)

    neur2_1                        shift and go to state 178

state 153

    (83) n -> / . neur2_2 termino
    (85) neur2_2 -> .

    (               reduce using rule 85 (neur2_2 -> .)
    ID              reduce using rule 85 (neur2_2 -> .)
    CTEE            reduce using rule 85 (neur2_2 -> .)
    CTEF            reduce using rule 85 (neur2_2 -> .)
    CTEBOOL         reduce using rule 85 (neur2_2 -> .)
    CTECHAR         reduce using rule 85 (neur2_2 -> .)
    CALL            reduce using rule 85 (neur2_2 -> .)

    neur2_2                        shift and go to state 179

state 154

    (79) termino -> factor neur4 n .

    +               reduce using rule 79 (termino -> factor neur4 n .)
    -               reduce using rule 79 (termino -> factor neur4 n .)
    AND             reduce using rule 79 (termino -> factor neur4 n .)
    OR              reduce using rule 79 (termino -> factor neur4 n .)
    ;               reduce using rule 79 (termino -> factor neur4 n .)
    )               reduce using rule 79 (termino -> factor neur4 n .)
    ID              reduce using rule 79 (termino -> factor neur4 n .)
    ,               reduce using rule 79 (termino -> factor neur4 n .)
    EQ              reduce using rule 79 (termino -> factor neur4 n .)
    NOTEQ           reduce using rule 79 (termino -> factor neur4 n .)
    >               reduce using rule 79 (termino -> factor neur4 n .)
    <               reduce using rule 79 (termino -> factor neur4 n .)
    MTHANEQ         reduce using rule 79 (termino -> factor neur4 n .)
    LTHANEQ         reduce using rule 79 (termino -> factor neur4 n .)


state 155

    (81) n -> empty .

    +               reduce using rule 81 (n -> empty .)
    -               reduce using rule 81 (n -> empty .)
    EQ              reduce using rule 81 (n -> empty .)
    NOTEQ           reduce using rule 81 (n -> empty .)
    >               reduce using rule 81 (n -> empty .)
    <               reduce using rule 81 (n -> empty .)
    MTHANEQ         reduce using rule 81 (n -> empty .)
    LTHANEQ         reduce using rule 81 (n -> empty .)
    AND             reduce using rule 81 (n -> empty .)
    OR              reduce using rule 81 (n -> empty .)
    ;               reduce using rule 81 (n -> empty .)
    )               reduce using rule 81 (n -> empty .)
    ID              reduce using rule 81 (n -> empty .)
    ,               reduce using rule 81 (n -> empty .)


state 156

    (118) callfunc -> CALL ID ( . s ) ;
    (119) s -> . empty
    (120) s -> . expresion t
    (131) empty -> .
    (47) expresion -> . m subexpresion
    (48) m -> . empty
    (49) m -> . NOT

    )               reduce using rule 131 (empty -> .)
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTEE            reduce using rule 131 (empty -> .)
    CTEF            reduce using rule 131 (empty -> .)
    CTEBOOL         reduce using rule 131 (empty -> .)
    CTECHAR         reduce using rule 131 (empty -> .)
    CALL            reduce using rule 131 (empty -> .)
    NOT             shift and go to state 81

    expresion                      shift and go to state 180
    m                              shift and go to state 80
    s                              shift and go to state 181
    empty                          shift and go to state 182

state 157

    (91) varcte -> ID r neurVar .

    *               reduce using rule 91 (varcte -> ID r neurVar .)
    /               reduce using rule 91 (varcte -> ID r neurVar .)
    +               reduce using rule 91 (varcte -> ID r neurVar .)
    -               reduce using rule 91 (varcte -> ID r neurVar .)
    AND             reduce using rule 91 (varcte -> ID r neurVar .)
    OR              reduce using rule 91 (varcte -> ID r neurVar .)
    ;               reduce using rule 91 (varcte -> ID r neurVar .)
    )               reduce using rule 91 (varcte -> ID r neurVar .)
    ID              reduce using rule 91 (varcte -> ID r neurVar .)
    ,               reduce using rule 91 (varcte -> ID r neurVar .)
    EQ              reduce using rule 91 (varcte -> ID r neurVar .)
    NOTEQ           reduce using rule 91 (varcte -> ID r neurVar .)
    >               reduce using rule 91 (varcte -> ID r neurVar .)
    <               reduce using rule 91 (varcte -> ID r neurVar .)
    MTHANEQ         reduce using rule 91 (varcte -> ID r neurVar .)
    LTHANEQ         reduce using rule 91 (varcte -> ID r neurVar .)


state 158

    (104) oplista -> ID . . x
    (105) x -> . inlistset
    (106) x -> . append
    (107) x -> . length
    (108) x -> . getlist
    (109) x -> . removelist
    (110) inlistset -> . SET ( CTEE , expresion )
    (111) append -> . APPEND ( expresion )
    (112) length -> . LENGTH ( )
    (113) getlist -> . GET ( expresion )
    (114) removelist -> . REMOVE ( expresion )

    SET             shift and go to state 183
    APPEND          shift and go to state 190
    LENGTH          shift and go to state 188
    GET             shift and go to state 185
    REMOVE          shift and go to state 187

    inlistset                      shift and go to state 184
    getlist                        shift and go to state 186
    length                         shift and go to state 189
    x                              shift and go to state 191
    removelist                     shift and go to state 192
    append                         shift and go to state 193

state 159

    (53) o -> AND . neur9_1 subexpresion
    (55) neur9_1 -> .

    (               reduce using rule 55 (neur9_1 -> .)
    ID              reduce using rule 55 (neur9_1 -> .)
    CTEE            reduce using rule 55 (neur9_1 -> .)
    CTEF            reduce using rule 55 (neur9_1 -> .)
    CTEBOOL         reduce using rule 55 (neur9_1 -> .)
    CTECHAR         reduce using rule 55 (neur9_1 -> .)
    CALL            reduce using rule 55 (neur9_1 -> .)

    neur9_1                        shift and go to state 194

state 160

    (50) subexpresion -> exp neur10 o .

    ;               reduce using rule 50 (subexpresion -> exp neur10 o .)
    )               reduce using rule 50 (subexpresion -> exp neur10 o .)
    ID              reduce using rule 50 (subexpresion -> exp neur10 o .)
    ,               reduce using rule 50 (subexpresion -> exp neur10 o .)


state 161

    (54) o -> OR . neur9_2 subexpresion
    (56) neur9_2 -> .

    (               reduce using rule 56 (neur9_2 -> .)
    ID              reduce using rule 56 (neur9_2 -> .)
    CTEE            reduce using rule 56 (neur9_2 -> .)
    CTEF            reduce using rule 56 (neur9_2 -> .)
    CTEBOOL         reduce using rule 56 (neur9_2 -> .)
    CTECHAR         reduce using rule 56 (neur9_2 -> .)
    CALL            reduce using rule 56 (neur9_2 -> .)

    neur9_2                        shift and go to state 195

state 162

    (52) o -> empty .

    ;               reduce using rule 52 (o -> empty .)
    )               reduce using rule 52 (o -> empty .)
    ID              reduce using rule 52 (o -> empty .)
    ,               reduce using rule 52 (o -> empty .)


state 163

    (46) for -> FOR ( asignacion expresion asignacion . ) bloque ;

    )               shift and go to state 196


state 164

    (38) asignacion -> ID = neur8 k ; .

    NOT             reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    (               reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    ID              reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CTEE            reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CTEF            reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CTEBOOL         reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CTECHAR         reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    CALL            reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    IF              reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    FOR             reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    RETURN          reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    WHILE           reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    PLAY            reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    PRINT           reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    }               reduce using rule 38 (asignacion -> ID = neur8 k ; .)
    )               reduce using rule 38 (asignacion -> ID = neur8 k ; .)


state 165

    (42) asiglista -> NEW LIST . ( )

    (               shift and go to state 197


state 166

    (43) if -> IF ( expresion ) bloque . l ;
    (44) l -> . empty
    (45) l -> . ELSE bloque
    (131) empty -> .

    ELSE            shift and go to state 199
    ;               reduce using rule 131 (empty -> .)

    l                              shift and go to state 198
    empty                          shift and go to state 200

state 167

    (116) play -> PLAY ( NOTA , CTEE ) . ;

    ;               shift and go to state 201


state 168

    (115) while -> WHILE ( expresion ) bloque ; .

    ID              reduce using rule 115 (while -> WHILE ( expresion ) bloque ; .)
    IF              reduce using rule 115 (while -> WHILE ( expresion ) bloque ; .)
    FOR             reduce using rule 115 (while -> WHILE ( expresion ) bloque ; .)
    RETURN          reduce using rule 115 (while -> WHILE ( expresion ) bloque ; .)
    WHILE           reduce using rule 115 (while -> WHILE ( expresion ) bloque ; .)
    PLAY            reduce using rule 115 (while -> WHILE ( expresion ) bloque ; .)
    PRINT           reduce using rule 115 (while -> WHILE ( expresion ) bloque ; .)
    }               reduce using rule 115 (while -> WHILE ( expresion ) bloque ; .)


state 169

    (75) q -> + neur3_1 . nexp
    (72) nexp -> . termino neur5 q
    (79) termino -> . factor neur4 n
    (86) factor -> . ( neur6 expresion ) neur7
    (87) factor -> . varcte neur1
    (91) varcte -> . ID r neurVar
    (92) varcte -> . CTEE neurCteE
    (93) varcte -> . CTEF neurCteF
    (94) varcte -> . CTEBOOL neurCteB
    (95) varcte -> . callfunc
    (96) varcte -> . CTECHAR neurCteCh
    (118) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    nexp                           shift and go to state 202
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 170

    (76) q -> - neur3_2 . nexp
    (72) nexp -> . termino neur5 q
    (79) termino -> . factor neur4 n
    (86) factor -> . ( neur6 expresion ) neur7
    (87) factor -> . varcte neur1
    (91) varcte -> . ID r neurVar
    (92) varcte -> . CTEE neurCteE
    (93) varcte -> . CTEF neurCteF
    (94) varcte -> . CTEBOOL neurCteB
    (95) varcte -> . callfunc
    (96) varcte -> . CTECHAR neurCteCh
    (118) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    nexp                           shift and go to state 203
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 171

    (86) factor -> ( neur6 expresion ) . neur7
    (89) neur7 -> .

    *               reduce using rule 89 (neur7 -> .)
    /               reduce using rule 89 (neur7 -> .)
    +               reduce using rule 89 (neur7 -> .)
    -               reduce using rule 89 (neur7 -> .)
    EQ              reduce using rule 89 (neur7 -> .)
    NOTEQ           reduce using rule 89 (neur7 -> .)
    >               reduce using rule 89 (neur7 -> .)
    <               reduce using rule 89 (neur7 -> .)
    MTHANEQ         reduce using rule 89 (neur7 -> .)
    LTHANEQ         reduce using rule 89 (neur7 -> .)
    AND             reduce using rule 89 (neur7 -> .)
    OR              reduce using rule 89 (neur7 -> .)
    ;               reduce using rule 89 (neur7 -> .)
    )               reduce using rule 89 (neur7 -> .)
    ID              reduce using rule 89 (neur7 -> .)
    ,               reduce using rule 89 (neur7 -> .)

    neur7                          shift and go to state 204

state 172

    (64) p -> MTHANEQ neur11_5 . nexp
    (72) nexp -> . termino neur5 q
    (79) termino -> . factor neur4 n
    (86) factor -> . ( neur6 expresion ) neur7
    (87) factor -> . varcte neur1
    (91) varcte -> . ID r neurVar
    (92) varcte -> . CTEE neurCteE
    (93) varcte -> . CTEF neurCteF
    (94) varcte -> . CTEBOOL neurCteB
    (95) varcte -> . callfunc
    (96) varcte -> . CTECHAR neurCteCh
    (118) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    nexp                           shift and go to state 205
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 173

    (65) p -> LTHANEQ neur11_6 . nexp
    (72) nexp -> . termino neur5 q
    (79) termino -> . factor neur4 n
    (86) factor -> . ( neur6 expresion ) neur7
    (87) factor -> . varcte neur1
    (91) varcte -> . ID r neurVar
    (92) varcte -> . CTEE neurCteE
    (93) varcte -> . CTEF neurCteF
    (94) varcte -> . CTEBOOL neurCteB
    (95) varcte -> . callfunc
    (96) varcte -> . CTECHAR neurCteCh
    (118) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    nexp                           shift and go to state 206
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 174

    (61) p -> NOTEQ neur11_2 . nexp
    (72) nexp -> . termino neur5 q
    (79) termino -> . factor neur4 n
    (86) factor -> . ( neur6 expresion ) neur7
    (87) factor -> . varcte neur1
    (91) varcte -> . ID r neurVar
    (92) varcte -> . CTEE neurCteE
    (93) varcte -> . CTEF neurCteF
    (94) varcte -> . CTEBOOL neurCteB
    (95) varcte -> . callfunc
    (96) varcte -> . CTECHAR neurCteCh
    (118) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    nexp                           shift and go to state 207
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 175

    (60) p -> EQ neur11_1 . nexp
    (72) nexp -> . termino neur5 q
    (79) termino -> . factor neur4 n
    (86) factor -> . ( neur6 expresion ) neur7
    (87) factor -> . varcte neur1
    (91) varcte -> . ID r neurVar
    (92) varcte -> . CTEE neurCteE
    (93) varcte -> . CTEF neurCteF
    (94) varcte -> . CTEBOOL neurCteB
    (95) varcte -> . callfunc
    (96) varcte -> . CTECHAR neurCteCh
    (118) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    nexp                           shift and go to state 208
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 176

    (63) p -> < neur11_4 . nexp
    (72) nexp -> . termino neur5 q
    (79) termino -> . factor neur4 n
    (86) factor -> . ( neur6 expresion ) neur7
    (87) factor -> . varcte neur1
    (91) varcte -> . ID r neurVar
    (92) varcte -> . CTEE neurCteE
    (93) varcte -> . CTEF neurCteF
    (94) varcte -> . CTEBOOL neurCteB
    (95) varcte -> . callfunc
    (96) varcte -> . CTECHAR neurCteCh
    (118) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    nexp                           shift and go to state 209
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 177

    (62) p -> > neur11_3 . nexp
    (72) nexp -> . termino neur5 q
    (79) termino -> . factor neur4 n
    (86) factor -> . ( neur6 expresion ) neur7
    (87) factor -> . varcte neur1
    (91) varcte -> . ID r neurVar
    (92) varcte -> . CTEE neurCteE
    (93) varcte -> . CTEF neurCteF
    (94) varcte -> . CTEBOOL neurCteB
    (95) varcte -> . callfunc
    (96) varcte -> . CTECHAR neurCteCh
    (118) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    nexp                           shift and go to state 210
    callfunc                       shift and go to state 105
    termino                        shift and go to state 95
    factor                         shift and go to state 100

state 178

    (82) n -> * neur2_1 . termino
    (79) termino -> . factor neur4 n
    (86) factor -> . ( neur6 expresion ) neur7
    (87) factor -> . varcte neur1
    (91) varcte -> . ID r neurVar
    (92) varcte -> . CTEE neurCteE
    (93) varcte -> . CTEF neurCteF
    (94) varcte -> . CTEBOOL neurCteB
    (95) varcte -> . callfunc
    (96) varcte -> . CTECHAR neurCteCh
    (118) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    termino                        shift and go to state 211
    factor                         shift and go to state 100

state 179

    (83) n -> / neur2_2 . termino
    (79) termino -> . factor neur4 n
    (86) factor -> . ( neur6 expresion ) neur7
    (87) factor -> . varcte neur1
    (91) varcte -> . ID r neurVar
    (92) varcte -> . CTEE neurCteE
    (93) varcte -> . CTEF neurCteF
    (94) varcte -> . CTEBOOL neurCteB
    (95) varcte -> . callfunc
    (96) varcte -> . CTECHAR neurCteCh
    (118) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    varcte                         shift and go to state 97
    callfunc                       shift and go to state 105
    termino                        shift and go to state 212
    factor                         shift and go to state 100

state 180

    (120) s -> expresion . t
    (121) t -> . empty
    (122) t -> . , s
    (131) empty -> .

    ,               shift and go to state 215
    )               reduce using rule 131 (empty -> .)

    t                              shift and go to state 213
    empty                          shift and go to state 214

state 181

    (118) callfunc -> CALL ID ( s . ) ;

    )               shift and go to state 216


state 182

    (119) s -> empty .
    (48) m -> empty .

    )               reduce using rule 119 (s -> empty .)
    (               reduce using rule 48 (m -> empty .)
    ID              reduce using rule 48 (m -> empty .)
    CTEE            reduce using rule 48 (m -> empty .)
    CTEF            reduce using rule 48 (m -> empty .)
    CTEBOOL         reduce using rule 48 (m -> empty .)
    CTECHAR         reduce using rule 48 (m -> empty .)
    CALL            reduce using rule 48 (m -> empty .)


state 183

    (110) inlistset -> SET . ( CTEE , expresion )

    (               shift and go to state 217


state 184

    (105) x -> inlistset .

    *               reduce using rule 105 (x -> inlistset .)
    /               reduce using rule 105 (x -> inlistset .)
    +               reduce using rule 105 (x -> inlistset .)
    -               reduce using rule 105 (x -> inlistset .)
    EQ              reduce using rule 105 (x -> inlistset .)
    NOTEQ           reduce using rule 105 (x -> inlistset .)
    >               reduce using rule 105 (x -> inlistset .)
    <               reduce using rule 105 (x -> inlistset .)
    MTHANEQ         reduce using rule 105 (x -> inlistset .)
    LTHANEQ         reduce using rule 105 (x -> inlistset .)
    AND             reduce using rule 105 (x -> inlistset .)
    OR              reduce using rule 105 (x -> inlistset .)
    ;               reduce using rule 105 (x -> inlistset .)
    )               reduce using rule 105 (x -> inlistset .)
    ID              reduce using rule 105 (x -> inlistset .)
    ,               reduce using rule 105 (x -> inlistset .)


state 185

    (113) getlist -> GET . ( expresion )

    (               shift and go to state 218


state 186

    (108) x -> getlist .

    *               reduce using rule 108 (x -> getlist .)
    /               reduce using rule 108 (x -> getlist .)
    +               reduce using rule 108 (x -> getlist .)
    -               reduce using rule 108 (x -> getlist .)
    EQ              reduce using rule 108 (x -> getlist .)
    NOTEQ           reduce using rule 108 (x -> getlist .)
    >               reduce using rule 108 (x -> getlist .)
    <               reduce using rule 108 (x -> getlist .)
    MTHANEQ         reduce using rule 108 (x -> getlist .)
    LTHANEQ         reduce using rule 108 (x -> getlist .)
    AND             reduce using rule 108 (x -> getlist .)
    OR              reduce using rule 108 (x -> getlist .)
    ;               reduce using rule 108 (x -> getlist .)
    )               reduce using rule 108 (x -> getlist .)
    ID              reduce using rule 108 (x -> getlist .)
    ,               reduce using rule 108 (x -> getlist .)


state 187

    (114) removelist -> REMOVE . ( expresion )

    (               shift and go to state 219


state 188

    (112) length -> LENGTH . ( )

    (               shift and go to state 220


state 189

    (107) x -> length .

    *               reduce using rule 107 (x -> length .)
    /               reduce using rule 107 (x -> length .)
    +               reduce using rule 107 (x -> length .)
    -               reduce using rule 107 (x -> length .)
    EQ              reduce using rule 107 (x -> length .)
    NOTEQ           reduce using rule 107 (x -> length .)
    >               reduce using rule 107 (x -> length .)
    <               reduce using rule 107 (x -> length .)
    MTHANEQ         reduce using rule 107 (x -> length .)
    LTHANEQ         reduce using rule 107 (x -> length .)
    AND             reduce using rule 107 (x -> length .)
    OR              reduce using rule 107 (x -> length .)
    ;               reduce using rule 107 (x -> length .)
    )               reduce using rule 107 (x -> length .)
    ID              reduce using rule 107 (x -> length .)
    ,               reduce using rule 107 (x -> length .)


state 190

    (111) append -> APPEND . ( expresion )

    (               shift and go to state 221


state 191

    (104) oplista -> ID . x .

    *               reduce using rule 104 (oplista -> ID . x .)
    /               reduce using rule 104 (oplista -> ID . x .)
    +               reduce using rule 104 (oplista -> ID . x .)
    -               reduce using rule 104 (oplista -> ID . x .)
    EQ              reduce using rule 104 (oplista -> ID . x .)
    NOTEQ           reduce using rule 104 (oplista -> ID . x .)
    >               reduce using rule 104 (oplista -> ID . x .)
    <               reduce using rule 104 (oplista -> ID . x .)
    MTHANEQ         reduce using rule 104 (oplista -> ID . x .)
    LTHANEQ         reduce using rule 104 (oplista -> ID . x .)
    AND             reduce using rule 104 (oplista -> ID . x .)
    OR              reduce using rule 104 (oplista -> ID . x .)
    ;               reduce using rule 104 (oplista -> ID . x .)
    )               reduce using rule 104 (oplista -> ID . x .)
    ID              reduce using rule 104 (oplista -> ID . x .)
    ,               reduce using rule 104 (oplista -> ID . x .)


state 192

    (109) x -> removelist .

    *               reduce using rule 109 (x -> removelist .)
    /               reduce using rule 109 (x -> removelist .)
    +               reduce using rule 109 (x -> removelist .)
    -               reduce using rule 109 (x -> removelist .)
    EQ              reduce using rule 109 (x -> removelist .)
    NOTEQ           reduce using rule 109 (x -> removelist .)
    >               reduce using rule 109 (x -> removelist .)
    <               reduce using rule 109 (x -> removelist .)
    MTHANEQ         reduce using rule 109 (x -> removelist .)
    LTHANEQ         reduce using rule 109 (x -> removelist .)
    AND             reduce using rule 109 (x -> removelist .)
    OR              reduce using rule 109 (x -> removelist .)
    ;               reduce using rule 109 (x -> removelist .)
    )               reduce using rule 109 (x -> removelist .)
    ID              reduce using rule 109 (x -> removelist .)
    ,               reduce using rule 109 (x -> removelist .)


state 193

    (106) x -> append .

    *               reduce using rule 106 (x -> append .)
    /               reduce using rule 106 (x -> append .)
    +               reduce using rule 106 (x -> append .)
    -               reduce using rule 106 (x -> append .)
    EQ              reduce using rule 106 (x -> append .)
    NOTEQ           reduce using rule 106 (x -> append .)
    >               reduce using rule 106 (x -> append .)
    <               reduce using rule 106 (x -> append .)
    MTHANEQ         reduce using rule 106 (x -> append .)
    LTHANEQ         reduce using rule 106 (x -> append .)
    AND             reduce using rule 106 (x -> append .)
    OR              reduce using rule 106 (x -> append .)
    ;               reduce using rule 106 (x -> append .)
    )               reduce using rule 106 (x -> append .)
    ID              reduce using rule 106 (x -> append .)
    ,               reduce using rule 106 (x -> append .)


state 194

    (53) o -> AND neur9_1 . subexpresion
    (50) subexpresion -> . exp neur10 o
    (57) exp -> . nexp neur12 p
    (72) nexp -> . termino neur5 q
    (79) termino -> . factor neur4 n
    (86) factor -> . ( neur6 expresion ) neur7
    (87) factor -> . varcte neur1
    (91) varcte -> . ID r neurVar
    (92) varcte -> . CTEE neurCteE
    (93) varcte -> . CTEF neurCteF
    (94) varcte -> . CTEBOOL neurCteB
    (95) varcte -> . callfunc
    (96) varcte -> . CTECHAR neurCteCh
    (118) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    termino                        shift and go to state 95
    varcte                         shift and go to state 97
    nexp                           shift and go to state 99
    factor                         shift and go to state 100
    subexpresion                   shift and go to state 222
    callfunc                       shift and go to state 105
    exp                            shift and go to state 107

state 195

    (54) o -> OR neur9_2 . subexpresion
    (50) subexpresion -> . exp neur10 o
    (57) exp -> . nexp neur12 p
    (72) nexp -> . termino neur5 q
    (79) termino -> . factor neur4 n
    (86) factor -> . ( neur6 expresion ) neur7
    (87) factor -> . varcte neur1
    (91) varcte -> . ID r neurVar
    (92) varcte -> . CTEE neurCteE
    (93) varcte -> . CTEF neurCteF
    (94) varcte -> . CTEBOOL neurCteB
    (95) varcte -> . callfunc
    (96) varcte -> . CTECHAR neurCteCh
    (118) callfunc -> . CALL ID ( s ) ;

    (               shift and go to state 98
    ID              shift and go to state 103
    CTEE            shift and go to state 108
    CTEF            shift and go to state 106
    CTEBOOL         shift and go to state 104
    CTECHAR         shift and go to state 96
    CALL            shift and go to state 101

    termino                        shift and go to state 95
    varcte                         shift and go to state 97
    nexp                           shift and go to state 99
    factor                         shift and go to state 100
    subexpresion                   shift and go to state 223
    callfunc                       shift and go to state 105
    exp                            shift and go to state 107

state 196

    (46) for -> FOR ( asignacion expresion asignacion ) . bloque ;
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 224

state 197

    (42) asiglista -> NEW LIST ( . )

    )               shift and go to state 225


state 198

    (43) if -> IF ( expresion ) bloque l . ;

    ;               shift and go to state 226


state 199

    (45) l -> ELSE . bloque
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 227

state 200

    (44) l -> empty .

    ;               reduce using rule 44 (l -> empty .)


state 201

    (116) play -> PLAY ( NOTA , CTEE ) ; .

    ID              reduce using rule 116 (play -> PLAY ( NOTA , CTEE ) ; .)
    IF              reduce using rule 116 (play -> PLAY ( NOTA , CTEE ) ; .)
    FOR             reduce using rule 116 (play -> PLAY ( NOTA , CTEE ) ; .)
    RETURN          reduce using rule 116 (play -> PLAY ( NOTA , CTEE ) ; .)
    WHILE           reduce using rule 116 (play -> PLAY ( NOTA , CTEE ) ; .)
    PLAY            reduce using rule 116 (play -> PLAY ( NOTA , CTEE ) ; .)
    PRINT           reduce using rule 116 (play -> PLAY ( NOTA , CTEE ) ; .)
    }               reduce using rule 116 (play -> PLAY ( NOTA , CTEE ) ; .)


state 202

    (75) q -> + neur3_1 nexp .

    EQ              reduce using rule 75 (q -> + neur3_1 nexp .)
    NOTEQ           reduce using rule 75 (q -> + neur3_1 nexp .)
    >               reduce using rule 75 (q -> + neur3_1 nexp .)
    <               reduce using rule 75 (q -> + neur3_1 nexp .)
    MTHANEQ         reduce using rule 75 (q -> + neur3_1 nexp .)
    LTHANEQ         reduce using rule 75 (q -> + neur3_1 nexp .)
    AND             reduce using rule 75 (q -> + neur3_1 nexp .)
    OR              reduce using rule 75 (q -> + neur3_1 nexp .)
    ;               reduce using rule 75 (q -> + neur3_1 nexp .)
    )               reduce using rule 75 (q -> + neur3_1 nexp .)
    ID              reduce using rule 75 (q -> + neur3_1 nexp .)
    ,               reduce using rule 75 (q -> + neur3_1 nexp .)


state 203

    (76) q -> - neur3_2 nexp .

    EQ              reduce using rule 76 (q -> - neur3_2 nexp .)
    NOTEQ           reduce using rule 76 (q -> - neur3_2 nexp .)
    >               reduce using rule 76 (q -> - neur3_2 nexp .)
    <               reduce using rule 76 (q -> - neur3_2 nexp .)
    MTHANEQ         reduce using rule 76 (q -> - neur3_2 nexp .)
    LTHANEQ         reduce using rule 76 (q -> - neur3_2 nexp .)
    AND             reduce using rule 76 (q -> - neur3_2 nexp .)
    OR              reduce using rule 76 (q -> - neur3_2 nexp .)
    ;               reduce using rule 76 (q -> - neur3_2 nexp .)
    )               reduce using rule 76 (q -> - neur3_2 nexp .)
    ID              reduce using rule 76 (q -> - neur3_2 nexp .)
    ,               reduce using rule 76 (q -> - neur3_2 nexp .)


state 204

    (86) factor -> ( neur6 expresion ) neur7 .

    *               reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    /               reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    +               reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    -               reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    EQ              reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    NOTEQ           reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    >               reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    <               reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    MTHANEQ         reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    LTHANEQ         reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    AND             reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    OR              reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    ;               reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    )               reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    ID              reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)
    ,               reduce using rule 86 (factor -> ( neur6 expresion ) neur7 .)


state 205

    (64) p -> MTHANEQ neur11_5 nexp .

    AND             reduce using rule 64 (p -> MTHANEQ neur11_5 nexp .)
    OR              reduce using rule 64 (p -> MTHANEQ neur11_5 nexp .)
    ;               reduce using rule 64 (p -> MTHANEQ neur11_5 nexp .)
    )               reduce using rule 64 (p -> MTHANEQ neur11_5 nexp .)
    ID              reduce using rule 64 (p -> MTHANEQ neur11_5 nexp .)
    ,               reduce using rule 64 (p -> MTHANEQ neur11_5 nexp .)


state 206

    (65) p -> LTHANEQ neur11_6 nexp .

    AND             reduce using rule 65 (p -> LTHANEQ neur11_6 nexp .)
    OR              reduce using rule 65 (p -> LTHANEQ neur11_6 nexp .)
    ;               reduce using rule 65 (p -> LTHANEQ neur11_6 nexp .)
    )               reduce using rule 65 (p -> LTHANEQ neur11_6 nexp .)
    ID              reduce using rule 65 (p -> LTHANEQ neur11_6 nexp .)
    ,               reduce using rule 65 (p -> LTHANEQ neur11_6 nexp .)


state 207

    (61) p -> NOTEQ neur11_2 nexp .

    AND             reduce using rule 61 (p -> NOTEQ neur11_2 nexp .)
    OR              reduce using rule 61 (p -> NOTEQ neur11_2 nexp .)
    ;               reduce using rule 61 (p -> NOTEQ neur11_2 nexp .)
    )               reduce using rule 61 (p -> NOTEQ neur11_2 nexp .)
    ID              reduce using rule 61 (p -> NOTEQ neur11_2 nexp .)
    ,               reduce using rule 61 (p -> NOTEQ neur11_2 nexp .)


state 208

    (60) p -> EQ neur11_1 nexp .

    AND             reduce using rule 60 (p -> EQ neur11_1 nexp .)
    OR              reduce using rule 60 (p -> EQ neur11_1 nexp .)
    ;               reduce using rule 60 (p -> EQ neur11_1 nexp .)
    )               reduce using rule 60 (p -> EQ neur11_1 nexp .)
    ID              reduce using rule 60 (p -> EQ neur11_1 nexp .)
    ,               reduce using rule 60 (p -> EQ neur11_1 nexp .)


state 209

    (63) p -> < neur11_4 nexp .

    AND             reduce using rule 63 (p -> < neur11_4 nexp .)
    OR              reduce using rule 63 (p -> < neur11_4 nexp .)
    ;               reduce using rule 63 (p -> < neur11_4 nexp .)
    )               reduce using rule 63 (p -> < neur11_4 nexp .)
    ID              reduce using rule 63 (p -> < neur11_4 nexp .)
    ,               reduce using rule 63 (p -> < neur11_4 nexp .)


state 210

    (62) p -> > neur11_3 nexp .

    AND             reduce using rule 62 (p -> > neur11_3 nexp .)
    OR              reduce using rule 62 (p -> > neur11_3 nexp .)
    ;               reduce using rule 62 (p -> > neur11_3 nexp .)
    )               reduce using rule 62 (p -> > neur11_3 nexp .)
    ID              reduce using rule 62 (p -> > neur11_3 nexp .)
    ,               reduce using rule 62 (p -> > neur11_3 nexp .)


state 211

    (82) n -> * neur2_1 termino .

    +               reduce using rule 82 (n -> * neur2_1 termino .)
    -               reduce using rule 82 (n -> * neur2_1 termino .)
    EQ              reduce using rule 82 (n -> * neur2_1 termino .)
    NOTEQ           reduce using rule 82 (n -> * neur2_1 termino .)
    >               reduce using rule 82 (n -> * neur2_1 termino .)
    <               reduce using rule 82 (n -> * neur2_1 termino .)
    MTHANEQ         reduce using rule 82 (n -> * neur2_1 termino .)
    LTHANEQ         reduce using rule 82 (n -> * neur2_1 termino .)
    AND             reduce using rule 82 (n -> * neur2_1 termino .)
    OR              reduce using rule 82 (n -> * neur2_1 termino .)
    ;               reduce using rule 82 (n -> * neur2_1 termino .)
    )               reduce using rule 82 (n -> * neur2_1 termino .)
    ID              reduce using rule 82 (n -> * neur2_1 termino .)
    ,               reduce using rule 82 (n -> * neur2_1 termino .)


state 212

    (83) n -> / neur2_2 termino .

    +               reduce using rule 83 (n -> / neur2_2 termino .)
    -               reduce using rule 83 (n -> / neur2_2 termino .)
    EQ              reduce using rule 83 (n -> / neur2_2 termino .)
    NOTEQ           reduce using rule 83 (n -> / neur2_2 termino .)
    >               reduce using rule 83 (n -> / neur2_2 termino .)
    <               reduce using rule 83 (n -> / neur2_2 termino .)
    MTHANEQ         reduce using rule 83 (n -> / neur2_2 termino .)
    LTHANEQ         reduce using rule 83 (n -> / neur2_2 termino .)
    AND             reduce using rule 83 (n -> / neur2_2 termino .)
    OR              reduce using rule 83 (n -> / neur2_2 termino .)
    ;               reduce using rule 83 (n -> / neur2_2 termino .)
    )               reduce using rule 83 (n -> / neur2_2 termino .)
    ID              reduce using rule 83 (n -> / neur2_2 termino .)
    ,               reduce using rule 83 (n -> / neur2_2 termino .)


state 213

    (120) s -> expresion t .

    )               reduce using rule 120 (s -> expresion t .)


state 214

    (121) t -> empty .

    )               reduce using rule 121 (t -> empty .)


state 215

    (122) t -> , . s
    (119) s -> . empty
    (120) s -> . expresion t
    (131) empty -> .
    (47) expresion -> . m subexpresion
    (48) m -> . empty
    (49) m -> . NOT

    )               reduce using rule 131 (empty -> .)
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTEE            reduce using rule 131 (empty -> .)
    CTEF            reduce using rule 131 (empty -> .)
    CTEBOOL         reduce using rule 131 (empty -> .)
    CTECHAR         reduce using rule 131 (empty -> .)
    CALL            reduce using rule 131 (empty -> .)
    NOT             shift and go to state 81

    expresion                      shift and go to state 180
    m                              shift and go to state 80
    s                              shift and go to state 228
    empty                          shift and go to state 182

state 216

    (118) callfunc -> CALL ID ( s ) . ;

    ;               shift and go to state 229


state 217

    (110) inlistset -> SET ( . CTEE , expresion )

    CTEE            shift and go to state 230


state 218

    (113) getlist -> GET ( . expresion )
    (47) expresion -> . m subexpresion
    (48) m -> . empty
    (49) m -> . NOT
    (131) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTEE            reduce using rule 131 (empty -> .)
    CTEF            reduce using rule 131 (empty -> .)
    CTEBOOL         reduce using rule 131 (empty -> .)
    CTECHAR         reduce using rule 131 (empty -> .)
    CALL            reduce using rule 131 (empty -> .)

    expresion                      shift and go to state 231
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 219

    (114) removelist -> REMOVE ( . expresion )
    (47) expresion -> . m subexpresion
    (48) m -> . empty
    (49) m -> . NOT
    (131) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTEE            reduce using rule 131 (empty -> .)
    CTEF            reduce using rule 131 (empty -> .)
    CTEBOOL         reduce using rule 131 (empty -> .)
    CTECHAR         reduce using rule 131 (empty -> .)
    CALL            reduce using rule 131 (empty -> .)

    expresion                      shift and go to state 232
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 220

    (112) length -> LENGTH ( . )

    )               shift and go to state 233


state 221

    (111) append -> APPEND ( . expresion )
    (47) expresion -> . m subexpresion
    (48) m -> . empty
    (49) m -> . NOT
    (131) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTEE            reduce using rule 131 (empty -> .)
    CTEF            reduce using rule 131 (empty -> .)
    CTEBOOL         reduce using rule 131 (empty -> .)
    CTECHAR         reduce using rule 131 (empty -> .)
    CALL            reduce using rule 131 (empty -> .)

    expresion                      shift and go to state 234
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 222

    (53) o -> AND neur9_1 subexpresion .

    ;               reduce using rule 53 (o -> AND neur9_1 subexpresion .)
    )               reduce using rule 53 (o -> AND neur9_1 subexpresion .)
    ID              reduce using rule 53 (o -> AND neur9_1 subexpresion .)
    ,               reduce using rule 53 (o -> AND neur9_1 subexpresion .)


state 223

    (54) o -> OR neur9_2 subexpresion .

    ;               reduce using rule 54 (o -> OR neur9_2 subexpresion .)
    )               reduce using rule 54 (o -> OR neur9_2 subexpresion .)
    ID              reduce using rule 54 (o -> OR neur9_2 subexpresion .)
    ,               reduce using rule 54 (o -> OR neur9_2 subexpresion .)


state 224

    (46) for -> FOR ( asignacion expresion asignacion ) bloque . ;

    ;               shift and go to state 235


state 225

    (42) asiglista -> NEW LIST ( ) .

    ;               reduce using rule 42 (asiglista -> NEW LIST ( ) .)


state 226

    (43) if -> IF ( expresion ) bloque l ; .

    ID              reduce using rule 43 (if -> IF ( expresion ) bloque l ; .)
    IF              reduce using rule 43 (if -> IF ( expresion ) bloque l ; .)
    FOR             reduce using rule 43 (if -> IF ( expresion ) bloque l ; .)
    RETURN          reduce using rule 43 (if -> IF ( expresion ) bloque l ; .)
    WHILE           reduce using rule 43 (if -> IF ( expresion ) bloque l ; .)
    PLAY            reduce using rule 43 (if -> IF ( expresion ) bloque l ; .)
    PRINT           reduce using rule 43 (if -> IF ( expresion ) bloque l ; .)
    }               reduce using rule 43 (if -> IF ( expresion ) bloque l ; .)


state 227

    (45) l -> ELSE bloque .

    ;               reduce using rule 45 (l -> ELSE bloque .)


state 228

    (122) t -> , s .

    )               reduce using rule 122 (t -> , s .)


state 229

    (118) callfunc -> CALL ID ( s ) ; .

    *               reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    /               reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    +               reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    -               reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    EQ              reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    NOTEQ           reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    >               reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    <               reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    MTHANEQ         reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    LTHANEQ         reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    AND             reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    OR              reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    ;               reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    )               reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    ID              reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)
    ,               reduce using rule 118 (callfunc -> CALL ID ( s ) ; .)


state 230

    (110) inlistset -> SET ( CTEE . , expresion )

    ,               shift and go to state 236


state 231

    (113) getlist -> GET ( expresion . )

    )               shift and go to state 237


state 232

    (114) removelist -> REMOVE ( expresion . )

    )               shift and go to state 238


state 233

    (112) length -> LENGTH ( ) .

    *               reduce using rule 112 (length -> LENGTH ( ) .)
    /               reduce using rule 112 (length -> LENGTH ( ) .)
    +               reduce using rule 112 (length -> LENGTH ( ) .)
    -               reduce using rule 112 (length -> LENGTH ( ) .)
    EQ              reduce using rule 112 (length -> LENGTH ( ) .)
    NOTEQ           reduce using rule 112 (length -> LENGTH ( ) .)
    >               reduce using rule 112 (length -> LENGTH ( ) .)
    <               reduce using rule 112 (length -> LENGTH ( ) .)
    MTHANEQ         reduce using rule 112 (length -> LENGTH ( ) .)
    LTHANEQ         reduce using rule 112 (length -> LENGTH ( ) .)
    AND             reduce using rule 112 (length -> LENGTH ( ) .)
    OR              reduce using rule 112 (length -> LENGTH ( ) .)
    ;               reduce using rule 112 (length -> LENGTH ( ) .)
    )               reduce using rule 112 (length -> LENGTH ( ) .)
    ID              reduce using rule 112 (length -> LENGTH ( ) .)
    ,               reduce using rule 112 (length -> LENGTH ( ) .)


state 234

    (111) append -> APPEND ( expresion . )

    )               shift and go to state 239


state 235

    (46) for -> FOR ( asignacion expresion asignacion ) bloque ; .

    ID              reduce using rule 46 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    IF              reduce using rule 46 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    FOR             reduce using rule 46 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    RETURN          reduce using rule 46 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    WHILE           reduce using rule 46 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    PLAY            reduce using rule 46 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    PRINT           reduce using rule 46 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    }               reduce using rule 46 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)


state 236

    (110) inlistset -> SET ( CTEE , . expresion )
    (47) expresion -> . m subexpresion
    (48) m -> . empty
    (49) m -> . NOT
    (131) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 131 (empty -> .)
    ID              reduce using rule 131 (empty -> .)
    CTEE            reduce using rule 131 (empty -> .)
    CTEF            reduce using rule 131 (empty -> .)
    CTEBOOL         reduce using rule 131 (empty -> .)
    CTECHAR         reduce using rule 131 (empty -> .)
    CALL            reduce using rule 131 (empty -> .)

    expresion                      shift and go to state 240
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 237

    (113) getlist -> GET ( expresion ) .

    *               reduce using rule 113 (getlist -> GET ( expresion ) .)
    /               reduce using rule 113 (getlist -> GET ( expresion ) .)
    +               reduce using rule 113 (getlist -> GET ( expresion ) .)
    -               reduce using rule 113 (getlist -> GET ( expresion ) .)
    EQ              reduce using rule 113 (getlist -> GET ( expresion ) .)
    NOTEQ           reduce using rule 113 (getlist -> GET ( expresion ) .)
    >               reduce using rule 113 (getlist -> GET ( expresion ) .)
    <               reduce using rule 113 (getlist -> GET ( expresion ) .)
    MTHANEQ         reduce using rule 113 (getlist -> GET ( expresion ) .)
    LTHANEQ         reduce using rule 113 (getlist -> GET ( expresion ) .)
    AND             reduce using rule 113 (getlist -> GET ( expresion ) .)
    OR              reduce using rule 113 (getlist -> GET ( expresion ) .)
    ;               reduce using rule 113 (getlist -> GET ( expresion ) .)
    )               reduce using rule 113 (getlist -> GET ( expresion ) .)
    ID              reduce using rule 113 (getlist -> GET ( expresion ) .)
    ,               reduce using rule 113 (getlist -> GET ( expresion ) .)


state 238

    (114) removelist -> REMOVE ( expresion ) .

    *               reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    /               reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    +               reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    -               reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    EQ              reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    NOTEQ           reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    >               reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    <               reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    MTHANEQ         reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    LTHANEQ         reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    AND             reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    OR              reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    ;               reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    )               reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    ID              reduce using rule 114 (removelist -> REMOVE ( expresion ) .)
    ,               reduce using rule 114 (removelist -> REMOVE ( expresion ) .)


state 239

    (111) append -> APPEND ( expresion ) .

    *               reduce using rule 111 (append -> APPEND ( expresion ) .)
    /               reduce using rule 111 (append -> APPEND ( expresion ) .)
    +               reduce using rule 111 (append -> APPEND ( expresion ) .)
    -               reduce using rule 111 (append -> APPEND ( expresion ) .)
    EQ              reduce using rule 111 (append -> APPEND ( expresion ) .)
    NOTEQ           reduce using rule 111 (append -> APPEND ( expresion ) .)
    >               reduce using rule 111 (append -> APPEND ( expresion ) .)
    <               reduce using rule 111 (append -> APPEND ( expresion ) .)
    MTHANEQ         reduce using rule 111 (append -> APPEND ( expresion ) .)
    LTHANEQ         reduce using rule 111 (append -> APPEND ( expresion ) .)
    AND             reduce using rule 111 (append -> APPEND ( expresion ) .)
    OR              reduce using rule 111 (append -> APPEND ( expresion ) .)
    ;               reduce using rule 111 (append -> APPEND ( expresion ) .)
    )               reduce using rule 111 (append -> APPEND ( expresion ) .)
    ID              reduce using rule 111 (append -> APPEND ( expresion ) .)
    ,               reduce using rule 111 (append -> APPEND ( expresion ) .)


state 240

    (110) inlistset -> SET ( CTEE , expresion . )

    )               shift and go to state 241


state 241

    (110) inlistset -> SET ( CTEE , expresion ) .

    *               reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    /               reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    +               reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    -               reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    EQ              reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    NOTEQ           reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    >               reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    <               reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    MTHANEQ         reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    LTHANEQ         reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    AND             reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    OR              reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    ;               reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    )               reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    ID              reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)
    ,               reduce using rule 110 (inlistset -> SET ( CTEE , expresion ) .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 103 resolved as shift
WARNING: reduce/reduce conflict in state 13 resolved using rule (a -> empty)
WARNING: rejected rule (b -> empty) in state 13
WARNING: reduce/reduce conflict in state 24 resolved using rule (c -> empty)
WARNING: rejected rule (d -> empty) in state 24
WARNING: reduce/reduce conflict in state 50 resolved using rule (f -> empty)
WARNING: rejected rule (g -> empty) in state 50
WARNING: reduce/reduce conflict in state 83 resolved using rule (i -> empty)
WARNING: rejected rule (j -> empty) in state 83
WARNING: Rule (b -> empty) is never reduced
WARNING: Rule (d -> empty) is never reduced
WARNING: Rule (g -> empty) is never reduced
WARNING: Rule (j -> empty) is never reduced
