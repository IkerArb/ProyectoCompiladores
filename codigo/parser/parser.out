Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programa
Rule 1     programa -> creadirprocglobal a neur22 c cancion
Rule 2     creadirprocglobal -> <empty>
Rule 3     a -> empty
Rule 4     a -> vars b
Rule 5     b -> empty
Rule 6     b -> a
Rule 7     neur22 -> <empty>
Rule 8     c -> empty
Rule 9     c -> funcion d
Rule 10    d -> empty
Rule 11    d -> c
Rule 12    vars -> VAR v : tipo ;
Rule 13    v -> ID
Rule 14    funcion -> FUNC z ID meterfuncion ( params ) f neur23 bloque
Rule 15    z -> INT
Rule 16    z -> CHAR
Rule 17    z -> FLOAT
Rule 18    z -> BOOL
Rule 19    z -> VOID
Rule 20    meterfuncion -> <empty>
Rule 21    neur23 -> <empty>
Rule 22    f -> empty
Rule 23    f -> vars g
Rule 24    g -> empty
Rule 25    g -> f
Rule 26    params -> empty
Rule 27    params -> tipo ID meterparams h
Rule 28    meterparams -> <empty>
Rule 29    h -> empty
Rule 30    h -> , params
Rule 31    i -> empty
Rule 32    i -> estatuto j
Rule 33    j -> empty
Rule 34    j -> i
Rule 35    bloque -> { i }
Rule 36    cancion -> CANCION ( CTEE ) metercancion f bloque
Rule 37    metercancion -> <empty>
Rule 38    estatuto -> asignacion
Rule 39    estatuto -> if
Rule 40    estatuto -> for
Rule 41    estatuto -> return
Rule 42    estatuto -> while
Rule 43    estatuto -> play
Rule 44    estatuto -> print
Rule 45    estatuto -> callvoidfunc
Rule 46    asignacion -> ID = neur8 k ;
Rule 47    neur8 -> <empty>
Rule 48    k -> expresion
Rule 49    k -> asiglista
Rule 50    asiglista -> NEW LIST ( )
Rule 51    if -> IF ( expresion ) neur13 bloque l ; neur15
Rule 52    neur13 -> <empty>
Rule 53    l -> empty
Rule 54    l -> ELSE neur14 bloque
Rule 55    neur14 -> <empty>
Rule 56    neur15 -> <empty>
Rule 57    for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
Rule 58    neur18 -> <empty>
Rule 59    neur19 -> <empty>
Rule 60    neur21 -> <empty>
Rule 61    neur20 -> <empty>
Rule 62    expresion -> m subexpresion
Rule 63    m -> empty
Rule 64    m -> NOT
Rule 65    subexpresion -> exp neur10 o
Rule 66    neur10 -> <empty>
Rule 67    o -> empty
Rule 68    o -> AND neur9_1 subexpresion
Rule 69    o -> OR neur9_2 subexpresion
Rule 70    neur9_1 -> <empty>
Rule 71    neur9_2 -> <empty>
Rule 72    exp -> nexp p neur12
Rule 73    neur12 -> <empty>
Rule 74    p -> empty
Rule 75    p -> EQ neur11_1 nexp
Rule 76    p -> NOTEQ neur11_2 nexp
Rule 77    p -> > neur11_3 nexp
Rule 78    p -> < neur11_4 nexp
Rule 79    p -> MTHANEQ neur11_5 nexp
Rule 80    p -> LTHANEQ neur11_6 nexp
Rule 81    neur11_1 -> <empty>
Rule 82    neur11_2 -> <empty>
Rule 83    neur11_3 -> <empty>
Rule 84    neur11_4 -> <empty>
Rule 85    neur11_5 -> <empty>
Rule 86    neur11_6 -> <empty>
Rule 87    nexp -> termino neur5 q
Rule 88    neur5 -> <empty>
Rule 89    q -> empty
Rule 90    q -> + neur3_1 nexp
Rule 91    q -> - neur3_2 nexp
Rule 92    neur3_1 -> <empty>
Rule 93    neur3_2 -> <empty>
Rule 94    termino -> factor neur4 n
Rule 95    neur4 -> <empty>
Rule 96    n -> empty
Rule 97    n -> * neur2_1 termino
Rule 98    n -> / neur2_2 termino
Rule 99    neur2_1 -> <empty>
Rule 100   neur2_2 -> <empty>
Rule 101   factor -> ( neur6 expresion ) neur7
Rule 102   factor -> varcte
Rule 103   neur6 -> <empty>
Rule 104   neur7 -> <empty>
Rule 105   varcte -> ID r neurVar
Rule 106   varcte -> CTEE neurCteE
Rule 107   varcte -> CTEF neurCteF
Rule 108   varcte -> CTEBOOL neurCteB
Rule 109   varcte -> callreturnfunc
Rule 110   varcte -> CTECHAR neurCteCh
Rule 111   neurVar -> <empty>
Rule 112   neurCteE -> <empty>
Rule 113   neurCteF -> <empty>
Rule 114   neurCteB -> <empty>
Rule 115   neurCteCh -> <empty>
Rule 116   r -> empty
Rule 117   r -> oplista
Rule 118   oplista -> ID . x
Rule 119   x -> inlistset
Rule 120   x -> append
Rule 121   x -> length
Rule 122   x -> getlist
Rule 123   x -> removelist
Rule 124   inlistset -> SET ( CTEE , expresion )
Rule 125   append -> APPEND ( expresion )
Rule 126   length -> LENGTH ( )
Rule 127   getlist -> GET ( expresion )
Rule 128   removelist -> REMOVE ( expresion )
Rule 129   while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17
Rule 130   neur16 -> <empty>
Rule 131   neur17 -> <empty>
Rule 132   play -> PLAY ( NOTA , CTEE ) ;
Rule 133   print -> PRINT expresion ;
Rule 134   callreturnfunc -> CALL ID neur24 ( s ) neur26 ;
Rule 135   s -> empty
Rule 136   s -> expresion neur25 t
Rule 137   neur25 -> <empty>
Rule 138   t -> empty
Rule 139   t -> , s
Rule 140   callvoidfunc -> CALL ID neur24 ( s ) neur26 ;
Rule 141   neur24 -> <empty>
Rule 142   neur26 -> <empty>
Rule 143   return -> RETURN ( expresion ) ;
Rule 144   tipo -> u y
Rule 145   u -> empty
Rule 146   u -> LIST
Rule 147   y -> INT
Rule 148   y -> CHAR
Rule 149   y -> FLOAT
Rule 150   y -> BOOL
Rule 151   empty -> <empty>

Terminals, with rules where they appear

(                    : 14 36 50 51 57 101 124 125 126 127 128 129 132 134 140 143
)                    : 14 36 50 51 57 101 124 125 126 127 128 129 132 134 140 143
*                    : 97
+                    : 90
,                    : 30 124 132 139
-                    : 91
.                    : 118
/                    : 98
:                    : 12
;                    : 12 46 51 57 57 129 132 133 134 140 143
<                    : 78
=                    : 46
>                    : 77
AND                  : 68
APPEND               : 125
BOOL                 : 18 150
CALL                 : 134 140
CANCION              : 36
CHAR                 : 16 148
CTEBOOL              : 108
CTECHAR              : 110
CTEE                 : 36 106 124 132
CTEF                 : 107
ELSE                 : 54
EQ                   : 75
FLOAT                : 17 149
FOR                  : 57
FUNC                 : 14
GET                  : 127
ID                   : 13 14 27 46 105 118 134 140
IF                   : 51
INT                  : 15 147
LENGTH               : 126
LIST                 : 50 146
LTHANEQ              : 80
MTHANEQ              : 79
NEW                  : 50
NOT                  : 64
NOTA                 : 132
NOTEQ                : 76
OR                   : 69
PLAY                 : 132
PRINT                : 133
REMOVE               : 128
RETURN               : 143
SET                  : 124
VAR                  : 12
VOID                 : 19
WHILE                : 129
error                : 
{                    : 35
}                    : 35

Nonterminals, with rules where they appear

a                    : 1 6
append               : 120
asiglista            : 49
asignacion           : 38 57 57
b                    : 4
bloque               : 14 36 51 54 57 129
c                    : 1 11
callreturnfunc       : 109
callvoidfunc         : 45
cancion              : 1
creadirprocglobal    : 1
d                    : 9
empty                : 3 5 8 10 22 24 26 29 31 33 53 63 67 74 89 96 116 135 138 145
estatuto             : 32
exp                  : 65
expresion            : 48 51 57 101 124 125 127 128 129 133 136 143
f                    : 14 25 36
factor               : 94
for                  : 40
funcion              : 9
g                    : 23
getlist              : 122
h                    : 27
i                    : 34 35
if                   : 39
inlistset            : 119
j                    : 32
k                    : 46
l                    : 51
length               : 121
m                    : 62
metercancion         : 36
meterfuncion         : 14
meterparams          : 27
n                    : 94
neur10               : 65
neur11_1             : 75
neur11_2             : 76
neur11_3             : 77
neur11_4             : 78
neur11_5             : 79
neur11_6             : 80
neur12               : 72
neur13               : 51 129
neur14               : 54
neur15               : 51
neur16               : 129
neur17               : 129
neur18               : 57
neur19               : 57
neur20               : 57
neur21               : 57
neur22               : 1
neur23               : 14
neur24               : 134 140
neur25               : 136
neur26               : 134 140
neur2_1              : 97
neur2_2              : 98
neur3_1              : 90
neur3_2              : 91
neur4                : 94
neur5                : 87
neur6                : 101
neur7                : 101
neur8                : 46
neur9_1              : 68
neur9_2              : 69
neurCteB             : 108
neurCteCh            : 110
neurCteE             : 106
neurCteF             : 107
neurVar              : 105
nexp                 : 72 75 76 77 78 79 80 90 91
o                    : 65
oplista              : 117
p                    : 72
params               : 14 30
play                 : 43
print                : 44
programa             : 0
q                    : 87
r                    : 105
removelist           : 123
return               : 41
s                    : 134 139 140
subexpresion         : 62 68 69
t                    : 136
termino              : 87 97 98
tipo                 : 12 27
u                    : 144
v                    : 12
varcte               : 102
vars                 : 4 23
while                : 42
x                    : 118
y                    : 144
z                    : 14

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . creadirprocglobal a neur22 c cancion
    (2) creadirprocglobal -> .

    VAR             reduce using rule 2 (creadirprocglobal -> .)
    FUNC            reduce using rule 2 (creadirprocglobal -> .)
    CANCION         reduce using rule 2 (creadirprocglobal -> .)

    creadirprocglobal              shift and go to state 1
    programa                       shift and go to state 2

state 1

    (1) programa -> creadirprocglobal . a neur22 c cancion
    (3) a -> . empty
    (4) a -> . vars b
    (151) empty -> .
    (12) vars -> . VAR v : tipo ;

    FUNC            reduce using rule 151 (empty -> .)
    CANCION         reduce using rule 151 (empty -> .)
    VAR             shift and go to state 5

    a                              shift and go to state 3
    vars                           shift and go to state 4
    empty                          shift and go to state 6

state 2

    (0) S' -> programa .



state 3

    (1) programa -> creadirprocglobal a . neur22 c cancion
    (7) neur22 -> .

    FUNC            reduce using rule 7 (neur22 -> .)
    CANCION         reduce using rule 7 (neur22 -> .)

    neur22                         shift and go to state 7

state 4

    (4) a -> vars . b
    (5) b -> . empty
    (6) b -> . a
    (151) empty -> .
    (3) a -> . empty
    (4) a -> . vars b
    (12) vars -> . VAR v : tipo ;

    FUNC            reduce using rule 151 (empty -> .)
    CANCION         reduce using rule 151 (empty -> .)
    VAR             shift and go to state 5

    a                              shift and go to state 8
    b                              shift and go to state 9
    vars                           shift and go to state 4
    empty                          shift and go to state 10

state 5

    (12) vars -> VAR . v : tipo ;
    (13) v -> . ID

    ID              shift and go to state 12

    v                              shift and go to state 11

state 6

    (3) a -> empty .

    FUNC            reduce using rule 3 (a -> empty .)
    CANCION         reduce using rule 3 (a -> empty .)


state 7

    (1) programa -> creadirprocglobal a neur22 . c cancion
    (8) c -> . empty
    (9) c -> . funcion d
    (151) empty -> .
    (14) funcion -> . FUNC z ID meterfuncion ( params ) f neur23 bloque

    CANCION         reduce using rule 151 (empty -> .)
    FUNC            shift and go to state 14

    c                              shift and go to state 13
    empty                          shift and go to state 15
    funcion                        shift and go to state 16

state 8

    (6) b -> a .

    FUNC            reduce using rule 6 (b -> a .)
    CANCION         reduce using rule 6 (b -> a .)


state 9

    (4) a -> vars b .

    FUNC            reduce using rule 4 (a -> vars b .)
    CANCION         reduce using rule 4 (a -> vars b .)


state 10

    (5) b -> empty .
    (3) a -> empty .

  ! reduce/reduce conflict for FUNC resolved using rule 3 (a -> empty .)
  ! reduce/reduce conflict for CANCION resolved using rule 3 (a -> empty .)
    FUNC            reduce using rule 3 (a -> empty .)
    CANCION         reduce using rule 3 (a -> empty .)

  ! FUNC            [ reduce using rule 5 (b -> empty .) ]
  ! CANCION         [ reduce using rule 5 (b -> empty .) ]


state 11

    (12) vars -> VAR v . : tipo ;

    :               shift and go to state 17


state 12

    (13) v -> ID .

    :               reduce using rule 13 (v -> ID .)


state 13

    (1) programa -> creadirprocglobal a neur22 c . cancion
    (36) cancion -> . CANCION ( CTEE ) metercancion f bloque

    CANCION         shift and go to state 19

    cancion                        shift and go to state 18

state 14

    (14) funcion -> FUNC . z ID meterfuncion ( params ) f neur23 bloque
    (15) z -> . INT
    (16) z -> . CHAR
    (17) z -> . FLOAT
    (18) z -> . BOOL
    (19) z -> . VOID

    INT             shift and go to state 23
    CHAR            shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 24
    VOID            shift and go to state 20

    z                              shift and go to state 25

state 15

    (8) c -> empty .

    CANCION         reduce using rule 8 (c -> empty .)


state 16

    (9) c -> funcion . d
    (10) d -> . empty
    (11) d -> . c
    (151) empty -> .
    (8) c -> . empty
    (9) c -> . funcion d
    (14) funcion -> . FUNC z ID meterfuncion ( params ) f neur23 bloque

    CANCION         reduce using rule 151 (empty -> .)
    FUNC            shift and go to state 14

    c                              shift and go to state 26
    d                              shift and go to state 27
    empty                          shift and go to state 28
    funcion                        shift and go to state 16

state 17

    (12) vars -> VAR v : . tipo ;
    (144) tipo -> . u y
    (145) u -> . empty
    (146) u -> . LIST
    (151) empty -> .

    LIST            shift and go to state 30
    INT             reduce using rule 151 (empty -> .)
    CHAR            reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    BOOL            reduce using rule 151 (empty -> .)

    u                              shift and go to state 31
    empty                          shift and go to state 32
    tipo                           shift and go to state 29

state 18

    (1) programa -> creadirprocglobal a neur22 c cancion .

    $end            reduce using rule 1 (programa -> creadirprocglobal a neur22 c cancion .)


state 19

    (36) cancion -> CANCION . ( CTEE ) metercancion f bloque

    (               shift and go to state 33


state 20

    (19) z -> VOID .

    ID              reduce using rule 19 (z -> VOID .)


state 21

    (17) z -> FLOAT .

    ID              reduce using rule 17 (z -> FLOAT .)


state 22

    (16) z -> CHAR .

    ID              reduce using rule 16 (z -> CHAR .)


state 23

    (15) z -> INT .

    ID              reduce using rule 15 (z -> INT .)


state 24

    (18) z -> BOOL .

    ID              reduce using rule 18 (z -> BOOL .)


state 25

    (14) funcion -> FUNC z . ID meterfuncion ( params ) f neur23 bloque

    ID              shift and go to state 34


state 26

    (11) d -> c .

    CANCION         reduce using rule 11 (d -> c .)


state 27

    (9) c -> funcion d .

    CANCION         reduce using rule 9 (c -> funcion d .)


state 28

    (10) d -> empty .
    (8) c -> empty .

  ! reduce/reduce conflict for CANCION resolved using rule 8 (c -> empty .)
    CANCION         reduce using rule 8 (c -> empty .)

  ! CANCION         [ reduce using rule 10 (d -> empty .) ]


state 29

    (12) vars -> VAR v : tipo . ;

    ;               shift and go to state 35


state 30

    (146) u -> LIST .

    INT             reduce using rule 146 (u -> LIST .)
    CHAR            reduce using rule 146 (u -> LIST .)
    FLOAT           reduce using rule 146 (u -> LIST .)
    BOOL            reduce using rule 146 (u -> LIST .)


state 31

    (144) tipo -> u . y
    (147) y -> . INT
    (148) y -> . CHAR
    (149) y -> . FLOAT
    (150) y -> . BOOL

    INT             shift and go to state 36
    CHAR            shift and go to state 38
    FLOAT           shift and go to state 37
    BOOL            shift and go to state 40

    y                              shift and go to state 39

state 32

    (145) u -> empty .

    INT             reduce using rule 145 (u -> empty .)
    CHAR            reduce using rule 145 (u -> empty .)
    FLOAT           reduce using rule 145 (u -> empty .)
    BOOL            reduce using rule 145 (u -> empty .)


state 33

    (36) cancion -> CANCION ( . CTEE ) metercancion f bloque

    CTEE            shift and go to state 41


state 34

    (14) funcion -> FUNC z ID . meterfuncion ( params ) f neur23 bloque
    (20) meterfuncion -> .

    (               reduce using rule 20 (meterfuncion -> .)

    meterfuncion                   shift and go to state 42

state 35

    (12) vars -> VAR v : tipo ; .

    VAR             reduce using rule 12 (vars -> VAR v : tipo ; .)
    FUNC            reduce using rule 12 (vars -> VAR v : tipo ; .)
    CANCION         reduce using rule 12 (vars -> VAR v : tipo ; .)
    {               reduce using rule 12 (vars -> VAR v : tipo ; .)


state 36

    (147) y -> INT .

    ;               reduce using rule 147 (y -> INT .)
    ID              reduce using rule 147 (y -> INT .)


state 37

    (149) y -> FLOAT .

    ;               reduce using rule 149 (y -> FLOAT .)
    ID              reduce using rule 149 (y -> FLOAT .)


state 38

    (148) y -> CHAR .

    ;               reduce using rule 148 (y -> CHAR .)
    ID              reduce using rule 148 (y -> CHAR .)


state 39

    (144) tipo -> u y .

    ID              reduce using rule 144 (tipo -> u y .)
    ;               reduce using rule 144 (tipo -> u y .)


state 40

    (150) y -> BOOL .

    ;               reduce using rule 150 (y -> BOOL .)
    ID              reduce using rule 150 (y -> BOOL .)


state 41

    (36) cancion -> CANCION ( CTEE . ) metercancion f bloque

    )               shift and go to state 43


state 42

    (14) funcion -> FUNC z ID meterfuncion . ( params ) f neur23 bloque

    (               shift and go to state 44


state 43

    (36) cancion -> CANCION ( CTEE ) . metercancion f bloque
    (37) metercancion -> .

    VAR             reduce using rule 37 (metercancion -> .)
    {               reduce using rule 37 (metercancion -> .)

    metercancion                   shift and go to state 45

state 44

    (14) funcion -> FUNC z ID meterfuncion ( . params ) f neur23 bloque
    (26) params -> . empty
    (27) params -> . tipo ID meterparams h
    (151) empty -> .
    (144) tipo -> . u y
    (145) u -> . empty
    (146) u -> . LIST

    )               reduce using rule 151 (empty -> .)
    INT             reduce using rule 151 (empty -> .)
    CHAR            reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    BOOL            reduce using rule 151 (empty -> .)
    LIST            shift and go to state 30

    tipo                           shift and go to state 46
    params                         shift and go to state 47
    u                              shift and go to state 31
    empty                          shift and go to state 48

state 45

    (36) cancion -> CANCION ( CTEE ) metercancion . f bloque
    (22) f -> . empty
    (23) f -> . vars g
    (151) empty -> .
    (12) vars -> . VAR v : tipo ;

    {               reduce using rule 151 (empty -> .)
    VAR             shift and go to state 5

    vars                           shift and go to state 49
    f                              shift and go to state 50
    empty                          shift and go to state 51

state 46

    (27) params -> tipo . ID meterparams h

    ID              shift and go to state 52


state 47

    (14) funcion -> FUNC z ID meterfuncion ( params . ) f neur23 bloque

    )               shift and go to state 53


state 48

    (26) params -> empty .
    (145) u -> empty .

    )               reduce using rule 26 (params -> empty .)
    INT             reduce using rule 145 (u -> empty .)
    CHAR            reduce using rule 145 (u -> empty .)
    FLOAT           reduce using rule 145 (u -> empty .)
    BOOL            reduce using rule 145 (u -> empty .)


state 49

    (23) f -> vars . g
    (24) g -> . empty
    (25) g -> . f
    (151) empty -> .
    (22) f -> . empty
    (23) f -> . vars g
    (12) vars -> . VAR v : tipo ;

    {               reduce using rule 151 (empty -> .)
    VAR             shift and go to state 5

    g                              shift and go to state 54
    f                              shift and go to state 55
    vars                           shift and go to state 49
    empty                          shift and go to state 56

state 50

    (36) cancion -> CANCION ( CTEE ) metercancion f . bloque
    (35) bloque -> . { i }

    {               shift and go to state 57

    bloque                         shift and go to state 58

state 51

    (22) f -> empty .

    {               reduce using rule 22 (f -> empty .)


state 52

    (27) params -> tipo ID . meterparams h
    (28) meterparams -> .

    ,               reduce using rule 28 (meterparams -> .)
    )               reduce using rule 28 (meterparams -> .)

    meterparams                    shift and go to state 59

state 53

    (14) funcion -> FUNC z ID meterfuncion ( params ) . f neur23 bloque
    (22) f -> . empty
    (23) f -> . vars g
    (151) empty -> .
    (12) vars -> . VAR v : tipo ;

    {               reduce using rule 151 (empty -> .)
    VAR             shift and go to state 5

    vars                           shift and go to state 49
    f                              shift and go to state 60
    empty                          shift and go to state 51

state 54

    (23) f -> vars g .

    {               reduce using rule 23 (f -> vars g .)


state 55

    (25) g -> f .

    {               reduce using rule 25 (g -> f .)


state 56

    (24) g -> empty .
    (22) f -> empty .

  ! reduce/reduce conflict for { resolved using rule 22 (f -> empty .)
    {               reduce using rule 22 (f -> empty .)

  ! {               [ reduce using rule 24 (g -> empty .) ]


state 57

    (35) bloque -> { . i }
    (31) i -> . empty
    (32) i -> . estatuto j
    (151) empty -> .
    (38) estatuto -> . asignacion
    (39) estatuto -> . if
    (40) estatuto -> . for
    (41) estatuto -> . return
    (42) estatuto -> . while
    (43) estatuto -> . play
    (44) estatuto -> . print
    (45) estatuto -> . callvoidfunc
    (46) asignacion -> . ID = neur8 k ;
    (51) if -> . IF ( expresion ) neur13 bloque l ; neur15
    (57) for -> . FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (143) return -> . RETURN ( expresion ) ;
    (129) while -> . WHILE ( neur16 expresion ) neur13 bloque ; neur17
    (132) play -> . PLAY ( NOTA , CTEE ) ;
    (133) print -> . PRINT expresion ;
    (140) callvoidfunc -> . CALL ID neur24 ( s ) neur26 ;

    }               reduce using rule 151 (empty -> .)
    ID              shift and go to state 75
    IF              shift and go to state 76
    FOR             shift and go to state 74
    RETURN          shift and go to state 61
    WHILE           shift and go to state 62
    PLAY            shift and go to state 71
    PRINT           shift and go to state 63
    CALL            shift and go to state 69

    if                             shift and go to state 64
    for                            shift and go to state 65
    callvoidfunc                   shift and go to state 66
    estatuto                       shift and go to state 67
    print                          shift and go to state 68
    empty                          shift and go to state 70
    play                           shift and go to state 72
    return                         shift and go to state 73
    asignacion                     shift and go to state 77
    i                              shift and go to state 78
    while                          shift and go to state 79

state 58

    (36) cancion -> CANCION ( CTEE ) metercancion f bloque .

    $end            reduce using rule 36 (cancion -> CANCION ( CTEE ) metercancion f bloque .)


state 59

    (27) params -> tipo ID meterparams . h
    (29) h -> . empty
    (30) h -> . , params
    (151) empty -> .

    ,               shift and go to state 81
    )               reduce using rule 151 (empty -> .)

    h                              shift and go to state 80
    empty                          shift and go to state 82

state 60

    (14) funcion -> FUNC z ID meterfuncion ( params ) f . neur23 bloque
    (21) neur23 -> .

    {               reduce using rule 21 (neur23 -> .)

    neur23                         shift and go to state 83

state 61

    (143) return -> RETURN . ( expresion ) ;

    (               shift and go to state 84


state 62

    (129) while -> WHILE . ( neur16 expresion ) neur13 bloque ; neur17

    (               shift and go to state 85


state 63

    (133) print -> PRINT . expresion ;
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (151) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 151 (empty -> .)
    ID              reduce using rule 151 (empty -> .)
    CTEE            reduce using rule 151 (empty -> .)
    CTEF            reduce using rule 151 (empty -> .)
    CTEBOOL         reduce using rule 151 (empty -> .)
    CTECHAR         reduce using rule 151 (empty -> .)
    CALL            reduce using rule 151 (empty -> .)

    expresion                      shift and go to state 86
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 64

    (39) estatuto -> if .

    ID              reduce using rule 39 (estatuto -> if .)
    IF              reduce using rule 39 (estatuto -> if .)
    FOR             reduce using rule 39 (estatuto -> if .)
    RETURN          reduce using rule 39 (estatuto -> if .)
    WHILE           reduce using rule 39 (estatuto -> if .)
    PLAY            reduce using rule 39 (estatuto -> if .)
    PRINT           reduce using rule 39 (estatuto -> if .)
    CALL            reduce using rule 39 (estatuto -> if .)
    }               reduce using rule 39 (estatuto -> if .)


state 65

    (40) estatuto -> for .

    ID              reduce using rule 40 (estatuto -> for .)
    IF              reduce using rule 40 (estatuto -> for .)
    FOR             reduce using rule 40 (estatuto -> for .)
    RETURN          reduce using rule 40 (estatuto -> for .)
    WHILE           reduce using rule 40 (estatuto -> for .)
    PLAY            reduce using rule 40 (estatuto -> for .)
    PRINT           reduce using rule 40 (estatuto -> for .)
    CALL            reduce using rule 40 (estatuto -> for .)
    }               reduce using rule 40 (estatuto -> for .)


state 66

    (45) estatuto -> callvoidfunc .

    ID              reduce using rule 45 (estatuto -> callvoidfunc .)
    IF              reduce using rule 45 (estatuto -> callvoidfunc .)
    FOR             reduce using rule 45 (estatuto -> callvoidfunc .)
    RETURN          reduce using rule 45 (estatuto -> callvoidfunc .)
    WHILE           reduce using rule 45 (estatuto -> callvoidfunc .)
    PLAY            reduce using rule 45 (estatuto -> callvoidfunc .)
    PRINT           reduce using rule 45 (estatuto -> callvoidfunc .)
    CALL            reduce using rule 45 (estatuto -> callvoidfunc .)
    }               reduce using rule 45 (estatuto -> callvoidfunc .)


state 67

    (32) i -> estatuto . j
    (33) j -> . empty
    (34) j -> . i
    (151) empty -> .
    (31) i -> . empty
    (32) i -> . estatuto j
    (38) estatuto -> . asignacion
    (39) estatuto -> . if
    (40) estatuto -> . for
    (41) estatuto -> . return
    (42) estatuto -> . while
    (43) estatuto -> . play
    (44) estatuto -> . print
    (45) estatuto -> . callvoidfunc
    (46) asignacion -> . ID = neur8 k ;
    (51) if -> . IF ( expresion ) neur13 bloque l ; neur15
    (57) for -> . FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (143) return -> . RETURN ( expresion ) ;
    (129) while -> . WHILE ( neur16 expresion ) neur13 bloque ; neur17
    (132) play -> . PLAY ( NOTA , CTEE ) ;
    (133) print -> . PRINT expresion ;
    (140) callvoidfunc -> . CALL ID neur24 ( s ) neur26 ;

    }               reduce using rule 151 (empty -> .)
    ID              shift and go to state 75
    IF              shift and go to state 76
    FOR             shift and go to state 74
    RETURN          shift and go to state 61
    WHILE           shift and go to state 62
    PLAY            shift and go to state 71
    PRINT           shift and go to state 63
    CALL            shift and go to state 69

    if                             shift and go to state 64
    for                            shift and go to state 65
    callvoidfunc                   shift and go to state 66
    estatuto                       shift and go to state 67
    print                          shift and go to state 68
    empty                          shift and go to state 90
    play                           shift and go to state 72
    return                         shift and go to state 73
    asignacion                     shift and go to state 77
    i                              shift and go to state 91
    j                              shift and go to state 92
    while                          shift and go to state 79

state 68

    (44) estatuto -> print .

    ID              reduce using rule 44 (estatuto -> print .)
    IF              reduce using rule 44 (estatuto -> print .)
    FOR             reduce using rule 44 (estatuto -> print .)
    RETURN          reduce using rule 44 (estatuto -> print .)
    WHILE           reduce using rule 44 (estatuto -> print .)
    PLAY            reduce using rule 44 (estatuto -> print .)
    PRINT           reduce using rule 44 (estatuto -> print .)
    CALL            reduce using rule 44 (estatuto -> print .)
    }               reduce using rule 44 (estatuto -> print .)


state 69

    (140) callvoidfunc -> CALL . ID neur24 ( s ) neur26 ;

    ID              shift and go to state 93


state 70

    (31) i -> empty .

    }               reduce using rule 31 (i -> empty .)


state 71

    (132) play -> PLAY . ( NOTA , CTEE ) ;

    (               shift and go to state 94


state 72

    (43) estatuto -> play .

    ID              reduce using rule 43 (estatuto -> play .)
    IF              reduce using rule 43 (estatuto -> play .)
    FOR             reduce using rule 43 (estatuto -> play .)
    RETURN          reduce using rule 43 (estatuto -> play .)
    WHILE           reduce using rule 43 (estatuto -> play .)
    PLAY            reduce using rule 43 (estatuto -> play .)
    PRINT           reduce using rule 43 (estatuto -> play .)
    CALL            reduce using rule 43 (estatuto -> play .)
    }               reduce using rule 43 (estatuto -> play .)


state 73

    (41) estatuto -> return .

    ID              reduce using rule 41 (estatuto -> return .)
    IF              reduce using rule 41 (estatuto -> return .)
    FOR             reduce using rule 41 (estatuto -> return .)
    RETURN          reduce using rule 41 (estatuto -> return .)
    WHILE           reduce using rule 41 (estatuto -> return .)
    PLAY            reduce using rule 41 (estatuto -> return .)
    PRINT           reduce using rule 41 (estatuto -> return .)
    CALL            reduce using rule 41 (estatuto -> return .)
    }               reduce using rule 41 (estatuto -> return .)


state 74

    (57) for -> FOR . ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20

    (               shift and go to state 95


state 75

    (46) asignacion -> ID . = neur8 k ;

    =               shift and go to state 96


state 76

    (51) if -> IF . ( expresion ) neur13 bloque l ; neur15

    (               shift and go to state 97


state 77

    (38) estatuto -> asignacion .

    ID              reduce using rule 38 (estatuto -> asignacion .)
    IF              reduce using rule 38 (estatuto -> asignacion .)
    FOR             reduce using rule 38 (estatuto -> asignacion .)
    RETURN          reduce using rule 38 (estatuto -> asignacion .)
    WHILE           reduce using rule 38 (estatuto -> asignacion .)
    PLAY            reduce using rule 38 (estatuto -> asignacion .)
    PRINT           reduce using rule 38 (estatuto -> asignacion .)
    CALL            reduce using rule 38 (estatuto -> asignacion .)
    }               reduce using rule 38 (estatuto -> asignacion .)


state 78

    (35) bloque -> { i . }

    }               shift and go to state 98


state 79

    (42) estatuto -> while .

    ID              reduce using rule 42 (estatuto -> while .)
    IF              reduce using rule 42 (estatuto -> while .)
    FOR             reduce using rule 42 (estatuto -> while .)
    RETURN          reduce using rule 42 (estatuto -> while .)
    WHILE           reduce using rule 42 (estatuto -> while .)
    PLAY            reduce using rule 42 (estatuto -> while .)
    PRINT           reduce using rule 42 (estatuto -> while .)
    CALL            reduce using rule 42 (estatuto -> while .)
    }               reduce using rule 42 (estatuto -> while .)


state 80

    (27) params -> tipo ID meterparams h .

    )               reduce using rule 27 (params -> tipo ID meterparams h .)


state 81

    (30) h -> , . params
    (26) params -> . empty
    (27) params -> . tipo ID meterparams h
    (151) empty -> .
    (144) tipo -> . u y
    (145) u -> . empty
    (146) u -> . LIST

    )               reduce using rule 151 (empty -> .)
    INT             reduce using rule 151 (empty -> .)
    CHAR            reduce using rule 151 (empty -> .)
    FLOAT           reduce using rule 151 (empty -> .)
    BOOL            reduce using rule 151 (empty -> .)
    LIST            shift and go to state 30

    tipo                           shift and go to state 46
    u                              shift and go to state 31
    params                         shift and go to state 99
    empty                          shift and go to state 48

state 82

    (29) h -> empty .

    )               reduce using rule 29 (h -> empty .)


state 83

    (14) funcion -> FUNC z ID meterfuncion ( params ) f neur23 . bloque
    (35) bloque -> . { i }

    {               shift and go to state 57

    bloque                         shift and go to state 100

state 84

    (143) return -> RETURN ( . expresion ) ;
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (151) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 151 (empty -> .)
    ID              reduce using rule 151 (empty -> .)
    CTEE            reduce using rule 151 (empty -> .)
    CTEF            reduce using rule 151 (empty -> .)
    CTEBOOL         reduce using rule 151 (empty -> .)
    CTECHAR         reduce using rule 151 (empty -> .)
    CALL            reduce using rule 151 (empty -> .)

    expresion                      shift and go to state 101
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 85

    (129) while -> WHILE ( . neur16 expresion ) neur13 bloque ; neur17
    (130) neur16 -> .

    NOT             reduce using rule 130 (neur16 -> .)
    (               reduce using rule 130 (neur16 -> .)
    ID              reduce using rule 130 (neur16 -> .)
    CTEE            reduce using rule 130 (neur16 -> .)
    CTEF            reduce using rule 130 (neur16 -> .)
    CTEBOOL         reduce using rule 130 (neur16 -> .)
    CTECHAR         reduce using rule 130 (neur16 -> .)
    CALL            reduce using rule 130 (neur16 -> .)

    neur16                         shift and go to state 102

state 86

    (133) print -> PRINT expresion . ;

    ;               shift and go to state 103


state 87

    (62) expresion -> m . subexpresion
    (65) subexpresion -> . exp neur10 o
    (72) exp -> . nexp p neur12
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte
    (105) varcte -> . ID r neurVar
    (106) varcte -> . CTEE neurCteE
    (107) varcte -> . CTEF neurCteF
    (108) varcte -> . CTEBOOL neurCteB
    (109) varcte -> . callreturnfunc
    (110) varcte -> . CTECHAR neurCteCh
    (134) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 108
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110
    subexpresion                   shift and go to state 112
    exp                            shift and go to state 116

state 88

    (64) m -> NOT .

    (               reduce using rule 64 (m -> NOT .)
    ID              reduce using rule 64 (m -> NOT .)
    CTEE            reduce using rule 64 (m -> NOT .)
    CTEF            reduce using rule 64 (m -> NOT .)
    CTEBOOL         reduce using rule 64 (m -> NOT .)
    CTECHAR         reduce using rule 64 (m -> NOT .)
    CALL            reduce using rule 64 (m -> NOT .)


state 89

    (63) m -> empty .

    (               reduce using rule 63 (m -> empty .)
    ID              reduce using rule 63 (m -> empty .)
    CTEE            reduce using rule 63 (m -> empty .)
    CTEF            reduce using rule 63 (m -> empty .)
    CTEBOOL         reduce using rule 63 (m -> empty .)
    CTECHAR         reduce using rule 63 (m -> empty .)
    CALL            reduce using rule 63 (m -> empty .)


state 90

    (33) j -> empty .
    (31) i -> empty .

  ! reduce/reduce conflict for } resolved using rule 31 (i -> empty .)
    }               reduce using rule 31 (i -> empty .)

  ! }               [ reduce using rule 33 (j -> empty .) ]


state 91

    (34) j -> i .

    }               reduce using rule 34 (j -> i .)


state 92

    (32) i -> estatuto j .

    }               reduce using rule 32 (i -> estatuto j .)


state 93

    (140) callvoidfunc -> CALL ID . neur24 ( s ) neur26 ;
    (141) neur24 -> .

    (               reduce using rule 141 (neur24 -> .)

    neur24                         shift and go to state 118

state 94

    (132) play -> PLAY ( . NOTA , CTEE ) ;

    NOTA            shift and go to state 119


state 95

    (57) for -> FOR ( . asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (46) asignacion -> . ID = neur8 k ;

    ID              shift and go to state 75

    asignacion                     shift and go to state 120

state 96

    (46) asignacion -> ID = . neur8 k ;
    (47) neur8 -> .

    NEW             reduce using rule 47 (neur8 -> .)
    NOT             reduce using rule 47 (neur8 -> .)
    (               reduce using rule 47 (neur8 -> .)
    ID              reduce using rule 47 (neur8 -> .)
    CTEE            reduce using rule 47 (neur8 -> .)
    CTEF            reduce using rule 47 (neur8 -> .)
    CTEBOOL         reduce using rule 47 (neur8 -> .)
    CTECHAR         reduce using rule 47 (neur8 -> .)
    CALL            reduce using rule 47 (neur8 -> .)

    neur8                          shift and go to state 121

state 97

    (51) if -> IF ( . expresion ) neur13 bloque l ; neur15
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (151) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 151 (empty -> .)
    ID              reduce using rule 151 (empty -> .)
    CTEE            reduce using rule 151 (empty -> .)
    CTEF            reduce using rule 151 (empty -> .)
    CTEBOOL         reduce using rule 151 (empty -> .)
    CTECHAR         reduce using rule 151 (empty -> .)
    CALL            reduce using rule 151 (empty -> .)

    expresion                      shift and go to state 122
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 98

    (35) bloque -> { i } .

    ;               reduce using rule 35 (bloque -> { i } .)
    $end            reduce using rule 35 (bloque -> { i } .)
    FUNC            reduce using rule 35 (bloque -> { i } .)
    CANCION         reduce using rule 35 (bloque -> { i } .)
    ELSE            reduce using rule 35 (bloque -> { i } .)


state 99

    (30) h -> , params .

    )               reduce using rule 30 (h -> , params .)


state 100

    (14) funcion -> FUNC z ID meterfuncion ( params ) f neur23 bloque .

    FUNC            reduce using rule 14 (funcion -> FUNC z ID meterfuncion ( params ) f neur23 bloque .)
    CANCION         reduce using rule 14 (funcion -> FUNC z ID meterfuncion ( params ) f neur23 bloque .)


state 101

    (143) return -> RETURN ( expresion . ) ;

    )               shift and go to state 123


state 102

    (129) while -> WHILE ( neur16 . expresion ) neur13 bloque ; neur17
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (151) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 151 (empty -> .)
    ID              reduce using rule 151 (empty -> .)
    CTEE            reduce using rule 151 (empty -> .)
    CTEF            reduce using rule 151 (empty -> .)
    CTEBOOL         reduce using rule 151 (empty -> .)
    CTECHAR         reduce using rule 151 (empty -> .)
    CALL            reduce using rule 151 (empty -> .)

    expresion                      shift and go to state 124
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 103

    (133) print -> PRINT expresion ; .

    ID              reduce using rule 133 (print -> PRINT expresion ; .)
    IF              reduce using rule 133 (print -> PRINT expresion ; .)
    FOR             reduce using rule 133 (print -> PRINT expresion ; .)
    RETURN          reduce using rule 133 (print -> PRINT expresion ; .)
    WHILE           reduce using rule 133 (print -> PRINT expresion ; .)
    PLAY            reduce using rule 133 (print -> PRINT expresion ; .)
    PRINT           reduce using rule 133 (print -> PRINT expresion ; .)
    CALL            reduce using rule 133 (print -> PRINT expresion ; .)
    }               reduce using rule 133 (print -> PRINT expresion ; .)


state 104

    (87) nexp -> termino . neur5 q
    (88) neur5 -> .

    +               reduce using rule 88 (neur5 -> .)
    -               reduce using rule 88 (neur5 -> .)
    EQ              reduce using rule 88 (neur5 -> .)
    NOTEQ           reduce using rule 88 (neur5 -> .)
    >               reduce using rule 88 (neur5 -> .)
    <               reduce using rule 88 (neur5 -> .)
    MTHANEQ         reduce using rule 88 (neur5 -> .)
    LTHANEQ         reduce using rule 88 (neur5 -> .)
    AND             reduce using rule 88 (neur5 -> .)
    OR              reduce using rule 88 (neur5 -> .)
    ;               reduce using rule 88 (neur5 -> .)
    )               reduce using rule 88 (neur5 -> .)
    ,               reduce using rule 88 (neur5 -> .)

    neur5                          shift and go to state 125

state 105

    (110) varcte -> CTECHAR . neurCteCh
    (115) neurCteCh -> .

    *               reduce using rule 115 (neurCteCh -> .)
    /               reduce using rule 115 (neurCteCh -> .)
    +               reduce using rule 115 (neurCteCh -> .)
    -               reduce using rule 115 (neurCteCh -> .)
    EQ              reduce using rule 115 (neurCteCh -> .)
    NOTEQ           reduce using rule 115 (neurCteCh -> .)
    >               reduce using rule 115 (neurCteCh -> .)
    <               reduce using rule 115 (neurCteCh -> .)
    MTHANEQ         reduce using rule 115 (neurCteCh -> .)
    LTHANEQ         reduce using rule 115 (neurCteCh -> .)
    AND             reduce using rule 115 (neurCteCh -> .)
    OR              reduce using rule 115 (neurCteCh -> .)
    ;               reduce using rule 115 (neurCteCh -> .)
    )               reduce using rule 115 (neurCteCh -> .)
    ,               reduce using rule 115 (neurCteCh -> .)

    neurCteCh                      shift and go to state 126

state 106

    (102) factor -> varcte .

    *               reduce using rule 102 (factor -> varcte .)
    /               reduce using rule 102 (factor -> varcte .)
    +               reduce using rule 102 (factor -> varcte .)
    -               reduce using rule 102 (factor -> varcte .)
    EQ              reduce using rule 102 (factor -> varcte .)
    NOTEQ           reduce using rule 102 (factor -> varcte .)
    >               reduce using rule 102 (factor -> varcte .)
    <               reduce using rule 102 (factor -> varcte .)
    MTHANEQ         reduce using rule 102 (factor -> varcte .)
    LTHANEQ         reduce using rule 102 (factor -> varcte .)
    AND             reduce using rule 102 (factor -> varcte .)
    OR              reduce using rule 102 (factor -> varcte .)
    ;               reduce using rule 102 (factor -> varcte .)
    )               reduce using rule 102 (factor -> varcte .)
    ,               reduce using rule 102 (factor -> varcte .)


state 107

    (101) factor -> ( . neur6 expresion ) neur7
    (103) neur6 -> .

    NOT             reduce using rule 103 (neur6 -> .)
    (               reduce using rule 103 (neur6 -> .)
    ID              reduce using rule 103 (neur6 -> .)
    CTEE            reduce using rule 103 (neur6 -> .)
    CTEF            reduce using rule 103 (neur6 -> .)
    CTEBOOL         reduce using rule 103 (neur6 -> .)
    CTECHAR         reduce using rule 103 (neur6 -> .)
    CALL            reduce using rule 103 (neur6 -> .)

    neur6                          shift and go to state 127

state 108

    (72) exp -> nexp . p neur12
    (74) p -> . empty
    (75) p -> . EQ neur11_1 nexp
    (76) p -> . NOTEQ neur11_2 nexp
    (77) p -> . > neur11_3 nexp
    (78) p -> . < neur11_4 nexp
    (79) p -> . MTHANEQ neur11_5 nexp
    (80) p -> . LTHANEQ neur11_6 nexp
    (151) empty -> .

    EQ              shift and go to state 132
    NOTEQ           shift and go to state 131
    >               shift and go to state 135
    <               shift and go to state 133
    MTHANEQ         shift and go to state 128
    LTHANEQ         shift and go to state 130
    AND             reduce using rule 151 (empty -> .)
    OR              reduce using rule 151 (empty -> .)
    ;               reduce using rule 151 (empty -> .)
    )               reduce using rule 151 (empty -> .)
    ,               reduce using rule 151 (empty -> .)

    p                              shift and go to state 129
    empty                          shift and go to state 134

state 109

    (109) varcte -> callreturnfunc .

    *               reduce using rule 109 (varcte -> callreturnfunc .)
    /               reduce using rule 109 (varcte -> callreturnfunc .)
    +               reduce using rule 109 (varcte -> callreturnfunc .)
    -               reduce using rule 109 (varcte -> callreturnfunc .)
    AND             reduce using rule 109 (varcte -> callreturnfunc .)
    OR              reduce using rule 109 (varcte -> callreturnfunc .)
    ;               reduce using rule 109 (varcte -> callreturnfunc .)
    )               reduce using rule 109 (varcte -> callreturnfunc .)
    ,               reduce using rule 109 (varcte -> callreturnfunc .)
    EQ              reduce using rule 109 (varcte -> callreturnfunc .)
    NOTEQ           reduce using rule 109 (varcte -> callreturnfunc .)
    >               reduce using rule 109 (varcte -> callreturnfunc .)
    <               reduce using rule 109 (varcte -> callreturnfunc .)
    MTHANEQ         reduce using rule 109 (varcte -> callreturnfunc .)
    LTHANEQ         reduce using rule 109 (varcte -> callreturnfunc .)


state 110

    (94) termino -> factor . neur4 n
    (95) neur4 -> .

    *               reduce using rule 95 (neur4 -> .)
    /               reduce using rule 95 (neur4 -> .)
    +               reduce using rule 95 (neur4 -> .)
    -               reduce using rule 95 (neur4 -> .)
    EQ              reduce using rule 95 (neur4 -> .)
    NOTEQ           reduce using rule 95 (neur4 -> .)
    >               reduce using rule 95 (neur4 -> .)
    <               reduce using rule 95 (neur4 -> .)
    MTHANEQ         reduce using rule 95 (neur4 -> .)
    LTHANEQ         reduce using rule 95 (neur4 -> .)
    AND             reduce using rule 95 (neur4 -> .)
    OR              reduce using rule 95 (neur4 -> .)
    ;               reduce using rule 95 (neur4 -> .)
    )               reduce using rule 95 (neur4 -> .)
    ,               reduce using rule 95 (neur4 -> .)

    neur4                          shift and go to state 136

state 111

    (134) callreturnfunc -> CALL . ID neur24 ( s ) neur26 ;

    ID              shift and go to state 137


state 112

    (62) expresion -> m subexpresion .

    )               reduce using rule 62 (expresion -> m subexpresion .)
    ,               reduce using rule 62 (expresion -> m subexpresion .)
    ;               reduce using rule 62 (expresion -> m subexpresion .)


state 113

    (105) varcte -> ID . r neurVar
    (116) r -> . empty
    (117) r -> . oplista
    (151) empty -> .
    (118) oplista -> . ID . x

    *               reduce using rule 151 (empty -> .)
    /               reduce using rule 151 (empty -> .)
    +               reduce using rule 151 (empty -> .)
    -               reduce using rule 151 (empty -> .)
    EQ              reduce using rule 151 (empty -> .)
    NOTEQ           reduce using rule 151 (empty -> .)
    >               reduce using rule 151 (empty -> .)
    <               reduce using rule 151 (empty -> .)
    MTHANEQ         reduce using rule 151 (empty -> .)
    LTHANEQ         reduce using rule 151 (empty -> .)
    AND             reduce using rule 151 (empty -> .)
    OR              reduce using rule 151 (empty -> .)
    ;               reduce using rule 151 (empty -> .)
    )               reduce using rule 151 (empty -> .)
    ,               reduce using rule 151 (empty -> .)
    ID              shift and go to state 140

    oplista                        shift and go to state 138
    r                              shift and go to state 139
    empty                          shift and go to state 141

state 114

    (108) varcte -> CTEBOOL . neurCteB
    (114) neurCteB -> .

    *               reduce using rule 114 (neurCteB -> .)
    /               reduce using rule 114 (neurCteB -> .)
    +               reduce using rule 114 (neurCteB -> .)
    -               reduce using rule 114 (neurCteB -> .)
    EQ              reduce using rule 114 (neurCteB -> .)
    NOTEQ           reduce using rule 114 (neurCteB -> .)
    >               reduce using rule 114 (neurCteB -> .)
    <               reduce using rule 114 (neurCteB -> .)
    MTHANEQ         reduce using rule 114 (neurCteB -> .)
    LTHANEQ         reduce using rule 114 (neurCteB -> .)
    AND             reduce using rule 114 (neurCteB -> .)
    OR              reduce using rule 114 (neurCteB -> .)
    ;               reduce using rule 114 (neurCteB -> .)
    )               reduce using rule 114 (neurCteB -> .)
    ,               reduce using rule 114 (neurCteB -> .)

    neurCteB                       shift and go to state 142

state 115

    (107) varcte -> CTEF . neurCteF
    (113) neurCteF -> .

    *               reduce using rule 113 (neurCteF -> .)
    /               reduce using rule 113 (neurCteF -> .)
    +               reduce using rule 113 (neurCteF -> .)
    -               reduce using rule 113 (neurCteF -> .)
    EQ              reduce using rule 113 (neurCteF -> .)
    NOTEQ           reduce using rule 113 (neurCteF -> .)
    >               reduce using rule 113 (neurCteF -> .)
    <               reduce using rule 113 (neurCteF -> .)
    MTHANEQ         reduce using rule 113 (neurCteF -> .)
    LTHANEQ         reduce using rule 113 (neurCteF -> .)
    AND             reduce using rule 113 (neurCteF -> .)
    OR              reduce using rule 113 (neurCteF -> .)
    ;               reduce using rule 113 (neurCteF -> .)
    )               reduce using rule 113 (neurCteF -> .)
    ,               reduce using rule 113 (neurCteF -> .)

    neurCteF                       shift and go to state 143

state 116

    (65) subexpresion -> exp . neur10 o
    (66) neur10 -> .

    AND             reduce using rule 66 (neur10 -> .)
    OR              reduce using rule 66 (neur10 -> .)
    ;               reduce using rule 66 (neur10 -> .)
    )               reduce using rule 66 (neur10 -> .)
    ,               reduce using rule 66 (neur10 -> .)

    neur10                         shift and go to state 144

state 117

    (106) varcte -> CTEE . neurCteE
    (112) neurCteE -> .

    *               reduce using rule 112 (neurCteE -> .)
    /               reduce using rule 112 (neurCteE -> .)
    +               reduce using rule 112 (neurCteE -> .)
    -               reduce using rule 112 (neurCteE -> .)
    EQ              reduce using rule 112 (neurCteE -> .)
    NOTEQ           reduce using rule 112 (neurCteE -> .)
    >               reduce using rule 112 (neurCteE -> .)
    <               reduce using rule 112 (neurCteE -> .)
    MTHANEQ         reduce using rule 112 (neurCteE -> .)
    LTHANEQ         reduce using rule 112 (neurCteE -> .)
    AND             reduce using rule 112 (neurCteE -> .)
    OR              reduce using rule 112 (neurCteE -> .)
    ;               reduce using rule 112 (neurCteE -> .)
    )               reduce using rule 112 (neurCteE -> .)
    ,               reduce using rule 112 (neurCteE -> .)

    neurCteE                       shift and go to state 145

state 118

    (140) callvoidfunc -> CALL ID neur24 . ( s ) neur26 ;

    (               shift and go to state 146


state 119

    (132) play -> PLAY ( NOTA . , CTEE ) ;

    ,               shift and go to state 147


state 120

    (57) for -> FOR ( asignacion . neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (58) neur18 -> .

    NOT             reduce using rule 58 (neur18 -> .)
    (               reduce using rule 58 (neur18 -> .)
    ID              reduce using rule 58 (neur18 -> .)
    CTEE            reduce using rule 58 (neur18 -> .)
    CTEF            reduce using rule 58 (neur18 -> .)
    CTEBOOL         reduce using rule 58 (neur18 -> .)
    CTECHAR         reduce using rule 58 (neur18 -> .)
    CALL            reduce using rule 58 (neur18 -> .)

    neur18                         shift and go to state 148

state 121

    (46) asignacion -> ID = neur8 . k ;
    (48) k -> . expresion
    (49) k -> . asiglista
    (62) expresion -> . m subexpresion
    (50) asiglista -> . NEW LIST ( )
    (63) m -> . empty
    (64) m -> . NOT
    (151) empty -> .

    NEW             shift and go to state 152
    NOT             shift and go to state 88
    (               reduce using rule 151 (empty -> .)
    ID              reduce using rule 151 (empty -> .)
    CTEE            reduce using rule 151 (empty -> .)
    CTEF            reduce using rule 151 (empty -> .)
    CTEBOOL         reduce using rule 151 (empty -> .)
    CTECHAR         reduce using rule 151 (empty -> .)
    CALL            reduce using rule 151 (empty -> .)

    expresion                      shift and go to state 149
    k                              shift and go to state 150
    m                              shift and go to state 87
    asiglista                      shift and go to state 151
    empty                          shift and go to state 89

state 122

    (51) if -> IF ( expresion . ) neur13 bloque l ; neur15

    )               shift and go to state 153


state 123

    (143) return -> RETURN ( expresion ) . ;

    ;               shift and go to state 154


state 124

    (129) while -> WHILE ( neur16 expresion . ) neur13 bloque ; neur17

    )               shift and go to state 155


state 125

    (87) nexp -> termino neur5 . q
    (89) q -> . empty
    (90) q -> . + neur3_1 nexp
    (91) q -> . - neur3_2 nexp
    (151) empty -> .

    +               shift and go to state 156
    -               shift and go to state 157
    EQ              reduce using rule 151 (empty -> .)
    NOTEQ           reduce using rule 151 (empty -> .)
    >               reduce using rule 151 (empty -> .)
    <               reduce using rule 151 (empty -> .)
    MTHANEQ         reduce using rule 151 (empty -> .)
    LTHANEQ         reduce using rule 151 (empty -> .)
    AND             reduce using rule 151 (empty -> .)
    OR              reduce using rule 151 (empty -> .)
    ;               reduce using rule 151 (empty -> .)
    )               reduce using rule 151 (empty -> .)
    ,               reduce using rule 151 (empty -> .)

    q                              shift and go to state 158
    empty                          shift and go to state 159

state 126

    (110) varcte -> CTECHAR neurCteCh .

    *               reduce using rule 110 (varcte -> CTECHAR neurCteCh .)
    /               reduce using rule 110 (varcte -> CTECHAR neurCteCh .)
    +               reduce using rule 110 (varcte -> CTECHAR neurCteCh .)
    -               reduce using rule 110 (varcte -> CTECHAR neurCteCh .)
    AND             reduce using rule 110 (varcte -> CTECHAR neurCteCh .)
    OR              reduce using rule 110 (varcte -> CTECHAR neurCteCh .)
    ;               reduce using rule 110 (varcte -> CTECHAR neurCteCh .)
    )               reduce using rule 110 (varcte -> CTECHAR neurCteCh .)
    ,               reduce using rule 110 (varcte -> CTECHAR neurCteCh .)
    EQ              reduce using rule 110 (varcte -> CTECHAR neurCteCh .)
    NOTEQ           reduce using rule 110 (varcte -> CTECHAR neurCteCh .)
    >               reduce using rule 110 (varcte -> CTECHAR neurCteCh .)
    <               reduce using rule 110 (varcte -> CTECHAR neurCteCh .)
    MTHANEQ         reduce using rule 110 (varcte -> CTECHAR neurCteCh .)
    LTHANEQ         reduce using rule 110 (varcte -> CTECHAR neurCteCh .)


state 127

    (101) factor -> ( neur6 . expresion ) neur7
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (151) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 151 (empty -> .)
    ID              reduce using rule 151 (empty -> .)
    CTEE            reduce using rule 151 (empty -> .)
    CTEF            reduce using rule 151 (empty -> .)
    CTEBOOL         reduce using rule 151 (empty -> .)
    CTECHAR         reduce using rule 151 (empty -> .)
    CALL            reduce using rule 151 (empty -> .)

    expresion                      shift and go to state 160
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 128

    (79) p -> MTHANEQ . neur11_5 nexp
    (85) neur11_5 -> .

    (               reduce using rule 85 (neur11_5 -> .)
    ID              reduce using rule 85 (neur11_5 -> .)
    CTEE            reduce using rule 85 (neur11_5 -> .)
    CTEF            reduce using rule 85 (neur11_5 -> .)
    CTEBOOL         reduce using rule 85 (neur11_5 -> .)
    CTECHAR         reduce using rule 85 (neur11_5 -> .)
    CALL            reduce using rule 85 (neur11_5 -> .)

    neur11_5                       shift and go to state 161

state 129

    (72) exp -> nexp p . neur12
    (73) neur12 -> .

    AND             reduce using rule 73 (neur12 -> .)
    OR              reduce using rule 73 (neur12 -> .)
    ;               reduce using rule 73 (neur12 -> .)
    )               reduce using rule 73 (neur12 -> .)
    ,               reduce using rule 73 (neur12 -> .)

    neur12                         shift and go to state 162

state 130

    (80) p -> LTHANEQ . neur11_6 nexp
    (86) neur11_6 -> .

    (               reduce using rule 86 (neur11_6 -> .)
    ID              reduce using rule 86 (neur11_6 -> .)
    CTEE            reduce using rule 86 (neur11_6 -> .)
    CTEF            reduce using rule 86 (neur11_6 -> .)
    CTEBOOL         reduce using rule 86 (neur11_6 -> .)
    CTECHAR         reduce using rule 86 (neur11_6 -> .)
    CALL            reduce using rule 86 (neur11_6 -> .)

    neur11_6                       shift and go to state 163

state 131

    (76) p -> NOTEQ . neur11_2 nexp
    (82) neur11_2 -> .

    (               reduce using rule 82 (neur11_2 -> .)
    ID              reduce using rule 82 (neur11_2 -> .)
    CTEE            reduce using rule 82 (neur11_2 -> .)
    CTEF            reduce using rule 82 (neur11_2 -> .)
    CTEBOOL         reduce using rule 82 (neur11_2 -> .)
    CTECHAR         reduce using rule 82 (neur11_2 -> .)
    CALL            reduce using rule 82 (neur11_2 -> .)

    neur11_2                       shift and go to state 164

state 132

    (75) p -> EQ . neur11_1 nexp
    (81) neur11_1 -> .

    (               reduce using rule 81 (neur11_1 -> .)
    ID              reduce using rule 81 (neur11_1 -> .)
    CTEE            reduce using rule 81 (neur11_1 -> .)
    CTEF            reduce using rule 81 (neur11_1 -> .)
    CTEBOOL         reduce using rule 81 (neur11_1 -> .)
    CTECHAR         reduce using rule 81 (neur11_1 -> .)
    CALL            reduce using rule 81 (neur11_1 -> .)

    neur11_1                       shift and go to state 165

state 133

    (78) p -> < . neur11_4 nexp
    (84) neur11_4 -> .

    (               reduce using rule 84 (neur11_4 -> .)
    ID              reduce using rule 84 (neur11_4 -> .)
    CTEE            reduce using rule 84 (neur11_4 -> .)
    CTEF            reduce using rule 84 (neur11_4 -> .)
    CTEBOOL         reduce using rule 84 (neur11_4 -> .)
    CTECHAR         reduce using rule 84 (neur11_4 -> .)
    CALL            reduce using rule 84 (neur11_4 -> .)

    neur11_4                       shift and go to state 166

state 134

    (74) p -> empty .

    AND             reduce using rule 74 (p -> empty .)
    OR              reduce using rule 74 (p -> empty .)
    ;               reduce using rule 74 (p -> empty .)
    )               reduce using rule 74 (p -> empty .)
    ,               reduce using rule 74 (p -> empty .)


state 135

    (77) p -> > . neur11_3 nexp
    (83) neur11_3 -> .

    (               reduce using rule 83 (neur11_3 -> .)
    ID              reduce using rule 83 (neur11_3 -> .)
    CTEE            reduce using rule 83 (neur11_3 -> .)
    CTEF            reduce using rule 83 (neur11_3 -> .)
    CTEBOOL         reduce using rule 83 (neur11_3 -> .)
    CTECHAR         reduce using rule 83 (neur11_3 -> .)
    CALL            reduce using rule 83 (neur11_3 -> .)

    neur11_3                       shift and go to state 167

state 136

    (94) termino -> factor neur4 . n
    (96) n -> . empty
    (97) n -> . * neur2_1 termino
    (98) n -> . / neur2_2 termino
    (151) empty -> .

    *               shift and go to state 168
    /               shift and go to state 169
    +               reduce using rule 151 (empty -> .)
    -               reduce using rule 151 (empty -> .)
    EQ              reduce using rule 151 (empty -> .)
    NOTEQ           reduce using rule 151 (empty -> .)
    >               reduce using rule 151 (empty -> .)
    <               reduce using rule 151 (empty -> .)
    MTHANEQ         reduce using rule 151 (empty -> .)
    LTHANEQ         reduce using rule 151 (empty -> .)
    AND             reduce using rule 151 (empty -> .)
    OR              reduce using rule 151 (empty -> .)
    ;               reduce using rule 151 (empty -> .)
    )               reduce using rule 151 (empty -> .)
    ,               reduce using rule 151 (empty -> .)

    n                              shift and go to state 170
    empty                          shift and go to state 171

state 137

    (134) callreturnfunc -> CALL ID . neur24 ( s ) neur26 ;
    (141) neur24 -> .

    (               reduce using rule 141 (neur24 -> .)

    neur24                         shift and go to state 172

state 138

    (117) r -> oplista .

    *               reduce using rule 117 (r -> oplista .)
    /               reduce using rule 117 (r -> oplista .)
    +               reduce using rule 117 (r -> oplista .)
    -               reduce using rule 117 (r -> oplista .)
    EQ              reduce using rule 117 (r -> oplista .)
    NOTEQ           reduce using rule 117 (r -> oplista .)
    >               reduce using rule 117 (r -> oplista .)
    <               reduce using rule 117 (r -> oplista .)
    MTHANEQ         reduce using rule 117 (r -> oplista .)
    LTHANEQ         reduce using rule 117 (r -> oplista .)
    AND             reduce using rule 117 (r -> oplista .)
    OR              reduce using rule 117 (r -> oplista .)
    ;               reduce using rule 117 (r -> oplista .)
    )               reduce using rule 117 (r -> oplista .)
    ,               reduce using rule 117 (r -> oplista .)


state 139

    (105) varcte -> ID r . neurVar
    (111) neurVar -> .

    *               reduce using rule 111 (neurVar -> .)
    /               reduce using rule 111 (neurVar -> .)
    +               reduce using rule 111 (neurVar -> .)
    -               reduce using rule 111 (neurVar -> .)
    EQ              reduce using rule 111 (neurVar -> .)
    NOTEQ           reduce using rule 111 (neurVar -> .)
    >               reduce using rule 111 (neurVar -> .)
    <               reduce using rule 111 (neurVar -> .)
    MTHANEQ         reduce using rule 111 (neurVar -> .)
    LTHANEQ         reduce using rule 111 (neurVar -> .)
    AND             reduce using rule 111 (neurVar -> .)
    OR              reduce using rule 111 (neurVar -> .)
    ;               reduce using rule 111 (neurVar -> .)
    )               reduce using rule 111 (neurVar -> .)
    ,               reduce using rule 111 (neurVar -> .)

    neurVar                        shift and go to state 173

state 140

    (118) oplista -> ID . . x

    .               shift and go to state 174


state 141

    (116) r -> empty .

    *               reduce using rule 116 (r -> empty .)
    /               reduce using rule 116 (r -> empty .)
    +               reduce using rule 116 (r -> empty .)
    -               reduce using rule 116 (r -> empty .)
    EQ              reduce using rule 116 (r -> empty .)
    NOTEQ           reduce using rule 116 (r -> empty .)
    >               reduce using rule 116 (r -> empty .)
    <               reduce using rule 116 (r -> empty .)
    MTHANEQ         reduce using rule 116 (r -> empty .)
    LTHANEQ         reduce using rule 116 (r -> empty .)
    AND             reduce using rule 116 (r -> empty .)
    OR              reduce using rule 116 (r -> empty .)
    ;               reduce using rule 116 (r -> empty .)
    )               reduce using rule 116 (r -> empty .)
    ,               reduce using rule 116 (r -> empty .)


state 142

    (108) varcte -> CTEBOOL neurCteB .

    *               reduce using rule 108 (varcte -> CTEBOOL neurCteB .)
    /               reduce using rule 108 (varcte -> CTEBOOL neurCteB .)
    +               reduce using rule 108 (varcte -> CTEBOOL neurCteB .)
    -               reduce using rule 108 (varcte -> CTEBOOL neurCteB .)
    AND             reduce using rule 108 (varcte -> CTEBOOL neurCteB .)
    OR              reduce using rule 108 (varcte -> CTEBOOL neurCteB .)
    ;               reduce using rule 108 (varcte -> CTEBOOL neurCteB .)
    )               reduce using rule 108 (varcte -> CTEBOOL neurCteB .)
    ,               reduce using rule 108 (varcte -> CTEBOOL neurCteB .)
    EQ              reduce using rule 108 (varcte -> CTEBOOL neurCteB .)
    NOTEQ           reduce using rule 108 (varcte -> CTEBOOL neurCteB .)
    >               reduce using rule 108 (varcte -> CTEBOOL neurCteB .)
    <               reduce using rule 108 (varcte -> CTEBOOL neurCteB .)
    MTHANEQ         reduce using rule 108 (varcte -> CTEBOOL neurCteB .)
    LTHANEQ         reduce using rule 108 (varcte -> CTEBOOL neurCteB .)


state 143

    (107) varcte -> CTEF neurCteF .

    *               reduce using rule 107 (varcte -> CTEF neurCteF .)
    /               reduce using rule 107 (varcte -> CTEF neurCteF .)
    +               reduce using rule 107 (varcte -> CTEF neurCteF .)
    -               reduce using rule 107 (varcte -> CTEF neurCteF .)
    AND             reduce using rule 107 (varcte -> CTEF neurCteF .)
    OR              reduce using rule 107 (varcte -> CTEF neurCteF .)
    ;               reduce using rule 107 (varcte -> CTEF neurCteF .)
    )               reduce using rule 107 (varcte -> CTEF neurCteF .)
    ,               reduce using rule 107 (varcte -> CTEF neurCteF .)
    EQ              reduce using rule 107 (varcte -> CTEF neurCteF .)
    NOTEQ           reduce using rule 107 (varcte -> CTEF neurCteF .)
    >               reduce using rule 107 (varcte -> CTEF neurCteF .)
    <               reduce using rule 107 (varcte -> CTEF neurCteF .)
    MTHANEQ         reduce using rule 107 (varcte -> CTEF neurCteF .)
    LTHANEQ         reduce using rule 107 (varcte -> CTEF neurCteF .)


state 144

    (65) subexpresion -> exp neur10 . o
    (67) o -> . empty
    (68) o -> . AND neur9_1 subexpresion
    (69) o -> . OR neur9_2 subexpresion
    (151) empty -> .

    AND             shift and go to state 175
    OR              shift and go to state 177
    ;               reduce using rule 151 (empty -> .)
    )               reduce using rule 151 (empty -> .)
    ,               reduce using rule 151 (empty -> .)

    o                              shift and go to state 176
    empty                          shift and go to state 178

state 145

    (106) varcte -> CTEE neurCteE .

    *               reduce using rule 106 (varcte -> CTEE neurCteE .)
    /               reduce using rule 106 (varcte -> CTEE neurCteE .)
    +               reduce using rule 106 (varcte -> CTEE neurCteE .)
    -               reduce using rule 106 (varcte -> CTEE neurCteE .)
    AND             reduce using rule 106 (varcte -> CTEE neurCteE .)
    OR              reduce using rule 106 (varcte -> CTEE neurCteE .)
    ;               reduce using rule 106 (varcte -> CTEE neurCteE .)
    )               reduce using rule 106 (varcte -> CTEE neurCteE .)
    ,               reduce using rule 106 (varcte -> CTEE neurCteE .)
    EQ              reduce using rule 106 (varcte -> CTEE neurCteE .)
    NOTEQ           reduce using rule 106 (varcte -> CTEE neurCteE .)
    >               reduce using rule 106 (varcte -> CTEE neurCteE .)
    <               reduce using rule 106 (varcte -> CTEE neurCteE .)
    MTHANEQ         reduce using rule 106 (varcte -> CTEE neurCteE .)
    LTHANEQ         reduce using rule 106 (varcte -> CTEE neurCteE .)


state 146

    (140) callvoidfunc -> CALL ID neur24 ( . s ) neur26 ;
    (135) s -> . empty
    (136) s -> . expresion neur25 t
    (151) empty -> .
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT

    )               reduce using rule 151 (empty -> .)
    (               reduce using rule 151 (empty -> .)
    ID              reduce using rule 151 (empty -> .)
    CTEE            reduce using rule 151 (empty -> .)
    CTEF            reduce using rule 151 (empty -> .)
    CTEBOOL         reduce using rule 151 (empty -> .)
    CTECHAR         reduce using rule 151 (empty -> .)
    CALL            reduce using rule 151 (empty -> .)
    NOT             shift and go to state 88

    expresion                      shift and go to state 179
    m                              shift and go to state 87
    s                              shift and go to state 180
    empty                          shift and go to state 181

state 147

    (132) play -> PLAY ( NOTA , . CTEE ) ;

    CTEE            shift and go to state 182


state 148

    (57) for -> FOR ( asignacion neur18 . expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (151) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 151 (empty -> .)
    ID              reduce using rule 151 (empty -> .)
    CTEE            reduce using rule 151 (empty -> .)
    CTEF            reduce using rule 151 (empty -> .)
    CTEBOOL         reduce using rule 151 (empty -> .)
    CTECHAR         reduce using rule 151 (empty -> .)
    CALL            reduce using rule 151 (empty -> .)

    expresion                      shift and go to state 183
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 149

    (48) k -> expresion .

    ;               reduce using rule 48 (k -> expresion .)


state 150

    (46) asignacion -> ID = neur8 k . ;

    ;               shift and go to state 184


state 151

    (49) k -> asiglista .

    ;               reduce using rule 49 (k -> asiglista .)


state 152

    (50) asiglista -> NEW . LIST ( )

    LIST            shift and go to state 185


state 153

    (51) if -> IF ( expresion ) . neur13 bloque l ; neur15
    (52) neur13 -> .

    {               reduce using rule 52 (neur13 -> .)

    neur13                         shift and go to state 186

state 154

    (143) return -> RETURN ( expresion ) ; .

    ID              reduce using rule 143 (return -> RETURN ( expresion ) ; .)
    IF              reduce using rule 143 (return -> RETURN ( expresion ) ; .)
    FOR             reduce using rule 143 (return -> RETURN ( expresion ) ; .)
    RETURN          reduce using rule 143 (return -> RETURN ( expresion ) ; .)
    WHILE           reduce using rule 143 (return -> RETURN ( expresion ) ; .)
    PLAY            reduce using rule 143 (return -> RETURN ( expresion ) ; .)
    PRINT           reduce using rule 143 (return -> RETURN ( expresion ) ; .)
    CALL            reduce using rule 143 (return -> RETURN ( expresion ) ; .)
    }               reduce using rule 143 (return -> RETURN ( expresion ) ; .)


state 155

    (129) while -> WHILE ( neur16 expresion ) . neur13 bloque ; neur17
    (52) neur13 -> .

    {               reduce using rule 52 (neur13 -> .)

    neur13                         shift and go to state 187

state 156

    (90) q -> + . neur3_1 nexp
    (92) neur3_1 -> .

    (               reduce using rule 92 (neur3_1 -> .)
    ID              reduce using rule 92 (neur3_1 -> .)
    CTEE            reduce using rule 92 (neur3_1 -> .)
    CTEF            reduce using rule 92 (neur3_1 -> .)
    CTEBOOL         reduce using rule 92 (neur3_1 -> .)
    CTECHAR         reduce using rule 92 (neur3_1 -> .)
    CALL            reduce using rule 92 (neur3_1 -> .)

    neur3_1                        shift and go to state 188

state 157

    (91) q -> - . neur3_2 nexp
    (93) neur3_2 -> .

    (               reduce using rule 93 (neur3_2 -> .)
    ID              reduce using rule 93 (neur3_2 -> .)
    CTEE            reduce using rule 93 (neur3_2 -> .)
    CTEF            reduce using rule 93 (neur3_2 -> .)
    CTEBOOL         reduce using rule 93 (neur3_2 -> .)
    CTECHAR         reduce using rule 93 (neur3_2 -> .)
    CALL            reduce using rule 93 (neur3_2 -> .)

    neur3_2                        shift and go to state 189

state 158

    (87) nexp -> termino neur5 q .

    AND             reduce using rule 87 (nexp -> termino neur5 q .)
    OR              reduce using rule 87 (nexp -> termino neur5 q .)
    ;               reduce using rule 87 (nexp -> termino neur5 q .)
    )               reduce using rule 87 (nexp -> termino neur5 q .)
    ,               reduce using rule 87 (nexp -> termino neur5 q .)
    EQ              reduce using rule 87 (nexp -> termino neur5 q .)
    NOTEQ           reduce using rule 87 (nexp -> termino neur5 q .)
    >               reduce using rule 87 (nexp -> termino neur5 q .)
    <               reduce using rule 87 (nexp -> termino neur5 q .)
    MTHANEQ         reduce using rule 87 (nexp -> termino neur5 q .)
    LTHANEQ         reduce using rule 87 (nexp -> termino neur5 q .)


state 159

    (89) q -> empty .

    EQ              reduce using rule 89 (q -> empty .)
    NOTEQ           reduce using rule 89 (q -> empty .)
    >               reduce using rule 89 (q -> empty .)
    <               reduce using rule 89 (q -> empty .)
    MTHANEQ         reduce using rule 89 (q -> empty .)
    LTHANEQ         reduce using rule 89 (q -> empty .)
    AND             reduce using rule 89 (q -> empty .)
    OR              reduce using rule 89 (q -> empty .)
    ;               reduce using rule 89 (q -> empty .)
    )               reduce using rule 89 (q -> empty .)
    ,               reduce using rule 89 (q -> empty .)


state 160

    (101) factor -> ( neur6 expresion . ) neur7

    )               shift and go to state 190


state 161

    (79) p -> MTHANEQ neur11_5 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte
    (105) varcte -> . ID r neurVar
    (106) varcte -> . CTEE neurCteE
    (107) varcte -> . CTEF neurCteF
    (108) varcte -> . CTEBOOL neurCteB
    (109) varcte -> . callreturnfunc
    (110) varcte -> . CTECHAR neurCteCh
    (134) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 191
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 162

    (72) exp -> nexp p neur12 .

    AND             reduce using rule 72 (exp -> nexp p neur12 .)
    OR              reduce using rule 72 (exp -> nexp p neur12 .)
    ;               reduce using rule 72 (exp -> nexp p neur12 .)
    )               reduce using rule 72 (exp -> nexp p neur12 .)
    ,               reduce using rule 72 (exp -> nexp p neur12 .)


state 163

    (80) p -> LTHANEQ neur11_6 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte
    (105) varcte -> . ID r neurVar
    (106) varcte -> . CTEE neurCteE
    (107) varcte -> . CTEF neurCteF
    (108) varcte -> . CTEBOOL neurCteB
    (109) varcte -> . callreturnfunc
    (110) varcte -> . CTECHAR neurCteCh
    (134) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 192
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 164

    (76) p -> NOTEQ neur11_2 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte
    (105) varcte -> . ID r neurVar
    (106) varcte -> . CTEE neurCteE
    (107) varcte -> . CTEF neurCteF
    (108) varcte -> . CTEBOOL neurCteB
    (109) varcte -> . callreturnfunc
    (110) varcte -> . CTECHAR neurCteCh
    (134) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 193
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 165

    (75) p -> EQ neur11_1 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte
    (105) varcte -> . ID r neurVar
    (106) varcte -> . CTEE neurCteE
    (107) varcte -> . CTEF neurCteF
    (108) varcte -> . CTEBOOL neurCteB
    (109) varcte -> . callreturnfunc
    (110) varcte -> . CTECHAR neurCteCh
    (134) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 194
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 166

    (78) p -> < neur11_4 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte
    (105) varcte -> . ID r neurVar
    (106) varcte -> . CTEE neurCteE
    (107) varcte -> . CTEF neurCteF
    (108) varcte -> . CTEBOOL neurCteB
    (109) varcte -> . callreturnfunc
    (110) varcte -> . CTECHAR neurCteCh
    (134) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 195
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 167

    (77) p -> > neur11_3 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte
    (105) varcte -> . ID r neurVar
    (106) varcte -> . CTEE neurCteE
    (107) varcte -> . CTEF neurCteF
    (108) varcte -> . CTEBOOL neurCteB
    (109) varcte -> . callreturnfunc
    (110) varcte -> . CTECHAR neurCteCh
    (134) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 196
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 168

    (97) n -> * . neur2_1 termino
    (99) neur2_1 -> .

    (               reduce using rule 99 (neur2_1 -> .)
    ID              reduce using rule 99 (neur2_1 -> .)
    CTEE            reduce using rule 99 (neur2_1 -> .)
    CTEF            reduce using rule 99 (neur2_1 -> .)
    CTEBOOL         reduce using rule 99 (neur2_1 -> .)
    CTECHAR         reduce using rule 99 (neur2_1 -> .)
    CALL            reduce using rule 99 (neur2_1 -> .)

    neur2_1                        shift and go to state 197

state 169

    (98) n -> / . neur2_2 termino
    (100) neur2_2 -> .

    (               reduce using rule 100 (neur2_2 -> .)
    ID              reduce using rule 100 (neur2_2 -> .)
    CTEE            reduce using rule 100 (neur2_2 -> .)
    CTEF            reduce using rule 100 (neur2_2 -> .)
    CTEBOOL         reduce using rule 100 (neur2_2 -> .)
    CTECHAR         reduce using rule 100 (neur2_2 -> .)
    CALL            reduce using rule 100 (neur2_2 -> .)

    neur2_2                        shift and go to state 198

state 170

    (94) termino -> factor neur4 n .

    +               reduce using rule 94 (termino -> factor neur4 n .)
    -               reduce using rule 94 (termino -> factor neur4 n .)
    AND             reduce using rule 94 (termino -> factor neur4 n .)
    OR              reduce using rule 94 (termino -> factor neur4 n .)
    ;               reduce using rule 94 (termino -> factor neur4 n .)
    )               reduce using rule 94 (termino -> factor neur4 n .)
    ,               reduce using rule 94 (termino -> factor neur4 n .)
    EQ              reduce using rule 94 (termino -> factor neur4 n .)
    NOTEQ           reduce using rule 94 (termino -> factor neur4 n .)
    >               reduce using rule 94 (termino -> factor neur4 n .)
    <               reduce using rule 94 (termino -> factor neur4 n .)
    MTHANEQ         reduce using rule 94 (termino -> factor neur4 n .)
    LTHANEQ         reduce using rule 94 (termino -> factor neur4 n .)


state 171

    (96) n -> empty .

    +               reduce using rule 96 (n -> empty .)
    -               reduce using rule 96 (n -> empty .)
    EQ              reduce using rule 96 (n -> empty .)
    NOTEQ           reduce using rule 96 (n -> empty .)
    >               reduce using rule 96 (n -> empty .)
    <               reduce using rule 96 (n -> empty .)
    MTHANEQ         reduce using rule 96 (n -> empty .)
    LTHANEQ         reduce using rule 96 (n -> empty .)
    AND             reduce using rule 96 (n -> empty .)
    OR              reduce using rule 96 (n -> empty .)
    ;               reduce using rule 96 (n -> empty .)
    )               reduce using rule 96 (n -> empty .)
    ,               reduce using rule 96 (n -> empty .)


state 172

    (134) callreturnfunc -> CALL ID neur24 . ( s ) neur26 ;

    (               shift and go to state 199


state 173

    (105) varcte -> ID r neurVar .

    *               reduce using rule 105 (varcte -> ID r neurVar .)
    /               reduce using rule 105 (varcte -> ID r neurVar .)
    +               reduce using rule 105 (varcte -> ID r neurVar .)
    -               reduce using rule 105 (varcte -> ID r neurVar .)
    AND             reduce using rule 105 (varcte -> ID r neurVar .)
    OR              reduce using rule 105 (varcte -> ID r neurVar .)
    ;               reduce using rule 105 (varcte -> ID r neurVar .)
    )               reduce using rule 105 (varcte -> ID r neurVar .)
    ,               reduce using rule 105 (varcte -> ID r neurVar .)
    EQ              reduce using rule 105 (varcte -> ID r neurVar .)
    NOTEQ           reduce using rule 105 (varcte -> ID r neurVar .)
    >               reduce using rule 105 (varcte -> ID r neurVar .)
    <               reduce using rule 105 (varcte -> ID r neurVar .)
    MTHANEQ         reduce using rule 105 (varcte -> ID r neurVar .)
    LTHANEQ         reduce using rule 105 (varcte -> ID r neurVar .)


state 174

    (118) oplista -> ID . . x
    (119) x -> . inlistset
    (120) x -> . append
    (121) x -> . length
    (122) x -> . getlist
    (123) x -> . removelist
    (124) inlistset -> . SET ( CTEE , expresion )
    (125) append -> . APPEND ( expresion )
    (126) length -> . LENGTH ( )
    (127) getlist -> . GET ( expresion )
    (128) removelist -> . REMOVE ( expresion )

    SET             shift and go to state 200
    APPEND          shift and go to state 207
    LENGTH          shift and go to state 205
    GET             shift and go to state 202
    REMOVE          shift and go to state 204

    inlistset                      shift and go to state 201
    getlist                        shift and go to state 203
    length                         shift and go to state 206
    x                              shift and go to state 208
    removelist                     shift and go to state 209
    append                         shift and go to state 210

state 175

    (68) o -> AND . neur9_1 subexpresion
    (70) neur9_1 -> .

    (               reduce using rule 70 (neur9_1 -> .)
    ID              reduce using rule 70 (neur9_1 -> .)
    CTEE            reduce using rule 70 (neur9_1 -> .)
    CTEF            reduce using rule 70 (neur9_1 -> .)
    CTEBOOL         reduce using rule 70 (neur9_1 -> .)
    CTECHAR         reduce using rule 70 (neur9_1 -> .)
    CALL            reduce using rule 70 (neur9_1 -> .)

    neur9_1                        shift and go to state 211

state 176

    (65) subexpresion -> exp neur10 o .

    ;               reduce using rule 65 (subexpresion -> exp neur10 o .)
    )               reduce using rule 65 (subexpresion -> exp neur10 o .)
    ,               reduce using rule 65 (subexpresion -> exp neur10 o .)


state 177

    (69) o -> OR . neur9_2 subexpresion
    (71) neur9_2 -> .

    (               reduce using rule 71 (neur9_2 -> .)
    ID              reduce using rule 71 (neur9_2 -> .)
    CTEE            reduce using rule 71 (neur9_2 -> .)
    CTEF            reduce using rule 71 (neur9_2 -> .)
    CTEBOOL         reduce using rule 71 (neur9_2 -> .)
    CTECHAR         reduce using rule 71 (neur9_2 -> .)
    CALL            reduce using rule 71 (neur9_2 -> .)

    neur9_2                        shift and go to state 212

state 178

    (67) o -> empty .

    ;               reduce using rule 67 (o -> empty .)
    )               reduce using rule 67 (o -> empty .)
    ,               reduce using rule 67 (o -> empty .)


state 179

    (136) s -> expresion . neur25 t
    (137) neur25 -> .

    ,               reduce using rule 137 (neur25 -> .)
    )               reduce using rule 137 (neur25 -> .)

    neur25                         shift and go to state 213

state 180

    (140) callvoidfunc -> CALL ID neur24 ( s . ) neur26 ;

    )               shift and go to state 214


state 181

    (135) s -> empty .
    (63) m -> empty .

    )               reduce using rule 135 (s -> empty .)
    (               reduce using rule 63 (m -> empty .)
    ID              reduce using rule 63 (m -> empty .)
    CTEE            reduce using rule 63 (m -> empty .)
    CTEF            reduce using rule 63 (m -> empty .)
    CTEBOOL         reduce using rule 63 (m -> empty .)
    CTECHAR         reduce using rule 63 (m -> empty .)
    CALL            reduce using rule 63 (m -> empty .)


state 182

    (132) play -> PLAY ( NOTA , CTEE . ) ;

    )               shift and go to state 215


state 183

    (57) for -> FOR ( asignacion neur18 expresion . ; neur19 asignacion ) neur21 bloque ; neur20

    ;               shift and go to state 216


state 184

    (46) asignacion -> ID = neur8 k ; .

    NOT             reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    (               reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    ID              reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    CTEE            reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    CTEF            reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    CTEBOOL         reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    CTECHAR         reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    CALL            reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    IF              reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    FOR             reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    RETURN          reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    WHILE           reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    PLAY            reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    PRINT           reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    }               reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    )               reduce using rule 46 (asignacion -> ID = neur8 k ; .)


state 185

    (50) asiglista -> NEW LIST . ( )

    (               shift and go to state 217


state 186

    (51) if -> IF ( expresion ) neur13 . bloque l ; neur15
    (35) bloque -> . { i }

    {               shift and go to state 57

    bloque                         shift and go to state 218

state 187

    (129) while -> WHILE ( neur16 expresion ) neur13 . bloque ; neur17
    (35) bloque -> . { i }

    {               shift and go to state 57

    bloque                         shift and go to state 219

state 188

    (90) q -> + neur3_1 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte
    (105) varcte -> . ID r neurVar
    (106) varcte -> . CTEE neurCteE
    (107) varcte -> . CTEF neurCteF
    (108) varcte -> . CTEBOOL neurCteB
    (109) varcte -> . callreturnfunc
    (110) varcte -> . CTECHAR neurCteCh
    (134) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 220
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 189

    (91) q -> - neur3_2 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte
    (105) varcte -> . ID r neurVar
    (106) varcte -> . CTEE neurCteE
    (107) varcte -> . CTEF neurCteF
    (108) varcte -> . CTEBOOL neurCteB
    (109) varcte -> . callreturnfunc
    (110) varcte -> . CTECHAR neurCteCh
    (134) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 221
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 190

    (101) factor -> ( neur6 expresion ) . neur7
    (104) neur7 -> .

    *               reduce using rule 104 (neur7 -> .)
    /               reduce using rule 104 (neur7 -> .)
    +               reduce using rule 104 (neur7 -> .)
    -               reduce using rule 104 (neur7 -> .)
    EQ              reduce using rule 104 (neur7 -> .)
    NOTEQ           reduce using rule 104 (neur7 -> .)
    >               reduce using rule 104 (neur7 -> .)
    <               reduce using rule 104 (neur7 -> .)
    MTHANEQ         reduce using rule 104 (neur7 -> .)
    LTHANEQ         reduce using rule 104 (neur7 -> .)
    AND             reduce using rule 104 (neur7 -> .)
    OR              reduce using rule 104 (neur7 -> .)
    ;               reduce using rule 104 (neur7 -> .)
    )               reduce using rule 104 (neur7 -> .)
    ,               reduce using rule 104 (neur7 -> .)

    neur7                          shift and go to state 222

state 191

    (79) p -> MTHANEQ neur11_5 nexp .

    AND             reduce using rule 79 (p -> MTHANEQ neur11_5 nexp .)
    OR              reduce using rule 79 (p -> MTHANEQ neur11_5 nexp .)
    ;               reduce using rule 79 (p -> MTHANEQ neur11_5 nexp .)
    )               reduce using rule 79 (p -> MTHANEQ neur11_5 nexp .)
    ,               reduce using rule 79 (p -> MTHANEQ neur11_5 nexp .)


state 192

    (80) p -> LTHANEQ neur11_6 nexp .

    AND             reduce using rule 80 (p -> LTHANEQ neur11_6 nexp .)
    OR              reduce using rule 80 (p -> LTHANEQ neur11_6 nexp .)
    ;               reduce using rule 80 (p -> LTHANEQ neur11_6 nexp .)
    )               reduce using rule 80 (p -> LTHANEQ neur11_6 nexp .)
    ,               reduce using rule 80 (p -> LTHANEQ neur11_6 nexp .)


state 193

    (76) p -> NOTEQ neur11_2 nexp .

    AND             reduce using rule 76 (p -> NOTEQ neur11_2 nexp .)
    OR              reduce using rule 76 (p -> NOTEQ neur11_2 nexp .)
    ;               reduce using rule 76 (p -> NOTEQ neur11_2 nexp .)
    )               reduce using rule 76 (p -> NOTEQ neur11_2 nexp .)
    ,               reduce using rule 76 (p -> NOTEQ neur11_2 nexp .)


state 194

    (75) p -> EQ neur11_1 nexp .

    AND             reduce using rule 75 (p -> EQ neur11_1 nexp .)
    OR              reduce using rule 75 (p -> EQ neur11_1 nexp .)
    ;               reduce using rule 75 (p -> EQ neur11_1 nexp .)
    )               reduce using rule 75 (p -> EQ neur11_1 nexp .)
    ,               reduce using rule 75 (p -> EQ neur11_1 nexp .)


state 195

    (78) p -> < neur11_4 nexp .

    AND             reduce using rule 78 (p -> < neur11_4 nexp .)
    OR              reduce using rule 78 (p -> < neur11_4 nexp .)
    ;               reduce using rule 78 (p -> < neur11_4 nexp .)
    )               reduce using rule 78 (p -> < neur11_4 nexp .)
    ,               reduce using rule 78 (p -> < neur11_4 nexp .)


state 196

    (77) p -> > neur11_3 nexp .

    AND             reduce using rule 77 (p -> > neur11_3 nexp .)
    OR              reduce using rule 77 (p -> > neur11_3 nexp .)
    ;               reduce using rule 77 (p -> > neur11_3 nexp .)
    )               reduce using rule 77 (p -> > neur11_3 nexp .)
    ,               reduce using rule 77 (p -> > neur11_3 nexp .)


state 197

    (97) n -> * neur2_1 . termino
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte
    (105) varcte -> . ID r neurVar
    (106) varcte -> . CTEE neurCteE
    (107) varcte -> . CTEF neurCteF
    (108) varcte -> . CTEBOOL neurCteB
    (109) varcte -> . callreturnfunc
    (110) varcte -> . CTECHAR neurCteCh
    (134) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    varcte                         shift and go to state 106
    callreturnfunc                 shift and go to state 109
    termino                        shift and go to state 223
    factor                         shift and go to state 110

state 198

    (98) n -> / neur2_2 . termino
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte
    (105) varcte -> . ID r neurVar
    (106) varcte -> . CTEE neurCteE
    (107) varcte -> . CTEF neurCteF
    (108) varcte -> . CTEBOOL neurCteB
    (109) varcte -> . callreturnfunc
    (110) varcte -> . CTECHAR neurCteCh
    (134) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    varcte                         shift and go to state 106
    callreturnfunc                 shift and go to state 109
    termino                        shift and go to state 224
    factor                         shift and go to state 110

state 199

    (134) callreturnfunc -> CALL ID neur24 ( . s ) neur26 ;
    (135) s -> . empty
    (136) s -> . expresion neur25 t
    (151) empty -> .
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT

    )               reduce using rule 151 (empty -> .)
    (               reduce using rule 151 (empty -> .)
    ID              reduce using rule 151 (empty -> .)
    CTEE            reduce using rule 151 (empty -> .)
    CTEF            reduce using rule 151 (empty -> .)
    CTEBOOL         reduce using rule 151 (empty -> .)
    CTECHAR         reduce using rule 151 (empty -> .)
    CALL            reduce using rule 151 (empty -> .)
    NOT             shift and go to state 88

    expresion                      shift and go to state 179
    m                              shift and go to state 87
    s                              shift and go to state 225
    empty                          shift and go to state 181

state 200

    (124) inlistset -> SET . ( CTEE , expresion )

    (               shift and go to state 226


state 201

    (119) x -> inlistset .

    *               reduce using rule 119 (x -> inlistset .)
    /               reduce using rule 119 (x -> inlistset .)
    +               reduce using rule 119 (x -> inlistset .)
    -               reduce using rule 119 (x -> inlistset .)
    EQ              reduce using rule 119 (x -> inlistset .)
    NOTEQ           reduce using rule 119 (x -> inlistset .)
    >               reduce using rule 119 (x -> inlistset .)
    <               reduce using rule 119 (x -> inlistset .)
    MTHANEQ         reduce using rule 119 (x -> inlistset .)
    LTHANEQ         reduce using rule 119 (x -> inlistset .)
    AND             reduce using rule 119 (x -> inlistset .)
    OR              reduce using rule 119 (x -> inlistset .)
    ;               reduce using rule 119 (x -> inlistset .)
    )               reduce using rule 119 (x -> inlistset .)
    ,               reduce using rule 119 (x -> inlistset .)


state 202

    (127) getlist -> GET . ( expresion )

    (               shift and go to state 227


state 203

    (122) x -> getlist .

    *               reduce using rule 122 (x -> getlist .)
    /               reduce using rule 122 (x -> getlist .)
    +               reduce using rule 122 (x -> getlist .)
    -               reduce using rule 122 (x -> getlist .)
    EQ              reduce using rule 122 (x -> getlist .)
    NOTEQ           reduce using rule 122 (x -> getlist .)
    >               reduce using rule 122 (x -> getlist .)
    <               reduce using rule 122 (x -> getlist .)
    MTHANEQ         reduce using rule 122 (x -> getlist .)
    LTHANEQ         reduce using rule 122 (x -> getlist .)
    AND             reduce using rule 122 (x -> getlist .)
    OR              reduce using rule 122 (x -> getlist .)
    ;               reduce using rule 122 (x -> getlist .)
    )               reduce using rule 122 (x -> getlist .)
    ,               reduce using rule 122 (x -> getlist .)


state 204

    (128) removelist -> REMOVE . ( expresion )

    (               shift and go to state 228


state 205

    (126) length -> LENGTH . ( )

    (               shift and go to state 229


state 206

    (121) x -> length .

    *               reduce using rule 121 (x -> length .)
    /               reduce using rule 121 (x -> length .)
    +               reduce using rule 121 (x -> length .)
    -               reduce using rule 121 (x -> length .)
    EQ              reduce using rule 121 (x -> length .)
    NOTEQ           reduce using rule 121 (x -> length .)
    >               reduce using rule 121 (x -> length .)
    <               reduce using rule 121 (x -> length .)
    MTHANEQ         reduce using rule 121 (x -> length .)
    LTHANEQ         reduce using rule 121 (x -> length .)
    AND             reduce using rule 121 (x -> length .)
    OR              reduce using rule 121 (x -> length .)
    ;               reduce using rule 121 (x -> length .)
    )               reduce using rule 121 (x -> length .)
    ,               reduce using rule 121 (x -> length .)


state 207

    (125) append -> APPEND . ( expresion )

    (               shift and go to state 230


state 208

    (118) oplista -> ID . x .

    *               reduce using rule 118 (oplista -> ID . x .)
    /               reduce using rule 118 (oplista -> ID . x .)
    +               reduce using rule 118 (oplista -> ID . x .)
    -               reduce using rule 118 (oplista -> ID . x .)
    EQ              reduce using rule 118 (oplista -> ID . x .)
    NOTEQ           reduce using rule 118 (oplista -> ID . x .)
    >               reduce using rule 118 (oplista -> ID . x .)
    <               reduce using rule 118 (oplista -> ID . x .)
    MTHANEQ         reduce using rule 118 (oplista -> ID . x .)
    LTHANEQ         reduce using rule 118 (oplista -> ID . x .)
    AND             reduce using rule 118 (oplista -> ID . x .)
    OR              reduce using rule 118 (oplista -> ID . x .)
    ;               reduce using rule 118 (oplista -> ID . x .)
    )               reduce using rule 118 (oplista -> ID . x .)
    ,               reduce using rule 118 (oplista -> ID . x .)


state 209

    (123) x -> removelist .

    *               reduce using rule 123 (x -> removelist .)
    /               reduce using rule 123 (x -> removelist .)
    +               reduce using rule 123 (x -> removelist .)
    -               reduce using rule 123 (x -> removelist .)
    EQ              reduce using rule 123 (x -> removelist .)
    NOTEQ           reduce using rule 123 (x -> removelist .)
    >               reduce using rule 123 (x -> removelist .)
    <               reduce using rule 123 (x -> removelist .)
    MTHANEQ         reduce using rule 123 (x -> removelist .)
    LTHANEQ         reduce using rule 123 (x -> removelist .)
    AND             reduce using rule 123 (x -> removelist .)
    OR              reduce using rule 123 (x -> removelist .)
    ;               reduce using rule 123 (x -> removelist .)
    )               reduce using rule 123 (x -> removelist .)
    ,               reduce using rule 123 (x -> removelist .)


state 210

    (120) x -> append .

    *               reduce using rule 120 (x -> append .)
    /               reduce using rule 120 (x -> append .)
    +               reduce using rule 120 (x -> append .)
    -               reduce using rule 120 (x -> append .)
    EQ              reduce using rule 120 (x -> append .)
    NOTEQ           reduce using rule 120 (x -> append .)
    >               reduce using rule 120 (x -> append .)
    <               reduce using rule 120 (x -> append .)
    MTHANEQ         reduce using rule 120 (x -> append .)
    LTHANEQ         reduce using rule 120 (x -> append .)
    AND             reduce using rule 120 (x -> append .)
    OR              reduce using rule 120 (x -> append .)
    ;               reduce using rule 120 (x -> append .)
    )               reduce using rule 120 (x -> append .)
    ,               reduce using rule 120 (x -> append .)


state 211

    (68) o -> AND neur9_1 . subexpresion
    (65) subexpresion -> . exp neur10 o
    (72) exp -> . nexp p neur12
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte
    (105) varcte -> . ID r neurVar
    (106) varcte -> . CTEE neurCteE
    (107) varcte -> . CTEF neurCteF
    (108) varcte -> . CTEBOOL neurCteB
    (109) varcte -> . callreturnfunc
    (110) varcte -> . CTECHAR neurCteCh
    (134) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 108
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110
    subexpresion                   shift and go to state 231
    exp                            shift and go to state 116

state 212

    (69) o -> OR neur9_2 . subexpresion
    (65) subexpresion -> . exp neur10 o
    (72) exp -> . nexp p neur12
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte
    (105) varcte -> . ID r neurVar
    (106) varcte -> . CTEE neurCteE
    (107) varcte -> . CTEF neurCteF
    (108) varcte -> . CTEBOOL neurCteB
    (109) varcte -> . callreturnfunc
    (110) varcte -> . CTECHAR neurCteCh
    (134) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 108
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110
    subexpresion                   shift and go to state 232
    exp                            shift and go to state 116

state 213

    (136) s -> expresion neur25 . t
    (138) t -> . empty
    (139) t -> . , s
    (151) empty -> .

    ,               shift and go to state 233
    )               reduce using rule 151 (empty -> .)

    t                              shift and go to state 234
    empty                          shift and go to state 235

state 214

    (140) callvoidfunc -> CALL ID neur24 ( s ) . neur26 ;
    (142) neur26 -> .

    ;               reduce using rule 142 (neur26 -> .)

    neur26                         shift and go to state 236

state 215

    (132) play -> PLAY ( NOTA , CTEE ) . ;

    ;               shift and go to state 237


state 216

    (57) for -> FOR ( asignacion neur18 expresion ; . neur19 asignacion ) neur21 bloque ; neur20
    (59) neur19 -> .

    ID              reduce using rule 59 (neur19 -> .)

    neur19                         shift and go to state 238

state 217

    (50) asiglista -> NEW LIST ( . )

    )               shift and go to state 239


state 218

    (51) if -> IF ( expresion ) neur13 bloque . l ; neur15
    (53) l -> . empty
    (54) l -> . ELSE neur14 bloque
    (151) empty -> .

    ELSE            shift and go to state 241
    ;               reduce using rule 151 (empty -> .)

    l                              shift and go to state 240
    empty                          shift and go to state 242

state 219

    (129) while -> WHILE ( neur16 expresion ) neur13 bloque . ; neur17

    ;               shift and go to state 243


state 220

    (90) q -> + neur3_1 nexp .

    EQ              reduce using rule 90 (q -> + neur3_1 nexp .)
    NOTEQ           reduce using rule 90 (q -> + neur3_1 nexp .)
    >               reduce using rule 90 (q -> + neur3_1 nexp .)
    <               reduce using rule 90 (q -> + neur3_1 nexp .)
    MTHANEQ         reduce using rule 90 (q -> + neur3_1 nexp .)
    LTHANEQ         reduce using rule 90 (q -> + neur3_1 nexp .)
    AND             reduce using rule 90 (q -> + neur3_1 nexp .)
    OR              reduce using rule 90 (q -> + neur3_1 nexp .)
    ;               reduce using rule 90 (q -> + neur3_1 nexp .)
    )               reduce using rule 90 (q -> + neur3_1 nexp .)
    ,               reduce using rule 90 (q -> + neur3_1 nexp .)


state 221

    (91) q -> - neur3_2 nexp .

    EQ              reduce using rule 91 (q -> - neur3_2 nexp .)
    NOTEQ           reduce using rule 91 (q -> - neur3_2 nexp .)
    >               reduce using rule 91 (q -> - neur3_2 nexp .)
    <               reduce using rule 91 (q -> - neur3_2 nexp .)
    MTHANEQ         reduce using rule 91 (q -> - neur3_2 nexp .)
    LTHANEQ         reduce using rule 91 (q -> - neur3_2 nexp .)
    AND             reduce using rule 91 (q -> - neur3_2 nexp .)
    OR              reduce using rule 91 (q -> - neur3_2 nexp .)
    ;               reduce using rule 91 (q -> - neur3_2 nexp .)
    )               reduce using rule 91 (q -> - neur3_2 nexp .)
    ,               reduce using rule 91 (q -> - neur3_2 nexp .)


state 222

    (101) factor -> ( neur6 expresion ) neur7 .

    *               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    /               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    +               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    -               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    EQ              reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    NOTEQ           reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    >               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    <               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    MTHANEQ         reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    LTHANEQ         reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    AND             reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    OR              reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    ;               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    )               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    ,               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)


state 223

    (97) n -> * neur2_1 termino .

    +               reduce using rule 97 (n -> * neur2_1 termino .)
    -               reduce using rule 97 (n -> * neur2_1 termino .)
    EQ              reduce using rule 97 (n -> * neur2_1 termino .)
    NOTEQ           reduce using rule 97 (n -> * neur2_1 termino .)
    >               reduce using rule 97 (n -> * neur2_1 termino .)
    <               reduce using rule 97 (n -> * neur2_1 termino .)
    MTHANEQ         reduce using rule 97 (n -> * neur2_1 termino .)
    LTHANEQ         reduce using rule 97 (n -> * neur2_1 termino .)
    AND             reduce using rule 97 (n -> * neur2_1 termino .)
    OR              reduce using rule 97 (n -> * neur2_1 termino .)
    ;               reduce using rule 97 (n -> * neur2_1 termino .)
    )               reduce using rule 97 (n -> * neur2_1 termino .)
    ,               reduce using rule 97 (n -> * neur2_1 termino .)


state 224

    (98) n -> / neur2_2 termino .

    +               reduce using rule 98 (n -> / neur2_2 termino .)
    -               reduce using rule 98 (n -> / neur2_2 termino .)
    EQ              reduce using rule 98 (n -> / neur2_2 termino .)
    NOTEQ           reduce using rule 98 (n -> / neur2_2 termino .)
    >               reduce using rule 98 (n -> / neur2_2 termino .)
    <               reduce using rule 98 (n -> / neur2_2 termino .)
    MTHANEQ         reduce using rule 98 (n -> / neur2_2 termino .)
    LTHANEQ         reduce using rule 98 (n -> / neur2_2 termino .)
    AND             reduce using rule 98 (n -> / neur2_2 termino .)
    OR              reduce using rule 98 (n -> / neur2_2 termino .)
    ;               reduce using rule 98 (n -> / neur2_2 termino .)
    )               reduce using rule 98 (n -> / neur2_2 termino .)
    ,               reduce using rule 98 (n -> / neur2_2 termino .)


state 225

    (134) callreturnfunc -> CALL ID neur24 ( s . ) neur26 ;

    )               shift and go to state 244


state 226

    (124) inlistset -> SET ( . CTEE , expresion )

    CTEE            shift and go to state 245


state 227

    (127) getlist -> GET ( . expresion )
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (151) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 151 (empty -> .)
    ID              reduce using rule 151 (empty -> .)
    CTEE            reduce using rule 151 (empty -> .)
    CTEF            reduce using rule 151 (empty -> .)
    CTEBOOL         reduce using rule 151 (empty -> .)
    CTECHAR         reduce using rule 151 (empty -> .)
    CALL            reduce using rule 151 (empty -> .)

    expresion                      shift and go to state 246
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 228

    (128) removelist -> REMOVE ( . expresion )
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (151) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 151 (empty -> .)
    ID              reduce using rule 151 (empty -> .)
    CTEE            reduce using rule 151 (empty -> .)
    CTEF            reduce using rule 151 (empty -> .)
    CTEBOOL         reduce using rule 151 (empty -> .)
    CTECHAR         reduce using rule 151 (empty -> .)
    CALL            reduce using rule 151 (empty -> .)

    expresion                      shift and go to state 247
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 229

    (126) length -> LENGTH ( . )

    )               shift and go to state 248


state 230

    (125) append -> APPEND ( . expresion )
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (151) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 151 (empty -> .)
    ID              reduce using rule 151 (empty -> .)
    CTEE            reduce using rule 151 (empty -> .)
    CTEF            reduce using rule 151 (empty -> .)
    CTEBOOL         reduce using rule 151 (empty -> .)
    CTECHAR         reduce using rule 151 (empty -> .)
    CALL            reduce using rule 151 (empty -> .)

    expresion                      shift and go to state 249
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 231

    (68) o -> AND neur9_1 subexpresion .

    ;               reduce using rule 68 (o -> AND neur9_1 subexpresion .)
    )               reduce using rule 68 (o -> AND neur9_1 subexpresion .)
    ,               reduce using rule 68 (o -> AND neur9_1 subexpresion .)


state 232

    (69) o -> OR neur9_2 subexpresion .

    ;               reduce using rule 69 (o -> OR neur9_2 subexpresion .)
    )               reduce using rule 69 (o -> OR neur9_2 subexpresion .)
    ,               reduce using rule 69 (o -> OR neur9_2 subexpresion .)


state 233

    (139) t -> , . s
    (135) s -> . empty
    (136) s -> . expresion neur25 t
    (151) empty -> .
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT

    )               reduce using rule 151 (empty -> .)
    (               reduce using rule 151 (empty -> .)
    ID              reduce using rule 151 (empty -> .)
    CTEE            reduce using rule 151 (empty -> .)
    CTEF            reduce using rule 151 (empty -> .)
    CTEBOOL         reduce using rule 151 (empty -> .)
    CTECHAR         reduce using rule 151 (empty -> .)
    CALL            reduce using rule 151 (empty -> .)
    NOT             shift and go to state 88

    expresion                      shift and go to state 179
    m                              shift and go to state 87
    s                              shift and go to state 250
    empty                          shift and go to state 181

state 234

    (136) s -> expresion neur25 t .

    )               reduce using rule 136 (s -> expresion neur25 t .)


state 235

    (138) t -> empty .

    )               reduce using rule 138 (t -> empty .)


state 236

    (140) callvoidfunc -> CALL ID neur24 ( s ) neur26 . ;

    ;               shift and go to state 251


state 237

    (132) play -> PLAY ( NOTA , CTEE ) ; .

    ID              reduce using rule 132 (play -> PLAY ( NOTA , CTEE ) ; .)
    IF              reduce using rule 132 (play -> PLAY ( NOTA , CTEE ) ; .)
    FOR             reduce using rule 132 (play -> PLAY ( NOTA , CTEE ) ; .)
    RETURN          reduce using rule 132 (play -> PLAY ( NOTA , CTEE ) ; .)
    WHILE           reduce using rule 132 (play -> PLAY ( NOTA , CTEE ) ; .)
    PLAY            reduce using rule 132 (play -> PLAY ( NOTA , CTEE ) ; .)
    PRINT           reduce using rule 132 (play -> PLAY ( NOTA , CTEE ) ; .)
    CALL            reduce using rule 132 (play -> PLAY ( NOTA , CTEE ) ; .)
    }               reduce using rule 132 (play -> PLAY ( NOTA , CTEE ) ; .)


state 238

    (57) for -> FOR ( asignacion neur18 expresion ; neur19 . asignacion ) neur21 bloque ; neur20
    (46) asignacion -> . ID = neur8 k ;

    ID              shift and go to state 75

    asignacion                     shift and go to state 252

state 239

    (50) asiglista -> NEW LIST ( ) .

    ;               reduce using rule 50 (asiglista -> NEW LIST ( ) .)


state 240

    (51) if -> IF ( expresion ) neur13 bloque l . ; neur15

    ;               shift and go to state 253


state 241

    (54) l -> ELSE . neur14 bloque
    (55) neur14 -> .

    {               reduce using rule 55 (neur14 -> .)

    neur14                         shift and go to state 254

state 242

    (53) l -> empty .

    ;               reduce using rule 53 (l -> empty .)


state 243

    (129) while -> WHILE ( neur16 expresion ) neur13 bloque ; . neur17
    (131) neur17 -> .

    ID              reduce using rule 131 (neur17 -> .)
    IF              reduce using rule 131 (neur17 -> .)
    FOR             reduce using rule 131 (neur17 -> .)
    RETURN          reduce using rule 131 (neur17 -> .)
    WHILE           reduce using rule 131 (neur17 -> .)
    PLAY            reduce using rule 131 (neur17 -> .)
    PRINT           reduce using rule 131 (neur17 -> .)
    CALL            reduce using rule 131 (neur17 -> .)
    }               reduce using rule 131 (neur17 -> .)

    neur17                         shift and go to state 255

state 244

    (134) callreturnfunc -> CALL ID neur24 ( s ) . neur26 ;
    (142) neur26 -> .

    ;               reduce using rule 142 (neur26 -> .)

    neur26                         shift and go to state 256

state 245

    (124) inlistset -> SET ( CTEE . , expresion )

    ,               shift and go to state 257


state 246

    (127) getlist -> GET ( expresion . )

    )               shift and go to state 258


state 247

    (128) removelist -> REMOVE ( expresion . )

    )               shift and go to state 259


state 248

    (126) length -> LENGTH ( ) .

    *               reduce using rule 126 (length -> LENGTH ( ) .)
    /               reduce using rule 126 (length -> LENGTH ( ) .)
    +               reduce using rule 126 (length -> LENGTH ( ) .)
    -               reduce using rule 126 (length -> LENGTH ( ) .)
    EQ              reduce using rule 126 (length -> LENGTH ( ) .)
    NOTEQ           reduce using rule 126 (length -> LENGTH ( ) .)
    >               reduce using rule 126 (length -> LENGTH ( ) .)
    <               reduce using rule 126 (length -> LENGTH ( ) .)
    MTHANEQ         reduce using rule 126 (length -> LENGTH ( ) .)
    LTHANEQ         reduce using rule 126 (length -> LENGTH ( ) .)
    AND             reduce using rule 126 (length -> LENGTH ( ) .)
    OR              reduce using rule 126 (length -> LENGTH ( ) .)
    ;               reduce using rule 126 (length -> LENGTH ( ) .)
    )               reduce using rule 126 (length -> LENGTH ( ) .)
    ,               reduce using rule 126 (length -> LENGTH ( ) .)


state 249

    (125) append -> APPEND ( expresion . )

    )               shift and go to state 260


state 250

    (139) t -> , s .

    )               reduce using rule 139 (t -> , s .)


state 251

    (140) callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .

    ID              reduce using rule 140 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    IF              reduce using rule 140 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    FOR             reduce using rule 140 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    RETURN          reduce using rule 140 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    WHILE           reduce using rule 140 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    PLAY            reduce using rule 140 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    PRINT           reduce using rule 140 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    CALL            reduce using rule 140 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    }               reduce using rule 140 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)


state 252

    (57) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion . ) neur21 bloque ; neur20

    )               shift and go to state 261


state 253

    (51) if -> IF ( expresion ) neur13 bloque l ; . neur15
    (56) neur15 -> .

    ID              reduce using rule 56 (neur15 -> .)
    IF              reduce using rule 56 (neur15 -> .)
    FOR             reduce using rule 56 (neur15 -> .)
    RETURN          reduce using rule 56 (neur15 -> .)
    WHILE           reduce using rule 56 (neur15 -> .)
    PLAY            reduce using rule 56 (neur15 -> .)
    PRINT           reduce using rule 56 (neur15 -> .)
    CALL            reduce using rule 56 (neur15 -> .)
    }               reduce using rule 56 (neur15 -> .)

    neur15                         shift and go to state 262

state 254

    (54) l -> ELSE neur14 . bloque
    (35) bloque -> . { i }

    {               shift and go to state 57

    bloque                         shift and go to state 263

state 255

    (129) while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .

    ID              reduce using rule 129 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    IF              reduce using rule 129 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    FOR             reduce using rule 129 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    RETURN          reduce using rule 129 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    WHILE           reduce using rule 129 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    PLAY            reduce using rule 129 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    PRINT           reduce using rule 129 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    CALL            reduce using rule 129 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    }               reduce using rule 129 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)


state 256

    (134) callreturnfunc -> CALL ID neur24 ( s ) neur26 . ;

    ;               shift and go to state 264


state 257

    (124) inlistset -> SET ( CTEE , . expresion )
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (151) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 151 (empty -> .)
    ID              reduce using rule 151 (empty -> .)
    CTEE            reduce using rule 151 (empty -> .)
    CTEF            reduce using rule 151 (empty -> .)
    CTEBOOL         reduce using rule 151 (empty -> .)
    CTECHAR         reduce using rule 151 (empty -> .)
    CALL            reduce using rule 151 (empty -> .)

    expresion                      shift and go to state 265
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 258

    (127) getlist -> GET ( expresion ) .

    *               reduce using rule 127 (getlist -> GET ( expresion ) .)
    /               reduce using rule 127 (getlist -> GET ( expresion ) .)
    +               reduce using rule 127 (getlist -> GET ( expresion ) .)
    -               reduce using rule 127 (getlist -> GET ( expresion ) .)
    EQ              reduce using rule 127 (getlist -> GET ( expresion ) .)
    NOTEQ           reduce using rule 127 (getlist -> GET ( expresion ) .)
    >               reduce using rule 127 (getlist -> GET ( expresion ) .)
    <               reduce using rule 127 (getlist -> GET ( expresion ) .)
    MTHANEQ         reduce using rule 127 (getlist -> GET ( expresion ) .)
    LTHANEQ         reduce using rule 127 (getlist -> GET ( expresion ) .)
    AND             reduce using rule 127 (getlist -> GET ( expresion ) .)
    OR              reduce using rule 127 (getlist -> GET ( expresion ) .)
    ;               reduce using rule 127 (getlist -> GET ( expresion ) .)
    )               reduce using rule 127 (getlist -> GET ( expresion ) .)
    ,               reduce using rule 127 (getlist -> GET ( expresion ) .)


state 259

    (128) removelist -> REMOVE ( expresion ) .

    *               reduce using rule 128 (removelist -> REMOVE ( expresion ) .)
    /               reduce using rule 128 (removelist -> REMOVE ( expresion ) .)
    +               reduce using rule 128 (removelist -> REMOVE ( expresion ) .)
    -               reduce using rule 128 (removelist -> REMOVE ( expresion ) .)
    EQ              reduce using rule 128 (removelist -> REMOVE ( expresion ) .)
    NOTEQ           reduce using rule 128 (removelist -> REMOVE ( expresion ) .)
    >               reduce using rule 128 (removelist -> REMOVE ( expresion ) .)
    <               reduce using rule 128 (removelist -> REMOVE ( expresion ) .)
    MTHANEQ         reduce using rule 128 (removelist -> REMOVE ( expresion ) .)
    LTHANEQ         reduce using rule 128 (removelist -> REMOVE ( expresion ) .)
    AND             reduce using rule 128 (removelist -> REMOVE ( expresion ) .)
    OR              reduce using rule 128 (removelist -> REMOVE ( expresion ) .)
    ;               reduce using rule 128 (removelist -> REMOVE ( expresion ) .)
    )               reduce using rule 128 (removelist -> REMOVE ( expresion ) .)
    ,               reduce using rule 128 (removelist -> REMOVE ( expresion ) .)


state 260

    (125) append -> APPEND ( expresion ) .

    *               reduce using rule 125 (append -> APPEND ( expresion ) .)
    /               reduce using rule 125 (append -> APPEND ( expresion ) .)
    +               reduce using rule 125 (append -> APPEND ( expresion ) .)
    -               reduce using rule 125 (append -> APPEND ( expresion ) .)
    EQ              reduce using rule 125 (append -> APPEND ( expresion ) .)
    NOTEQ           reduce using rule 125 (append -> APPEND ( expresion ) .)
    >               reduce using rule 125 (append -> APPEND ( expresion ) .)
    <               reduce using rule 125 (append -> APPEND ( expresion ) .)
    MTHANEQ         reduce using rule 125 (append -> APPEND ( expresion ) .)
    LTHANEQ         reduce using rule 125 (append -> APPEND ( expresion ) .)
    AND             reduce using rule 125 (append -> APPEND ( expresion ) .)
    OR              reduce using rule 125 (append -> APPEND ( expresion ) .)
    ;               reduce using rule 125 (append -> APPEND ( expresion ) .)
    )               reduce using rule 125 (append -> APPEND ( expresion ) .)
    ,               reduce using rule 125 (append -> APPEND ( expresion ) .)


state 261

    (57) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) . neur21 bloque ; neur20
    (60) neur21 -> .

    {               reduce using rule 60 (neur21 -> .)

    neur21                         shift and go to state 266

state 262

    (51) if -> IF ( expresion ) neur13 bloque l ; neur15 .

    ID              reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; neur15 .)
    IF              reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; neur15 .)
    FOR             reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; neur15 .)
    RETURN          reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; neur15 .)
    WHILE           reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; neur15 .)
    PLAY            reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; neur15 .)
    PRINT           reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; neur15 .)
    CALL            reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; neur15 .)
    }               reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; neur15 .)


state 263

    (54) l -> ELSE neur14 bloque .

    ;               reduce using rule 54 (l -> ELSE neur14 bloque .)


state 264

    (134) callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .

    *               reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    /               reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    +               reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    -               reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    EQ              reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    NOTEQ           reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    >               reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    <               reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    MTHANEQ         reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    LTHANEQ         reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    AND             reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    OR              reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    ;               reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    )               reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    ,               reduce using rule 134 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)


state 265

    (124) inlistset -> SET ( CTEE , expresion . )

    )               shift and go to state 267


state 266

    (57) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 . bloque ; neur20
    (35) bloque -> . { i }

    {               shift and go to state 57

    bloque                         shift and go to state 268

state 267

    (124) inlistset -> SET ( CTEE , expresion ) .

    *               reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)
    /               reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)
    +               reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)
    -               reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)
    EQ              reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)
    NOTEQ           reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)
    >               reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)
    <               reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)
    MTHANEQ         reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)
    LTHANEQ         reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)
    AND             reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)
    OR              reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)
    ;               reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)
    )               reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)
    ,               reduce using rule 124 (inlistset -> SET ( CTEE , expresion ) .)


state 268

    (57) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque . ; neur20

    ;               shift and go to state 269


state 269

    (57) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; . neur20
    (61) neur20 -> .

    ID              reduce using rule 61 (neur20 -> .)
    IF              reduce using rule 61 (neur20 -> .)
    FOR             reduce using rule 61 (neur20 -> .)
    RETURN          reduce using rule 61 (neur20 -> .)
    WHILE           reduce using rule 61 (neur20 -> .)
    PLAY            reduce using rule 61 (neur20 -> .)
    PRINT           reduce using rule 61 (neur20 -> .)
    CALL            reduce using rule 61 (neur20 -> .)
    }               reduce using rule 61 (neur20 -> .)

    neur20                         shift and go to state 270

state 270

    (57) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .

    ID              reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    IF              reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    FOR             reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    RETURN          reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    WHILE           reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    PLAY            reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    PRINT           reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    CALL            reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    }               reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 10 resolved using rule (a -> empty)
WARNING: rejected rule (b -> empty) in state 10
WARNING: reduce/reduce conflict in state 28 resolved using rule (c -> empty)
WARNING: rejected rule (d -> empty) in state 28
WARNING: reduce/reduce conflict in state 56 resolved using rule (f -> empty)
WARNING: rejected rule (g -> empty) in state 56
WARNING: reduce/reduce conflict in state 90 resolved using rule (i -> empty)
WARNING: rejected rule (j -> empty) in state 90
WARNING: Rule (b -> empty) is never reduced
WARNING: Rule (d -> empty) is never reduced
WARNING: Rule (g -> empty) is never reduced
WARNING: Rule (j -> empty) is never reduced
