Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programa
Rule 1     programa -> creadirprocglobal a c cancion
Rule 2     creadirprocglobal -> <empty>
Rule 3     a -> empty
Rule 4     a -> vars b
Rule 5     b -> empty
Rule 6     b -> a
Rule 7     c -> empty
Rule 8     c -> funcion d
Rule 9     d -> empty
Rule 10    d -> c
Rule 11    vars -> VAR v : tipo ;
Rule 12    v -> ID
Rule 13    funcion -> FUNC tipo ID meterfuncion ( params ) f bloque
Rule 14    meterfuncion -> <empty>
Rule 15    f -> empty
Rule 16    f -> vars g
Rule 17    g -> empty
Rule 18    g -> f
Rule 19    params -> empty
Rule 20    params -> tipo ID meterparams h
Rule 21    meterparams -> <empty>
Rule 22    h -> empty
Rule 23    h -> , params
Rule 24    i -> empty
Rule 25    i -> estatuto j
Rule 26    j -> empty
Rule 27    j -> i
Rule 28    bloque -> { i }
Rule 29    cancion -> CANCION ( CTEE ) metercancion f bloque
Rule 30    metercancion -> <empty>
Rule 31    estatuto -> asignacion
Rule 32    estatuto -> if
Rule 33    estatuto -> for
Rule 34    estatuto -> return
Rule 35    estatuto -> while
Rule 36    estatuto -> play
Rule 37    estatuto -> print
Rule 38    asignacion -> ID = k ;
Rule 39    k -> expresion
Rule 40    k -> asiglista
Rule 41    asiglista -> NEW LIST ( )
Rule 42    if -> IF ( expresion ) bloque l ;
Rule 43    l -> empty
Rule 44    l -> ELSE bloque
Rule 45    for -> FOR ( asignacion expresion asignacion ) bloque ;
Rule 46    expresion -> m subexpresion
Rule 47    m -> empty
Rule 48    m -> NOT
Rule 49    termino -> factor n
Rule 50    n -> empty
Rule 51    n -> * termino
Rule 52    n -> / termino
Rule 53    subexpresion -> exp o
Rule 54    o -> empty
Rule 55    o -> AND subexpresion
Rule 56    o -> OR subexpresion
Rule 57    exp -> nexp p
Rule 58    p -> empty
Rule 59    p -> EQ nexp
Rule 60    p -> NOTEQ nexp
Rule 61    p -> > nexp
Rule 62    p -> < nexp
Rule 63    p -> MTHANEQ nexp
Rule 64    p -> LTHANEQ nexp
Rule 65    nexp -> termino q
Rule 66    q -> empty
Rule 67    q -> + nexp
Rule 68    q -> - nexp
Rule 69    factor -> ( expresion )
Rule 70    factor -> w varcte
Rule 71    w -> empty
Rule 72    w -> -
Rule 73    varcte -> ID r
Rule 74    varcte -> CTEE
Rule 75    varcte -> CTEF
Rule 76    varcte -> CTEBOOL
Rule 77    varcte -> callfunc
Rule 78    varcte -> CTECHAR
Rule 79    r -> empty
Rule 80    r -> oplista
Rule 81    oplista -> ID . x
Rule 82    x -> inlistset
Rule 83    x -> append
Rule 84    x -> length
Rule 85    x -> getlist
Rule 86    x -> removelist
Rule 87    inlistset -> SET ( CTEE , expresion )
Rule 88    append -> APPEND ( expresion )
Rule 89    length -> LENGTH ( )
Rule 90    getlist -> GET ( expresion )
Rule 91    removelist -> REMOVE ( expresion )
Rule 92    while -> WHILE ( expresion ) bloque ;
Rule 93    play -> PLAY ( NOTA , CTEE ) ;
Rule 94    print -> PRINT expresion ;
Rule 95    callfunc -> CALL ID ( s ) ;
Rule 96    s -> empty
Rule 97    s -> expresion t
Rule 98    t -> empty
Rule 99    t -> , s
Rule 100   return -> RETURN ( expresion ) ;
Rule 101   tipo -> u y
Rule 102   u -> empty
Rule 103   u -> LIST
Rule 104   y -> INT
Rule 105   y -> CHAR
Rule 106   y -> FLOAT
Rule 107   y -> BOOL
Rule 108   empty -> <empty>

Terminals, with rules where they appear

(                    : 13 29 41 42 45 69 87 88 89 90 91 92 93 95 100
)                    : 13 29 41 42 45 69 87 88 89 90 91 92 93 95 100
*                    : 51
+                    : 67
,                    : 23 87 93 99
-                    : 68 72
.                    : 81
/                    : 52
:                    : 11
;                    : 11 38 42 45 92 93 94 95 100
<                    : 62
=                    : 38
>                    : 61
AND                  : 55
APPEND               : 88
BOOL                 : 107
CALL                 : 95
CANCION              : 29
CHAR                 : 105
CTEBOOL              : 76
CTECHAR              : 78
CTEE                 : 29 74 87 93
CTEF                 : 75
ELSE                 : 44
EQ                   : 59
FLOAT                : 106
FOR                  : 45
FUNC                 : 13
GET                  : 90
ID                   : 12 13 20 38 73 81 95
IF                   : 42
INT                  : 104
LENGTH               : 89
LIST                 : 41 103
LTHANEQ              : 64
MTHANEQ              : 63
NEW                  : 41
NOT                  : 48
NOTA                 : 93
NOTEQ                : 60
OR                   : 56
PLAY                 : 93
PRINT                : 94
REMOVE               : 91
RETURN               : 100
SET                  : 87
VAR                  : 11
WHILE                : 92
error                : 
{                    : 28
}                    : 28

Nonterminals, with rules where they appear

a                    : 1 6
append               : 83
asiglista            : 40
asignacion           : 31 45 45
b                    : 4
bloque               : 13 29 42 44 45 92
c                    : 1 10
callfunc             : 77
cancion              : 1
creadirprocglobal    : 1
d                    : 8
empty                : 3 5 7 9 15 17 19 22 24 26 43 47 50 54 58 66 71 79 96 98 102
estatuto             : 25
exp                  : 53
expresion            : 39 42 45 69 87 88 90 91 92 94 97 100
f                    : 13 18 29
factor               : 49
for                  : 33
funcion              : 8
g                    : 16
getlist              : 85
h                    : 20
i                    : 27 28
if                   : 32
inlistset            : 82
j                    : 25
k                    : 38
l                    : 42
length               : 84
m                    : 46
metercancion         : 29
meterfuncion         : 13
meterparams          : 20
n                    : 49
nexp                 : 57 59 60 61 62 63 64 67 68
o                    : 53
oplista              : 80
p                    : 57
params               : 13 23
play                 : 36
print                : 37
programa             : 0
q                    : 65
r                    : 73
removelist           : 86
return               : 34
s                    : 95 99
subexpresion         : 46 55 56
t                    : 97
termino              : 51 52 65
tipo                 : 11 13 20
u                    : 101
v                    : 11
varcte               : 70
vars                 : 4 16
w                    : 70
while                : 35
x                    : 81
y                    : 101

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . creadirprocglobal a c cancion
    (2) creadirprocglobal -> .

    VAR             reduce using rule 2 (creadirprocglobal -> .)
    FUNC            reduce using rule 2 (creadirprocglobal -> .)
    CANCION         reduce using rule 2 (creadirprocglobal -> .)

    programa                       shift and go to state 1
    creadirprocglobal              shift and go to state 2

state 1

    (0) S' -> programa .



state 2

    (1) programa -> creadirprocglobal . a c cancion
    (3) a -> . empty
    (4) a -> . vars b
    (108) empty -> .
    (11) vars -> . VAR v : tipo ;

    FUNC            reduce using rule 108 (empty -> .)
    CANCION         reduce using rule 108 (empty -> .)
    VAR             shift and go to state 5

    a                              shift and go to state 3
    vars                           shift and go to state 4
    empty                          shift and go to state 6

state 3

    (1) programa -> creadirprocglobal a . c cancion
    (7) c -> . empty
    (8) c -> . funcion d
    (108) empty -> .
    (13) funcion -> . FUNC tipo ID meterfuncion ( params ) f bloque

    CANCION         reduce using rule 108 (empty -> .)
    FUNC            shift and go to state 8

    c                              shift and go to state 7
    empty                          shift and go to state 9
    funcion                        shift and go to state 10

state 4

    (4) a -> vars . b
    (5) b -> . empty
    (6) b -> . a
    (108) empty -> .
    (3) a -> . empty
    (4) a -> . vars b
    (11) vars -> . VAR v : tipo ;

    FUNC            reduce using rule 108 (empty -> .)
    CANCION         reduce using rule 108 (empty -> .)
    VAR             shift and go to state 5

    a                              shift and go to state 11
    b                              shift and go to state 12
    vars                           shift and go to state 4
    empty                          shift and go to state 13

state 5

    (11) vars -> VAR . v : tipo ;
    (12) v -> . ID

    ID              shift and go to state 15

    v                              shift and go to state 14

state 6

    (3) a -> empty .

    FUNC            reduce using rule 3 (a -> empty .)
    CANCION         reduce using rule 3 (a -> empty .)


state 7

    (1) programa -> creadirprocglobal a c . cancion
    (29) cancion -> . CANCION ( CTEE ) metercancion f bloque

    CANCION         shift and go to state 16

    cancion                        shift and go to state 17

state 8

    (13) funcion -> FUNC . tipo ID meterfuncion ( params ) f bloque
    (101) tipo -> . u y
    (102) u -> . empty
    (103) u -> . LIST
    (108) empty -> .

    LIST            shift and go to state 19
    INT             reduce using rule 108 (empty -> .)
    CHAR            reduce using rule 108 (empty -> .)
    FLOAT           reduce using rule 108 (empty -> .)
    BOOL            reduce using rule 108 (empty -> .)

    tipo                           shift and go to state 18
    u                              shift and go to state 20
    empty                          shift and go to state 21

state 9

    (7) c -> empty .

    CANCION         reduce using rule 7 (c -> empty .)


state 10

    (8) c -> funcion . d
    (9) d -> . empty
    (10) d -> . c
    (108) empty -> .
    (7) c -> . empty
    (8) c -> . funcion d
    (13) funcion -> . FUNC tipo ID meterfuncion ( params ) f bloque

    CANCION         reduce using rule 108 (empty -> .)
    FUNC            shift and go to state 8

    c                              shift and go to state 22
    d                              shift and go to state 23
    empty                          shift and go to state 24
    funcion                        shift and go to state 10

state 11

    (6) b -> a .

    FUNC            reduce using rule 6 (b -> a .)
    CANCION         reduce using rule 6 (b -> a .)


state 12

    (4) a -> vars b .

    FUNC            reduce using rule 4 (a -> vars b .)
    CANCION         reduce using rule 4 (a -> vars b .)


state 13

    (5) b -> empty .
    (3) a -> empty .

  ! reduce/reduce conflict for FUNC resolved using rule 3 (a -> empty .)
  ! reduce/reduce conflict for CANCION resolved using rule 3 (a -> empty .)
    FUNC            reduce using rule 3 (a -> empty .)
    CANCION         reduce using rule 3 (a -> empty .)

  ! FUNC            [ reduce using rule 5 (b -> empty .) ]
  ! CANCION         [ reduce using rule 5 (b -> empty .) ]


state 14

    (11) vars -> VAR v . : tipo ;

    :               shift and go to state 25


state 15

    (12) v -> ID .

    :               reduce using rule 12 (v -> ID .)


state 16

    (29) cancion -> CANCION . ( CTEE ) metercancion f bloque

    (               shift and go to state 26


state 17

    (1) programa -> creadirprocglobal a c cancion .

    $end            reduce using rule 1 (programa -> creadirprocglobal a c cancion .)


state 18

    (13) funcion -> FUNC tipo . ID meterfuncion ( params ) f bloque

    ID              shift and go to state 27


state 19

    (103) u -> LIST .

    INT             reduce using rule 103 (u -> LIST .)
    CHAR            reduce using rule 103 (u -> LIST .)
    FLOAT           reduce using rule 103 (u -> LIST .)
    BOOL            reduce using rule 103 (u -> LIST .)


state 20

    (101) tipo -> u . y
    (104) y -> . INT
    (105) y -> . CHAR
    (106) y -> . FLOAT
    (107) y -> . BOOL

    INT             shift and go to state 28
    CHAR            shift and go to state 30
    FLOAT           shift and go to state 29
    BOOL            shift and go to state 32

    y                              shift and go to state 31

state 21

    (102) u -> empty .

    INT             reduce using rule 102 (u -> empty .)
    CHAR            reduce using rule 102 (u -> empty .)
    FLOAT           reduce using rule 102 (u -> empty .)
    BOOL            reduce using rule 102 (u -> empty .)


state 22

    (10) d -> c .

    CANCION         reduce using rule 10 (d -> c .)


state 23

    (8) c -> funcion d .

    CANCION         reduce using rule 8 (c -> funcion d .)


state 24

    (9) d -> empty .
    (7) c -> empty .

  ! reduce/reduce conflict for CANCION resolved using rule 7 (c -> empty .)
    CANCION         reduce using rule 7 (c -> empty .)

  ! CANCION         [ reduce using rule 9 (d -> empty .) ]


state 25

    (11) vars -> VAR v : . tipo ;
    (101) tipo -> . u y
    (102) u -> . empty
    (103) u -> . LIST
    (108) empty -> .

    LIST            shift and go to state 19
    INT             reduce using rule 108 (empty -> .)
    CHAR            reduce using rule 108 (empty -> .)
    FLOAT           reduce using rule 108 (empty -> .)
    BOOL            reduce using rule 108 (empty -> .)

    u                              shift and go to state 20
    empty                          shift and go to state 21
    tipo                           shift and go to state 33

state 26

    (29) cancion -> CANCION ( . CTEE ) metercancion f bloque

    CTEE            shift and go to state 34


state 27

    (13) funcion -> FUNC tipo ID . meterfuncion ( params ) f bloque
    (14) meterfuncion -> .

    (               reduce using rule 14 (meterfuncion -> .)

    meterfuncion                   shift and go to state 35

state 28

    (104) y -> INT .

    ID              reduce using rule 104 (y -> INT .)
    ;               reduce using rule 104 (y -> INT .)


state 29

    (106) y -> FLOAT .

    ID              reduce using rule 106 (y -> FLOAT .)
    ;               reduce using rule 106 (y -> FLOAT .)


state 30

    (105) y -> CHAR .

    ID              reduce using rule 105 (y -> CHAR .)
    ;               reduce using rule 105 (y -> CHAR .)


state 31

    (101) tipo -> u y .

    ID              reduce using rule 101 (tipo -> u y .)
    ;               reduce using rule 101 (tipo -> u y .)


state 32

    (107) y -> BOOL .

    ID              reduce using rule 107 (y -> BOOL .)
    ;               reduce using rule 107 (y -> BOOL .)


state 33

    (11) vars -> VAR v : tipo . ;

    ;               shift and go to state 36


state 34

    (29) cancion -> CANCION ( CTEE . ) metercancion f bloque

    )               shift and go to state 37


state 35

    (13) funcion -> FUNC tipo ID meterfuncion . ( params ) f bloque

    (               shift and go to state 38


state 36

    (11) vars -> VAR v : tipo ; .

    VAR             reduce using rule 11 (vars -> VAR v : tipo ; .)
    FUNC            reduce using rule 11 (vars -> VAR v : tipo ; .)
    CANCION         reduce using rule 11 (vars -> VAR v : tipo ; .)
    {               reduce using rule 11 (vars -> VAR v : tipo ; .)


state 37

    (29) cancion -> CANCION ( CTEE ) . metercancion f bloque
    (30) metercancion -> .

    VAR             reduce using rule 30 (metercancion -> .)
    {               reduce using rule 30 (metercancion -> .)

    metercancion                   shift and go to state 39

state 38

    (13) funcion -> FUNC tipo ID meterfuncion ( . params ) f bloque
    (19) params -> . empty
    (20) params -> . tipo ID meterparams h
    (108) empty -> .
    (101) tipo -> . u y
    (102) u -> . empty
    (103) u -> . LIST

    )               reduce using rule 108 (empty -> .)
    INT             reduce using rule 108 (empty -> .)
    CHAR            reduce using rule 108 (empty -> .)
    FLOAT           reduce using rule 108 (empty -> .)
    BOOL            reduce using rule 108 (empty -> .)
    LIST            shift and go to state 19

    tipo                           shift and go to state 40
    params                         shift and go to state 41
    u                              shift and go to state 20
    empty                          shift and go to state 42

state 39

    (29) cancion -> CANCION ( CTEE ) metercancion . f bloque
    (15) f -> . empty
    (16) f -> . vars g
    (108) empty -> .
    (11) vars -> . VAR v : tipo ;

    {               reduce using rule 108 (empty -> .)
    VAR             shift and go to state 5

    vars                           shift and go to state 43
    f                              shift and go to state 44
    empty                          shift and go to state 45

state 40

    (20) params -> tipo . ID meterparams h

    ID              shift and go to state 46


state 41

    (13) funcion -> FUNC tipo ID meterfuncion ( params . ) f bloque

    )               shift and go to state 47


state 42

    (19) params -> empty .
    (102) u -> empty .

    )               reduce using rule 19 (params -> empty .)
    INT             reduce using rule 102 (u -> empty .)
    CHAR            reduce using rule 102 (u -> empty .)
    FLOAT           reduce using rule 102 (u -> empty .)
    BOOL            reduce using rule 102 (u -> empty .)


state 43

    (16) f -> vars . g
    (17) g -> . empty
    (18) g -> . f
    (108) empty -> .
    (15) f -> . empty
    (16) f -> . vars g
    (11) vars -> . VAR v : tipo ;

    {               reduce using rule 108 (empty -> .)
    VAR             shift and go to state 5

    g                              shift and go to state 48
    f                              shift and go to state 49
    vars                           shift and go to state 43
    empty                          shift and go to state 50

state 44

    (29) cancion -> CANCION ( CTEE ) metercancion f . bloque
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 52

state 45

    (15) f -> empty .

    {               reduce using rule 15 (f -> empty .)


state 46

    (20) params -> tipo ID . meterparams h
    (21) meterparams -> .

    ,               reduce using rule 21 (meterparams -> .)
    )               reduce using rule 21 (meterparams -> .)

    meterparams                    shift and go to state 53

state 47

    (13) funcion -> FUNC tipo ID meterfuncion ( params ) . f bloque
    (15) f -> . empty
    (16) f -> . vars g
    (108) empty -> .
    (11) vars -> . VAR v : tipo ;

    {               reduce using rule 108 (empty -> .)
    VAR             shift and go to state 5

    vars                           shift and go to state 43
    f                              shift and go to state 54
    empty                          shift and go to state 45

state 48

    (16) f -> vars g .

    {               reduce using rule 16 (f -> vars g .)


state 49

    (18) g -> f .

    {               reduce using rule 18 (g -> f .)


state 50

    (17) g -> empty .
    (15) f -> empty .

  ! reduce/reduce conflict for { resolved using rule 15 (f -> empty .)
    {               reduce using rule 15 (f -> empty .)

  ! {               [ reduce using rule 17 (g -> empty .) ]


state 51

    (28) bloque -> { . i }
    (24) i -> . empty
    (25) i -> . estatuto j
    (108) empty -> .
    (31) estatuto -> . asignacion
    (32) estatuto -> . if
    (33) estatuto -> . for
    (34) estatuto -> . return
    (35) estatuto -> . while
    (36) estatuto -> . play
    (37) estatuto -> . print
    (38) asignacion -> . ID = k ;
    (42) if -> . IF ( expresion ) bloque l ;
    (45) for -> . FOR ( asignacion expresion asignacion ) bloque ;
    (100) return -> . RETURN ( expresion ) ;
    (92) while -> . WHILE ( expresion ) bloque ;
    (93) play -> . PLAY ( NOTA , CTEE ) ;
    (94) print -> . PRINT expresion ;

    }               reduce using rule 108 (empty -> .)
    ID              shift and go to state 67
    IF              shift and go to state 68
    FOR             shift and go to state 66
    RETURN          shift and go to state 55
    WHILE           shift and go to state 57
    PLAY            shift and go to state 56
    PRINT           shift and go to state 58

    play                           shift and go to state 64
    return                         shift and go to state 65
    for                            shift and go to state 60
    asignacion                     shift and go to state 69
    i                              shift and go to state 70
    estatuto                       shift and go to state 61
    while                          shift and go to state 71
    print                          shift and go to state 62
    empty                          shift and go to state 63
    if                             shift and go to state 59

state 52

    (29) cancion -> CANCION ( CTEE ) metercancion f bloque .

    $end            reduce using rule 29 (cancion -> CANCION ( CTEE ) metercancion f bloque .)


state 53

    (20) params -> tipo ID meterparams . h
    (22) h -> . empty
    (23) h -> . , params
    (108) empty -> .

    ,               shift and go to state 73
    )               reduce using rule 108 (empty -> .)

    h                              shift and go to state 72
    empty                          shift and go to state 74

state 54

    (13) funcion -> FUNC tipo ID meterfuncion ( params ) f . bloque
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 75

state 55

    (100) return -> RETURN . ( expresion ) ;

    (               shift and go to state 76


state 56

    (93) play -> PLAY . ( NOTA , CTEE ) ;

    (               shift and go to state 77


state 57

    (92) while -> WHILE . ( expresion ) bloque ;

    (               shift and go to state 78


state 58

    (94) print -> PRINT . expresion ;
    (46) expresion -> . m subexpresion
    (47) m -> . empty
    (48) m -> . NOT
    (108) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    expresion                      shift and go to state 79
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 59

    (32) estatuto -> if .

    ID              reduce using rule 32 (estatuto -> if .)
    IF              reduce using rule 32 (estatuto -> if .)
    FOR             reduce using rule 32 (estatuto -> if .)
    RETURN          reduce using rule 32 (estatuto -> if .)
    WHILE           reduce using rule 32 (estatuto -> if .)
    PLAY            reduce using rule 32 (estatuto -> if .)
    PRINT           reduce using rule 32 (estatuto -> if .)
    }               reduce using rule 32 (estatuto -> if .)


state 60

    (33) estatuto -> for .

    ID              reduce using rule 33 (estatuto -> for .)
    IF              reduce using rule 33 (estatuto -> for .)
    FOR             reduce using rule 33 (estatuto -> for .)
    RETURN          reduce using rule 33 (estatuto -> for .)
    WHILE           reduce using rule 33 (estatuto -> for .)
    PLAY            reduce using rule 33 (estatuto -> for .)
    PRINT           reduce using rule 33 (estatuto -> for .)
    }               reduce using rule 33 (estatuto -> for .)


state 61

    (25) i -> estatuto . j
    (26) j -> . empty
    (27) j -> . i
    (108) empty -> .
    (24) i -> . empty
    (25) i -> . estatuto j
    (31) estatuto -> . asignacion
    (32) estatuto -> . if
    (33) estatuto -> . for
    (34) estatuto -> . return
    (35) estatuto -> . while
    (36) estatuto -> . play
    (37) estatuto -> . print
    (38) asignacion -> . ID = k ;
    (42) if -> . IF ( expresion ) bloque l ;
    (45) for -> . FOR ( asignacion expresion asignacion ) bloque ;
    (100) return -> . RETURN ( expresion ) ;
    (92) while -> . WHILE ( expresion ) bloque ;
    (93) play -> . PLAY ( NOTA , CTEE ) ;
    (94) print -> . PRINT expresion ;

    }               reduce using rule 108 (empty -> .)
    ID              shift and go to state 67
    IF              shift and go to state 68
    FOR             shift and go to state 66
    RETURN          shift and go to state 55
    WHILE           shift and go to state 57
    PLAY            shift and go to state 56
    PRINT           shift and go to state 58

    play                           shift and go to state 64
    j                              shift and go to state 85
    return                         shift and go to state 65
    for                            shift and go to state 60
    asignacion                     shift and go to state 69
    i                              shift and go to state 84
    estatuto                       shift and go to state 61
    while                          shift and go to state 71
    print                          shift and go to state 62
    empty                          shift and go to state 83
    if                             shift and go to state 59

state 62

    (37) estatuto -> print .

    ID              reduce using rule 37 (estatuto -> print .)
    IF              reduce using rule 37 (estatuto -> print .)
    FOR             reduce using rule 37 (estatuto -> print .)
    RETURN          reduce using rule 37 (estatuto -> print .)
    WHILE           reduce using rule 37 (estatuto -> print .)
    PLAY            reduce using rule 37 (estatuto -> print .)
    PRINT           reduce using rule 37 (estatuto -> print .)
    }               reduce using rule 37 (estatuto -> print .)


state 63

    (24) i -> empty .

    }               reduce using rule 24 (i -> empty .)


state 64

    (36) estatuto -> play .

    ID              reduce using rule 36 (estatuto -> play .)
    IF              reduce using rule 36 (estatuto -> play .)
    FOR             reduce using rule 36 (estatuto -> play .)
    RETURN          reduce using rule 36 (estatuto -> play .)
    WHILE           reduce using rule 36 (estatuto -> play .)
    PLAY            reduce using rule 36 (estatuto -> play .)
    PRINT           reduce using rule 36 (estatuto -> play .)
    }               reduce using rule 36 (estatuto -> play .)


state 65

    (34) estatuto -> return .

    ID              reduce using rule 34 (estatuto -> return .)
    IF              reduce using rule 34 (estatuto -> return .)
    FOR             reduce using rule 34 (estatuto -> return .)
    RETURN          reduce using rule 34 (estatuto -> return .)
    WHILE           reduce using rule 34 (estatuto -> return .)
    PLAY            reduce using rule 34 (estatuto -> return .)
    PRINT           reduce using rule 34 (estatuto -> return .)
    }               reduce using rule 34 (estatuto -> return .)


state 66

    (45) for -> FOR . ( asignacion expresion asignacion ) bloque ;

    (               shift and go to state 86


state 67

    (38) asignacion -> ID . = k ;

    =               shift and go to state 87


state 68

    (42) if -> IF . ( expresion ) bloque l ;

    (               shift and go to state 88


state 69

    (31) estatuto -> asignacion .

    ID              reduce using rule 31 (estatuto -> asignacion .)
    IF              reduce using rule 31 (estatuto -> asignacion .)
    FOR             reduce using rule 31 (estatuto -> asignacion .)
    RETURN          reduce using rule 31 (estatuto -> asignacion .)
    WHILE           reduce using rule 31 (estatuto -> asignacion .)
    PLAY            reduce using rule 31 (estatuto -> asignacion .)
    PRINT           reduce using rule 31 (estatuto -> asignacion .)
    }               reduce using rule 31 (estatuto -> asignacion .)


state 70

    (28) bloque -> { i . }

    }               shift and go to state 89


state 71

    (35) estatuto -> while .

    ID              reduce using rule 35 (estatuto -> while .)
    IF              reduce using rule 35 (estatuto -> while .)
    FOR             reduce using rule 35 (estatuto -> while .)
    RETURN          reduce using rule 35 (estatuto -> while .)
    WHILE           reduce using rule 35 (estatuto -> while .)
    PLAY            reduce using rule 35 (estatuto -> while .)
    PRINT           reduce using rule 35 (estatuto -> while .)
    }               reduce using rule 35 (estatuto -> while .)


state 72

    (20) params -> tipo ID meterparams h .

    )               reduce using rule 20 (params -> tipo ID meterparams h .)


state 73

    (23) h -> , . params
    (19) params -> . empty
    (20) params -> . tipo ID meterparams h
    (108) empty -> .
    (101) tipo -> . u y
    (102) u -> . empty
    (103) u -> . LIST

    )               reduce using rule 108 (empty -> .)
    INT             reduce using rule 108 (empty -> .)
    CHAR            reduce using rule 108 (empty -> .)
    FLOAT           reduce using rule 108 (empty -> .)
    BOOL            reduce using rule 108 (empty -> .)
    LIST            shift and go to state 19

    tipo                           shift and go to state 40
    u                              shift and go to state 20
    params                         shift and go to state 90
    empty                          shift and go to state 42

state 74

    (22) h -> empty .

    )               reduce using rule 22 (h -> empty .)


state 75

    (13) funcion -> FUNC tipo ID meterfuncion ( params ) f bloque .

    FUNC            reduce using rule 13 (funcion -> FUNC tipo ID meterfuncion ( params ) f bloque .)
    CANCION         reduce using rule 13 (funcion -> FUNC tipo ID meterfuncion ( params ) f bloque .)


state 76

    (100) return -> RETURN ( . expresion ) ;
    (46) expresion -> . m subexpresion
    (47) m -> . empty
    (48) m -> . NOT
    (108) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    expresion                      shift and go to state 91
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 77

    (93) play -> PLAY ( . NOTA , CTEE ) ;

    NOTA            shift and go to state 92


state 78

    (92) while -> WHILE ( . expresion ) bloque ;
    (46) expresion -> . m subexpresion
    (47) m -> . empty
    (48) m -> . NOT
    (108) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    expresion                      shift and go to state 93
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 79

    (94) print -> PRINT expresion . ;

    ;               shift and go to state 94


state 80

    (46) expresion -> m . subexpresion
    (53) subexpresion -> . exp o
    (57) exp -> . nexp p
    (65) nexp -> . termino q
    (49) termino -> . factor n
    (69) factor -> . ( expresion )
    (70) factor -> . w varcte
    (71) w -> . empty
    (72) w -> . -
    (108) empty -> .

    (               shift and go to state 97
    -               shift and go to state 95
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    w                              shift and go to state 96
    nexp                           shift and go to state 98
    subexpresion                   shift and go to state 99
    termino                        shift and go to state 100
    exp                            shift and go to state 101
    factor                         shift and go to state 102
    empty                          shift and go to state 103

state 81

    (48) m -> NOT .

    (               reduce using rule 48 (m -> NOT .)
    -               reduce using rule 48 (m -> NOT .)
    ID              reduce using rule 48 (m -> NOT .)
    CTEE            reduce using rule 48 (m -> NOT .)
    CTEF            reduce using rule 48 (m -> NOT .)
    CTEBOOL         reduce using rule 48 (m -> NOT .)
    CTECHAR         reduce using rule 48 (m -> NOT .)
    CALL            reduce using rule 48 (m -> NOT .)


state 82

    (47) m -> empty .

    (               reduce using rule 47 (m -> empty .)
    -               reduce using rule 47 (m -> empty .)
    ID              reduce using rule 47 (m -> empty .)
    CTEE            reduce using rule 47 (m -> empty .)
    CTEF            reduce using rule 47 (m -> empty .)
    CTEBOOL         reduce using rule 47 (m -> empty .)
    CTECHAR         reduce using rule 47 (m -> empty .)
    CALL            reduce using rule 47 (m -> empty .)


state 83

    (26) j -> empty .
    (24) i -> empty .

  ! reduce/reduce conflict for } resolved using rule 24 (i -> empty .)
    }               reduce using rule 24 (i -> empty .)

  ! }               [ reduce using rule 26 (j -> empty .) ]


state 84

    (27) j -> i .

    }               reduce using rule 27 (j -> i .)


state 85

    (25) i -> estatuto j .

    }               reduce using rule 25 (i -> estatuto j .)


state 86

    (45) for -> FOR ( . asignacion expresion asignacion ) bloque ;
    (38) asignacion -> . ID = k ;

    ID              shift and go to state 67

    asignacion                     shift and go to state 104

state 87

    (38) asignacion -> ID = . k ;
    (39) k -> . expresion
    (40) k -> . asiglista
    (46) expresion -> . m subexpresion
    (41) asiglista -> . NEW LIST ( )
    (47) m -> . empty
    (48) m -> . NOT
    (108) empty -> .

    NEW             shift and go to state 108
    NOT             shift and go to state 81
    (               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    expresion                      shift and go to state 105
    k                              shift and go to state 106
    m                              shift and go to state 80
    asiglista                      shift and go to state 107
    empty                          shift and go to state 82

state 88

    (42) if -> IF ( . expresion ) bloque l ;
    (46) expresion -> . m subexpresion
    (47) m -> . empty
    (48) m -> . NOT
    (108) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    expresion                      shift and go to state 109
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 89

    (28) bloque -> { i } .

    ;               reduce using rule 28 (bloque -> { i } .)
    ELSE            reduce using rule 28 (bloque -> { i } .)
    $end            reduce using rule 28 (bloque -> { i } .)
    FUNC            reduce using rule 28 (bloque -> { i } .)
    CANCION         reduce using rule 28 (bloque -> { i } .)


state 90

    (23) h -> , params .

    )               reduce using rule 23 (h -> , params .)


state 91

    (100) return -> RETURN ( expresion . ) ;

    )               shift and go to state 110


state 92

    (93) play -> PLAY ( NOTA . , CTEE ) ;

    ,               shift and go to state 111


state 93

    (92) while -> WHILE ( expresion . ) bloque ;

    )               shift and go to state 112


state 94

    (94) print -> PRINT expresion ; .

    ID              reduce using rule 94 (print -> PRINT expresion ; .)
    IF              reduce using rule 94 (print -> PRINT expresion ; .)
    FOR             reduce using rule 94 (print -> PRINT expresion ; .)
    RETURN          reduce using rule 94 (print -> PRINT expresion ; .)
    WHILE           reduce using rule 94 (print -> PRINT expresion ; .)
    PLAY            reduce using rule 94 (print -> PRINT expresion ; .)
    PRINT           reduce using rule 94 (print -> PRINT expresion ; .)
    }               reduce using rule 94 (print -> PRINT expresion ; .)


state 95

    (72) w -> - .

    ID              reduce using rule 72 (w -> - .)
    CTEE            reduce using rule 72 (w -> - .)
    CTEF            reduce using rule 72 (w -> - .)
    CTEBOOL         reduce using rule 72 (w -> - .)
    CTECHAR         reduce using rule 72 (w -> - .)
    CALL            reduce using rule 72 (w -> - .)


state 96

    (70) factor -> w . varcte
    (73) varcte -> . ID r
    (74) varcte -> . CTEE
    (75) varcte -> . CTEF
    (76) varcte -> . CTEBOOL
    (77) varcte -> . callfunc
    (78) varcte -> . CTECHAR
    (95) callfunc -> . CALL ID ( s ) ;

    ID              shift and go to state 120
    CTEE            shift and go to state 118
    CTEF            shift and go to state 117
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 119
    CALL            shift and go to state 116

    callfunc                       shift and go to state 115
    varcte                         shift and go to state 113

state 97

    (69) factor -> ( . expresion )
    (46) expresion -> . m subexpresion
    (47) m -> . empty
    (48) m -> . NOT
    (108) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    expresion                      shift and go to state 121
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 98

    (57) exp -> nexp . p
    (58) p -> . empty
    (59) p -> . EQ nexp
    (60) p -> . NOTEQ nexp
    (61) p -> . > nexp
    (62) p -> . < nexp
    (63) p -> . MTHANEQ nexp
    (64) p -> . LTHANEQ nexp
    (108) empty -> .

    EQ              shift and go to state 126
    NOTEQ           shift and go to state 123
    >               shift and go to state 129
    <               shift and go to state 127
    MTHANEQ         shift and go to state 122
    LTHANEQ         shift and go to state 125
    AND             reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    ;               reduce using rule 108 (empty -> .)
    )               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    ,               reduce using rule 108 (empty -> .)

    p                              shift and go to state 124
    empty                          shift and go to state 128

state 99

    (46) expresion -> m subexpresion .

    ID              reduce using rule 46 (expresion -> m subexpresion .)
    ,               reduce using rule 46 (expresion -> m subexpresion .)
    )               reduce using rule 46 (expresion -> m subexpresion .)
    ;               reduce using rule 46 (expresion -> m subexpresion .)


state 100

    (65) nexp -> termino . q
    (66) q -> . empty
    (67) q -> . + nexp
    (68) q -> . - nexp
    (108) empty -> .

    +               shift and go to state 130
    -               shift and go to state 131
    EQ              reduce using rule 108 (empty -> .)
    NOTEQ           reduce using rule 108 (empty -> .)
    >               reduce using rule 108 (empty -> .)
    <               reduce using rule 108 (empty -> .)
    MTHANEQ         reduce using rule 108 (empty -> .)
    LTHANEQ         reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    ;               reduce using rule 108 (empty -> .)
    )               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    ,               reduce using rule 108 (empty -> .)

    q                              shift and go to state 132
    empty                          shift and go to state 133

state 101

    (53) subexpresion -> exp . o
    (54) o -> . empty
    (55) o -> . AND subexpresion
    (56) o -> . OR subexpresion
    (108) empty -> .

    AND             shift and go to state 134
    OR              shift and go to state 136
    ;               reduce using rule 108 (empty -> .)
    )               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    ,               reduce using rule 108 (empty -> .)

    empty                          shift and go to state 137
    o                              shift and go to state 135

state 102

    (49) termino -> factor . n
    (50) n -> . empty
    (51) n -> . * termino
    (52) n -> . / termino
    (108) empty -> .

    *               shift and go to state 138
    /               shift and go to state 139
    +               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    EQ              reduce using rule 108 (empty -> .)
    NOTEQ           reduce using rule 108 (empty -> .)
    >               reduce using rule 108 (empty -> .)
    <               reduce using rule 108 (empty -> .)
    MTHANEQ         reduce using rule 108 (empty -> .)
    LTHANEQ         reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    ;               reduce using rule 108 (empty -> .)
    )               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    ,               reduce using rule 108 (empty -> .)

    n                              shift and go to state 140
    empty                          shift and go to state 141

state 103

    (71) w -> empty .

    ID              reduce using rule 71 (w -> empty .)
    CTEE            reduce using rule 71 (w -> empty .)
    CTEF            reduce using rule 71 (w -> empty .)
    CTEBOOL         reduce using rule 71 (w -> empty .)
    CTECHAR         reduce using rule 71 (w -> empty .)
    CALL            reduce using rule 71 (w -> empty .)


state 104

    (45) for -> FOR ( asignacion . expresion asignacion ) bloque ;
    (46) expresion -> . m subexpresion
    (47) m -> . empty
    (48) m -> . NOT
    (108) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    expresion                      shift and go to state 142
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 105

    (39) k -> expresion .

    ;               reduce using rule 39 (k -> expresion .)


state 106

    (38) asignacion -> ID = k . ;

    ;               shift and go to state 143


state 107

    (40) k -> asiglista .

    ;               reduce using rule 40 (k -> asiglista .)


state 108

    (41) asiglista -> NEW . LIST ( )

    LIST            shift and go to state 144


state 109

    (42) if -> IF ( expresion . ) bloque l ;

    )               shift and go to state 145


state 110

    (100) return -> RETURN ( expresion ) . ;

    ;               shift and go to state 146


state 111

    (93) play -> PLAY ( NOTA , . CTEE ) ;

    CTEE            shift and go to state 147


state 112

    (92) while -> WHILE ( expresion ) . bloque ;
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 148

state 113

    (70) factor -> w varcte .

    *               reduce using rule 70 (factor -> w varcte .)
    /               reduce using rule 70 (factor -> w varcte .)
    +               reduce using rule 70 (factor -> w varcte .)
    -               reduce using rule 70 (factor -> w varcte .)
    EQ              reduce using rule 70 (factor -> w varcte .)
    NOTEQ           reduce using rule 70 (factor -> w varcte .)
    >               reduce using rule 70 (factor -> w varcte .)
    <               reduce using rule 70 (factor -> w varcte .)
    MTHANEQ         reduce using rule 70 (factor -> w varcte .)
    LTHANEQ         reduce using rule 70 (factor -> w varcte .)
    AND             reduce using rule 70 (factor -> w varcte .)
    OR              reduce using rule 70 (factor -> w varcte .)
    ;               reduce using rule 70 (factor -> w varcte .)
    )               reduce using rule 70 (factor -> w varcte .)
    ID              reduce using rule 70 (factor -> w varcte .)
    ,               reduce using rule 70 (factor -> w varcte .)


state 114

    (76) varcte -> CTEBOOL .

    *               reduce using rule 76 (varcte -> CTEBOOL .)
    /               reduce using rule 76 (varcte -> CTEBOOL .)
    +               reduce using rule 76 (varcte -> CTEBOOL .)
    -               reduce using rule 76 (varcte -> CTEBOOL .)
    EQ              reduce using rule 76 (varcte -> CTEBOOL .)
    NOTEQ           reduce using rule 76 (varcte -> CTEBOOL .)
    >               reduce using rule 76 (varcte -> CTEBOOL .)
    <               reduce using rule 76 (varcte -> CTEBOOL .)
    MTHANEQ         reduce using rule 76 (varcte -> CTEBOOL .)
    LTHANEQ         reduce using rule 76 (varcte -> CTEBOOL .)
    AND             reduce using rule 76 (varcte -> CTEBOOL .)
    OR              reduce using rule 76 (varcte -> CTEBOOL .)
    ;               reduce using rule 76 (varcte -> CTEBOOL .)
    )               reduce using rule 76 (varcte -> CTEBOOL .)
    ID              reduce using rule 76 (varcte -> CTEBOOL .)
    ,               reduce using rule 76 (varcte -> CTEBOOL .)


state 115

    (77) varcte -> callfunc .

    *               reduce using rule 77 (varcte -> callfunc .)
    /               reduce using rule 77 (varcte -> callfunc .)
    +               reduce using rule 77 (varcte -> callfunc .)
    -               reduce using rule 77 (varcte -> callfunc .)
    EQ              reduce using rule 77 (varcte -> callfunc .)
    NOTEQ           reduce using rule 77 (varcte -> callfunc .)
    >               reduce using rule 77 (varcte -> callfunc .)
    <               reduce using rule 77 (varcte -> callfunc .)
    MTHANEQ         reduce using rule 77 (varcte -> callfunc .)
    LTHANEQ         reduce using rule 77 (varcte -> callfunc .)
    AND             reduce using rule 77 (varcte -> callfunc .)
    OR              reduce using rule 77 (varcte -> callfunc .)
    ;               reduce using rule 77 (varcte -> callfunc .)
    )               reduce using rule 77 (varcte -> callfunc .)
    ID              reduce using rule 77 (varcte -> callfunc .)
    ,               reduce using rule 77 (varcte -> callfunc .)


state 116

    (95) callfunc -> CALL . ID ( s ) ;

    ID              shift and go to state 149


state 117

    (75) varcte -> CTEF .

    *               reduce using rule 75 (varcte -> CTEF .)
    /               reduce using rule 75 (varcte -> CTEF .)
    +               reduce using rule 75 (varcte -> CTEF .)
    -               reduce using rule 75 (varcte -> CTEF .)
    EQ              reduce using rule 75 (varcte -> CTEF .)
    NOTEQ           reduce using rule 75 (varcte -> CTEF .)
    >               reduce using rule 75 (varcte -> CTEF .)
    <               reduce using rule 75 (varcte -> CTEF .)
    MTHANEQ         reduce using rule 75 (varcte -> CTEF .)
    LTHANEQ         reduce using rule 75 (varcte -> CTEF .)
    AND             reduce using rule 75 (varcte -> CTEF .)
    OR              reduce using rule 75 (varcte -> CTEF .)
    ;               reduce using rule 75 (varcte -> CTEF .)
    )               reduce using rule 75 (varcte -> CTEF .)
    ID              reduce using rule 75 (varcte -> CTEF .)
    ,               reduce using rule 75 (varcte -> CTEF .)


state 118

    (74) varcte -> CTEE .

    *               reduce using rule 74 (varcte -> CTEE .)
    /               reduce using rule 74 (varcte -> CTEE .)
    +               reduce using rule 74 (varcte -> CTEE .)
    -               reduce using rule 74 (varcte -> CTEE .)
    EQ              reduce using rule 74 (varcte -> CTEE .)
    NOTEQ           reduce using rule 74 (varcte -> CTEE .)
    >               reduce using rule 74 (varcte -> CTEE .)
    <               reduce using rule 74 (varcte -> CTEE .)
    MTHANEQ         reduce using rule 74 (varcte -> CTEE .)
    LTHANEQ         reduce using rule 74 (varcte -> CTEE .)
    AND             reduce using rule 74 (varcte -> CTEE .)
    OR              reduce using rule 74 (varcte -> CTEE .)
    ;               reduce using rule 74 (varcte -> CTEE .)
    )               reduce using rule 74 (varcte -> CTEE .)
    ID              reduce using rule 74 (varcte -> CTEE .)
    ,               reduce using rule 74 (varcte -> CTEE .)


state 119

    (78) varcte -> CTECHAR .

    *               reduce using rule 78 (varcte -> CTECHAR .)
    /               reduce using rule 78 (varcte -> CTECHAR .)
    +               reduce using rule 78 (varcte -> CTECHAR .)
    -               reduce using rule 78 (varcte -> CTECHAR .)
    EQ              reduce using rule 78 (varcte -> CTECHAR .)
    NOTEQ           reduce using rule 78 (varcte -> CTECHAR .)
    >               reduce using rule 78 (varcte -> CTECHAR .)
    <               reduce using rule 78 (varcte -> CTECHAR .)
    MTHANEQ         reduce using rule 78 (varcte -> CTECHAR .)
    LTHANEQ         reduce using rule 78 (varcte -> CTECHAR .)
    AND             reduce using rule 78 (varcte -> CTECHAR .)
    OR              reduce using rule 78 (varcte -> CTECHAR .)
    ;               reduce using rule 78 (varcte -> CTECHAR .)
    )               reduce using rule 78 (varcte -> CTECHAR .)
    ID              reduce using rule 78 (varcte -> CTECHAR .)
    ,               reduce using rule 78 (varcte -> CTECHAR .)


state 120

    (73) varcte -> ID . r
    (79) r -> . empty
    (80) r -> . oplista
    (108) empty -> .
    (81) oplista -> . ID . x

  ! shift/reduce conflict for ID resolved as shift
    *               reduce using rule 108 (empty -> .)
    /               reduce using rule 108 (empty -> .)
    +               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    EQ              reduce using rule 108 (empty -> .)
    NOTEQ           reduce using rule 108 (empty -> .)
    >               reduce using rule 108 (empty -> .)
    <               reduce using rule 108 (empty -> .)
    MTHANEQ         reduce using rule 108 (empty -> .)
    LTHANEQ         reduce using rule 108 (empty -> .)
    AND             reduce using rule 108 (empty -> .)
    OR              reduce using rule 108 (empty -> .)
    ;               reduce using rule 108 (empty -> .)
    )               reduce using rule 108 (empty -> .)
    ,               reduce using rule 108 (empty -> .)
    ID              shift and go to state 152

  ! ID              [ reduce using rule 108 (empty -> .) ]

    oplista                        shift and go to state 150
    r                              shift and go to state 151
    empty                          shift and go to state 153

state 121

    (69) factor -> ( expresion . )

    )               shift and go to state 154


state 122

    (63) p -> MTHANEQ . nexp
    (65) nexp -> . termino q
    (49) termino -> . factor n
    (69) factor -> . ( expresion )
    (70) factor -> . w varcte
    (71) w -> . empty
    (72) w -> . -
    (108) empty -> .

    (               shift and go to state 97
    -               shift and go to state 95
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    nexp                           shift and go to state 155
    termino                        shift and go to state 100
    w                              shift and go to state 96
    factor                         shift and go to state 102
    empty                          shift and go to state 103

state 123

    (60) p -> NOTEQ . nexp
    (65) nexp -> . termino q
    (49) termino -> . factor n
    (69) factor -> . ( expresion )
    (70) factor -> . w varcte
    (71) w -> . empty
    (72) w -> . -
    (108) empty -> .

    (               shift and go to state 97
    -               shift and go to state 95
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    nexp                           shift and go to state 156
    termino                        shift and go to state 100
    w                              shift and go to state 96
    factor                         shift and go to state 102
    empty                          shift and go to state 103

state 124

    (57) exp -> nexp p .

    AND             reduce using rule 57 (exp -> nexp p .)
    OR              reduce using rule 57 (exp -> nexp p .)
    ;               reduce using rule 57 (exp -> nexp p .)
    )               reduce using rule 57 (exp -> nexp p .)
    ID              reduce using rule 57 (exp -> nexp p .)
    ,               reduce using rule 57 (exp -> nexp p .)


state 125

    (64) p -> LTHANEQ . nexp
    (65) nexp -> . termino q
    (49) termino -> . factor n
    (69) factor -> . ( expresion )
    (70) factor -> . w varcte
    (71) w -> . empty
    (72) w -> . -
    (108) empty -> .

    (               shift and go to state 97
    -               shift and go to state 95
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    nexp                           shift and go to state 157
    termino                        shift and go to state 100
    w                              shift and go to state 96
    factor                         shift and go to state 102
    empty                          shift and go to state 103

state 126

    (59) p -> EQ . nexp
    (65) nexp -> . termino q
    (49) termino -> . factor n
    (69) factor -> . ( expresion )
    (70) factor -> . w varcte
    (71) w -> . empty
    (72) w -> . -
    (108) empty -> .

    (               shift and go to state 97
    -               shift and go to state 95
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    nexp                           shift and go to state 158
    termino                        shift and go to state 100
    w                              shift and go to state 96
    factor                         shift and go to state 102
    empty                          shift and go to state 103

state 127

    (62) p -> < . nexp
    (65) nexp -> . termino q
    (49) termino -> . factor n
    (69) factor -> . ( expresion )
    (70) factor -> . w varcte
    (71) w -> . empty
    (72) w -> . -
    (108) empty -> .

    (               shift and go to state 97
    -               shift and go to state 95
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    nexp                           shift and go to state 159
    termino                        shift and go to state 100
    w                              shift and go to state 96
    factor                         shift and go to state 102
    empty                          shift and go to state 103

state 128

    (58) p -> empty .

    AND             reduce using rule 58 (p -> empty .)
    OR              reduce using rule 58 (p -> empty .)
    ;               reduce using rule 58 (p -> empty .)
    )               reduce using rule 58 (p -> empty .)
    ID              reduce using rule 58 (p -> empty .)
    ,               reduce using rule 58 (p -> empty .)


state 129

    (61) p -> > . nexp
    (65) nexp -> . termino q
    (49) termino -> . factor n
    (69) factor -> . ( expresion )
    (70) factor -> . w varcte
    (71) w -> . empty
    (72) w -> . -
    (108) empty -> .

    (               shift and go to state 97
    -               shift and go to state 95
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    nexp                           shift and go to state 160
    termino                        shift and go to state 100
    w                              shift and go to state 96
    factor                         shift and go to state 102
    empty                          shift and go to state 103

state 130

    (67) q -> + . nexp
    (65) nexp -> . termino q
    (49) termino -> . factor n
    (69) factor -> . ( expresion )
    (70) factor -> . w varcte
    (71) w -> . empty
    (72) w -> . -
    (108) empty -> .

    (               shift and go to state 97
    -               shift and go to state 95
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    nexp                           shift and go to state 161
    termino                        shift and go to state 100
    w                              shift and go to state 96
    factor                         shift and go to state 102
    empty                          shift and go to state 103

state 131

    (68) q -> - . nexp
    (65) nexp -> . termino q
    (49) termino -> . factor n
    (69) factor -> . ( expresion )
    (70) factor -> . w varcte
    (71) w -> . empty
    (72) w -> . -
    (108) empty -> .

    (               shift and go to state 97
    -               shift and go to state 95
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    nexp                           shift and go to state 162
    termino                        shift and go to state 100
    w                              shift and go to state 96
    factor                         shift and go to state 102
    empty                          shift and go to state 103

state 132

    (65) nexp -> termino q .

    AND             reduce using rule 65 (nexp -> termino q .)
    OR              reduce using rule 65 (nexp -> termino q .)
    ;               reduce using rule 65 (nexp -> termino q .)
    )               reduce using rule 65 (nexp -> termino q .)
    ID              reduce using rule 65 (nexp -> termino q .)
    ,               reduce using rule 65 (nexp -> termino q .)
    EQ              reduce using rule 65 (nexp -> termino q .)
    NOTEQ           reduce using rule 65 (nexp -> termino q .)
    >               reduce using rule 65 (nexp -> termino q .)
    <               reduce using rule 65 (nexp -> termino q .)
    MTHANEQ         reduce using rule 65 (nexp -> termino q .)
    LTHANEQ         reduce using rule 65 (nexp -> termino q .)


state 133

    (66) q -> empty .

    EQ              reduce using rule 66 (q -> empty .)
    NOTEQ           reduce using rule 66 (q -> empty .)
    >               reduce using rule 66 (q -> empty .)
    <               reduce using rule 66 (q -> empty .)
    MTHANEQ         reduce using rule 66 (q -> empty .)
    LTHANEQ         reduce using rule 66 (q -> empty .)
    AND             reduce using rule 66 (q -> empty .)
    OR              reduce using rule 66 (q -> empty .)
    ;               reduce using rule 66 (q -> empty .)
    )               reduce using rule 66 (q -> empty .)
    ID              reduce using rule 66 (q -> empty .)
    ,               reduce using rule 66 (q -> empty .)


state 134

    (55) o -> AND . subexpresion
    (53) subexpresion -> . exp o
    (57) exp -> . nexp p
    (65) nexp -> . termino q
    (49) termino -> . factor n
    (69) factor -> . ( expresion )
    (70) factor -> . w varcte
    (71) w -> . empty
    (72) w -> . -
    (108) empty -> .

    (               shift and go to state 97
    -               shift and go to state 95
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    w                              shift and go to state 96
    nexp                           shift and go to state 98
    subexpresion                   shift and go to state 163
    termino                        shift and go to state 100
    exp                            shift and go to state 101
    factor                         shift and go to state 102
    empty                          shift and go to state 103

state 135

    (53) subexpresion -> exp o .

    ;               reduce using rule 53 (subexpresion -> exp o .)
    )               reduce using rule 53 (subexpresion -> exp o .)
    ID              reduce using rule 53 (subexpresion -> exp o .)
    ,               reduce using rule 53 (subexpresion -> exp o .)


state 136

    (56) o -> OR . subexpresion
    (53) subexpresion -> . exp o
    (57) exp -> . nexp p
    (65) nexp -> . termino q
    (49) termino -> . factor n
    (69) factor -> . ( expresion )
    (70) factor -> . w varcte
    (71) w -> . empty
    (72) w -> . -
    (108) empty -> .

    (               shift and go to state 97
    -               shift and go to state 95
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    w                              shift and go to state 96
    nexp                           shift and go to state 98
    subexpresion                   shift and go to state 164
    termino                        shift and go to state 100
    exp                            shift and go to state 101
    factor                         shift and go to state 102
    empty                          shift and go to state 103

state 137

    (54) o -> empty .

    ;               reduce using rule 54 (o -> empty .)
    )               reduce using rule 54 (o -> empty .)
    ID              reduce using rule 54 (o -> empty .)
    ,               reduce using rule 54 (o -> empty .)


state 138

    (51) n -> * . termino
    (49) termino -> . factor n
    (69) factor -> . ( expresion )
    (70) factor -> . w varcte
    (71) w -> . empty
    (72) w -> . -
    (108) empty -> .

    (               shift and go to state 97
    -               shift and go to state 95
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    termino                        shift and go to state 165
    w                              shift and go to state 96
    factor                         shift and go to state 102
    empty                          shift and go to state 103

state 139

    (52) n -> / . termino
    (49) termino -> . factor n
    (69) factor -> . ( expresion )
    (70) factor -> . w varcte
    (71) w -> . empty
    (72) w -> . -
    (108) empty -> .

    (               shift and go to state 97
    -               shift and go to state 95
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    termino                        shift and go to state 166
    w                              shift and go to state 96
    factor                         shift and go to state 102
    empty                          shift and go to state 103

state 140

    (49) termino -> factor n .

    +               reduce using rule 49 (termino -> factor n .)
    -               reduce using rule 49 (termino -> factor n .)
    AND             reduce using rule 49 (termino -> factor n .)
    OR              reduce using rule 49 (termino -> factor n .)
    ;               reduce using rule 49 (termino -> factor n .)
    )               reduce using rule 49 (termino -> factor n .)
    ID              reduce using rule 49 (termino -> factor n .)
    ,               reduce using rule 49 (termino -> factor n .)
    EQ              reduce using rule 49 (termino -> factor n .)
    NOTEQ           reduce using rule 49 (termino -> factor n .)
    >               reduce using rule 49 (termino -> factor n .)
    <               reduce using rule 49 (termino -> factor n .)
    MTHANEQ         reduce using rule 49 (termino -> factor n .)
    LTHANEQ         reduce using rule 49 (termino -> factor n .)


state 141

    (50) n -> empty .

    +               reduce using rule 50 (n -> empty .)
    -               reduce using rule 50 (n -> empty .)
    EQ              reduce using rule 50 (n -> empty .)
    NOTEQ           reduce using rule 50 (n -> empty .)
    >               reduce using rule 50 (n -> empty .)
    <               reduce using rule 50 (n -> empty .)
    MTHANEQ         reduce using rule 50 (n -> empty .)
    LTHANEQ         reduce using rule 50 (n -> empty .)
    AND             reduce using rule 50 (n -> empty .)
    OR              reduce using rule 50 (n -> empty .)
    ;               reduce using rule 50 (n -> empty .)
    )               reduce using rule 50 (n -> empty .)
    ID              reduce using rule 50 (n -> empty .)
    ,               reduce using rule 50 (n -> empty .)


state 142

    (45) for -> FOR ( asignacion expresion . asignacion ) bloque ;
    (38) asignacion -> . ID = k ;

    ID              shift and go to state 67

    asignacion                     shift and go to state 167

state 143

    (38) asignacion -> ID = k ; .

    NOT             reduce using rule 38 (asignacion -> ID = k ; .)
    (               reduce using rule 38 (asignacion -> ID = k ; .)
    -               reduce using rule 38 (asignacion -> ID = k ; .)
    ID              reduce using rule 38 (asignacion -> ID = k ; .)
    CTEE            reduce using rule 38 (asignacion -> ID = k ; .)
    CTEF            reduce using rule 38 (asignacion -> ID = k ; .)
    CTEBOOL         reduce using rule 38 (asignacion -> ID = k ; .)
    CTECHAR         reduce using rule 38 (asignacion -> ID = k ; .)
    CALL            reduce using rule 38 (asignacion -> ID = k ; .)
    IF              reduce using rule 38 (asignacion -> ID = k ; .)
    FOR             reduce using rule 38 (asignacion -> ID = k ; .)
    RETURN          reduce using rule 38 (asignacion -> ID = k ; .)
    WHILE           reduce using rule 38 (asignacion -> ID = k ; .)
    PLAY            reduce using rule 38 (asignacion -> ID = k ; .)
    PRINT           reduce using rule 38 (asignacion -> ID = k ; .)
    }               reduce using rule 38 (asignacion -> ID = k ; .)
    )               reduce using rule 38 (asignacion -> ID = k ; .)


state 144

    (41) asiglista -> NEW LIST . ( )

    (               shift and go to state 168


state 145

    (42) if -> IF ( expresion ) . bloque l ;
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 169

state 146

    (100) return -> RETURN ( expresion ) ; .

    ID              reduce using rule 100 (return -> RETURN ( expresion ) ; .)
    IF              reduce using rule 100 (return -> RETURN ( expresion ) ; .)
    FOR             reduce using rule 100 (return -> RETURN ( expresion ) ; .)
    RETURN          reduce using rule 100 (return -> RETURN ( expresion ) ; .)
    WHILE           reduce using rule 100 (return -> RETURN ( expresion ) ; .)
    PLAY            reduce using rule 100 (return -> RETURN ( expresion ) ; .)
    PRINT           reduce using rule 100 (return -> RETURN ( expresion ) ; .)
    }               reduce using rule 100 (return -> RETURN ( expresion ) ; .)


state 147

    (93) play -> PLAY ( NOTA , CTEE . ) ;

    )               shift and go to state 170


state 148

    (92) while -> WHILE ( expresion ) bloque . ;

    ;               shift and go to state 171


state 149

    (95) callfunc -> CALL ID . ( s ) ;

    (               shift and go to state 172


state 150

    (80) r -> oplista .

    *               reduce using rule 80 (r -> oplista .)
    /               reduce using rule 80 (r -> oplista .)
    +               reduce using rule 80 (r -> oplista .)
    -               reduce using rule 80 (r -> oplista .)
    EQ              reduce using rule 80 (r -> oplista .)
    NOTEQ           reduce using rule 80 (r -> oplista .)
    >               reduce using rule 80 (r -> oplista .)
    <               reduce using rule 80 (r -> oplista .)
    MTHANEQ         reduce using rule 80 (r -> oplista .)
    LTHANEQ         reduce using rule 80 (r -> oplista .)
    AND             reduce using rule 80 (r -> oplista .)
    OR              reduce using rule 80 (r -> oplista .)
    ;               reduce using rule 80 (r -> oplista .)
    )               reduce using rule 80 (r -> oplista .)
    ID              reduce using rule 80 (r -> oplista .)
    ,               reduce using rule 80 (r -> oplista .)


state 151

    (73) varcte -> ID r .

    *               reduce using rule 73 (varcte -> ID r .)
    /               reduce using rule 73 (varcte -> ID r .)
    +               reduce using rule 73 (varcte -> ID r .)
    -               reduce using rule 73 (varcte -> ID r .)
    EQ              reduce using rule 73 (varcte -> ID r .)
    NOTEQ           reduce using rule 73 (varcte -> ID r .)
    >               reduce using rule 73 (varcte -> ID r .)
    <               reduce using rule 73 (varcte -> ID r .)
    MTHANEQ         reduce using rule 73 (varcte -> ID r .)
    LTHANEQ         reduce using rule 73 (varcte -> ID r .)
    AND             reduce using rule 73 (varcte -> ID r .)
    OR              reduce using rule 73 (varcte -> ID r .)
    ;               reduce using rule 73 (varcte -> ID r .)
    )               reduce using rule 73 (varcte -> ID r .)
    ID              reduce using rule 73 (varcte -> ID r .)
    ,               reduce using rule 73 (varcte -> ID r .)


state 152

    (81) oplista -> ID . . x

    .               shift and go to state 173


state 153

    (79) r -> empty .

    *               reduce using rule 79 (r -> empty .)
    /               reduce using rule 79 (r -> empty .)
    +               reduce using rule 79 (r -> empty .)
    -               reduce using rule 79 (r -> empty .)
    EQ              reduce using rule 79 (r -> empty .)
    NOTEQ           reduce using rule 79 (r -> empty .)
    >               reduce using rule 79 (r -> empty .)
    <               reduce using rule 79 (r -> empty .)
    MTHANEQ         reduce using rule 79 (r -> empty .)
    LTHANEQ         reduce using rule 79 (r -> empty .)
    AND             reduce using rule 79 (r -> empty .)
    OR              reduce using rule 79 (r -> empty .)
    ;               reduce using rule 79 (r -> empty .)
    )               reduce using rule 79 (r -> empty .)
    ID              reduce using rule 79 (r -> empty .)
    ,               reduce using rule 79 (r -> empty .)


state 154

    (69) factor -> ( expresion ) .

    *               reduce using rule 69 (factor -> ( expresion ) .)
    /               reduce using rule 69 (factor -> ( expresion ) .)
    +               reduce using rule 69 (factor -> ( expresion ) .)
    -               reduce using rule 69 (factor -> ( expresion ) .)
    EQ              reduce using rule 69 (factor -> ( expresion ) .)
    NOTEQ           reduce using rule 69 (factor -> ( expresion ) .)
    >               reduce using rule 69 (factor -> ( expresion ) .)
    <               reduce using rule 69 (factor -> ( expresion ) .)
    MTHANEQ         reduce using rule 69 (factor -> ( expresion ) .)
    LTHANEQ         reduce using rule 69 (factor -> ( expresion ) .)
    AND             reduce using rule 69 (factor -> ( expresion ) .)
    OR              reduce using rule 69 (factor -> ( expresion ) .)
    ;               reduce using rule 69 (factor -> ( expresion ) .)
    )               reduce using rule 69 (factor -> ( expresion ) .)
    ID              reduce using rule 69 (factor -> ( expresion ) .)
    ,               reduce using rule 69 (factor -> ( expresion ) .)


state 155

    (63) p -> MTHANEQ nexp .

    AND             reduce using rule 63 (p -> MTHANEQ nexp .)
    OR              reduce using rule 63 (p -> MTHANEQ nexp .)
    ;               reduce using rule 63 (p -> MTHANEQ nexp .)
    )               reduce using rule 63 (p -> MTHANEQ nexp .)
    ID              reduce using rule 63 (p -> MTHANEQ nexp .)
    ,               reduce using rule 63 (p -> MTHANEQ nexp .)


state 156

    (60) p -> NOTEQ nexp .

    AND             reduce using rule 60 (p -> NOTEQ nexp .)
    OR              reduce using rule 60 (p -> NOTEQ nexp .)
    ;               reduce using rule 60 (p -> NOTEQ nexp .)
    )               reduce using rule 60 (p -> NOTEQ nexp .)
    ID              reduce using rule 60 (p -> NOTEQ nexp .)
    ,               reduce using rule 60 (p -> NOTEQ nexp .)


state 157

    (64) p -> LTHANEQ nexp .

    AND             reduce using rule 64 (p -> LTHANEQ nexp .)
    OR              reduce using rule 64 (p -> LTHANEQ nexp .)
    ;               reduce using rule 64 (p -> LTHANEQ nexp .)
    )               reduce using rule 64 (p -> LTHANEQ nexp .)
    ID              reduce using rule 64 (p -> LTHANEQ nexp .)
    ,               reduce using rule 64 (p -> LTHANEQ nexp .)


state 158

    (59) p -> EQ nexp .

    AND             reduce using rule 59 (p -> EQ nexp .)
    OR              reduce using rule 59 (p -> EQ nexp .)
    ;               reduce using rule 59 (p -> EQ nexp .)
    )               reduce using rule 59 (p -> EQ nexp .)
    ID              reduce using rule 59 (p -> EQ nexp .)
    ,               reduce using rule 59 (p -> EQ nexp .)


state 159

    (62) p -> < nexp .

    AND             reduce using rule 62 (p -> < nexp .)
    OR              reduce using rule 62 (p -> < nexp .)
    ;               reduce using rule 62 (p -> < nexp .)
    )               reduce using rule 62 (p -> < nexp .)
    ID              reduce using rule 62 (p -> < nexp .)
    ,               reduce using rule 62 (p -> < nexp .)


state 160

    (61) p -> > nexp .

    AND             reduce using rule 61 (p -> > nexp .)
    OR              reduce using rule 61 (p -> > nexp .)
    ;               reduce using rule 61 (p -> > nexp .)
    )               reduce using rule 61 (p -> > nexp .)
    ID              reduce using rule 61 (p -> > nexp .)
    ,               reduce using rule 61 (p -> > nexp .)


state 161

    (67) q -> + nexp .

    EQ              reduce using rule 67 (q -> + nexp .)
    NOTEQ           reduce using rule 67 (q -> + nexp .)
    >               reduce using rule 67 (q -> + nexp .)
    <               reduce using rule 67 (q -> + nexp .)
    MTHANEQ         reduce using rule 67 (q -> + nexp .)
    LTHANEQ         reduce using rule 67 (q -> + nexp .)
    AND             reduce using rule 67 (q -> + nexp .)
    OR              reduce using rule 67 (q -> + nexp .)
    ;               reduce using rule 67 (q -> + nexp .)
    )               reduce using rule 67 (q -> + nexp .)
    ID              reduce using rule 67 (q -> + nexp .)
    ,               reduce using rule 67 (q -> + nexp .)


state 162

    (68) q -> - nexp .

    EQ              reduce using rule 68 (q -> - nexp .)
    NOTEQ           reduce using rule 68 (q -> - nexp .)
    >               reduce using rule 68 (q -> - nexp .)
    <               reduce using rule 68 (q -> - nexp .)
    MTHANEQ         reduce using rule 68 (q -> - nexp .)
    LTHANEQ         reduce using rule 68 (q -> - nexp .)
    AND             reduce using rule 68 (q -> - nexp .)
    OR              reduce using rule 68 (q -> - nexp .)
    ;               reduce using rule 68 (q -> - nexp .)
    )               reduce using rule 68 (q -> - nexp .)
    ID              reduce using rule 68 (q -> - nexp .)
    ,               reduce using rule 68 (q -> - nexp .)


state 163

    (55) o -> AND subexpresion .

    ;               reduce using rule 55 (o -> AND subexpresion .)
    )               reduce using rule 55 (o -> AND subexpresion .)
    ID              reduce using rule 55 (o -> AND subexpresion .)
    ,               reduce using rule 55 (o -> AND subexpresion .)


state 164

    (56) o -> OR subexpresion .

    ;               reduce using rule 56 (o -> OR subexpresion .)
    )               reduce using rule 56 (o -> OR subexpresion .)
    ID              reduce using rule 56 (o -> OR subexpresion .)
    ,               reduce using rule 56 (o -> OR subexpresion .)


state 165

    (51) n -> * termino .

    +               reduce using rule 51 (n -> * termino .)
    -               reduce using rule 51 (n -> * termino .)
    EQ              reduce using rule 51 (n -> * termino .)
    NOTEQ           reduce using rule 51 (n -> * termino .)
    >               reduce using rule 51 (n -> * termino .)
    <               reduce using rule 51 (n -> * termino .)
    MTHANEQ         reduce using rule 51 (n -> * termino .)
    LTHANEQ         reduce using rule 51 (n -> * termino .)
    AND             reduce using rule 51 (n -> * termino .)
    OR              reduce using rule 51 (n -> * termino .)
    ;               reduce using rule 51 (n -> * termino .)
    )               reduce using rule 51 (n -> * termino .)
    ID              reduce using rule 51 (n -> * termino .)
    ,               reduce using rule 51 (n -> * termino .)


state 166

    (52) n -> / termino .

    +               reduce using rule 52 (n -> / termino .)
    -               reduce using rule 52 (n -> / termino .)
    EQ              reduce using rule 52 (n -> / termino .)
    NOTEQ           reduce using rule 52 (n -> / termino .)
    >               reduce using rule 52 (n -> / termino .)
    <               reduce using rule 52 (n -> / termino .)
    MTHANEQ         reduce using rule 52 (n -> / termino .)
    LTHANEQ         reduce using rule 52 (n -> / termino .)
    AND             reduce using rule 52 (n -> / termino .)
    OR              reduce using rule 52 (n -> / termino .)
    ;               reduce using rule 52 (n -> / termino .)
    )               reduce using rule 52 (n -> / termino .)
    ID              reduce using rule 52 (n -> / termino .)
    ,               reduce using rule 52 (n -> / termino .)


state 167

    (45) for -> FOR ( asignacion expresion asignacion . ) bloque ;

    )               shift and go to state 174


state 168

    (41) asiglista -> NEW LIST ( . )

    )               shift and go to state 175


state 169

    (42) if -> IF ( expresion ) bloque . l ;
    (43) l -> . empty
    (44) l -> . ELSE bloque
    (108) empty -> .

    ELSE            shift and go to state 177
    ;               reduce using rule 108 (empty -> .)

    l                              shift and go to state 176
    empty                          shift and go to state 178

state 170

    (93) play -> PLAY ( NOTA , CTEE ) . ;

    ;               shift and go to state 179


state 171

    (92) while -> WHILE ( expresion ) bloque ; .

    ID              reduce using rule 92 (while -> WHILE ( expresion ) bloque ; .)
    IF              reduce using rule 92 (while -> WHILE ( expresion ) bloque ; .)
    FOR             reduce using rule 92 (while -> WHILE ( expresion ) bloque ; .)
    RETURN          reduce using rule 92 (while -> WHILE ( expresion ) bloque ; .)
    WHILE           reduce using rule 92 (while -> WHILE ( expresion ) bloque ; .)
    PLAY            reduce using rule 92 (while -> WHILE ( expresion ) bloque ; .)
    PRINT           reduce using rule 92 (while -> WHILE ( expresion ) bloque ; .)
    }               reduce using rule 92 (while -> WHILE ( expresion ) bloque ; .)


state 172

    (95) callfunc -> CALL ID ( . s ) ;
    (96) s -> . empty
    (97) s -> . expresion t
    (108) empty -> .
    (46) expresion -> . m subexpresion
    (47) m -> . empty
    (48) m -> . NOT

    )               reduce using rule 108 (empty -> .)
    (               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)
    NOT             shift and go to state 81

    expresion                      shift and go to state 180
    m                              shift and go to state 80
    s                              shift and go to state 181
    empty                          shift and go to state 182

state 173

    (81) oplista -> ID . . x
    (82) x -> . inlistset
    (83) x -> . append
    (84) x -> . length
    (85) x -> . getlist
    (86) x -> . removelist
    (87) inlistset -> . SET ( CTEE , expresion )
    (88) append -> . APPEND ( expresion )
    (89) length -> . LENGTH ( )
    (90) getlist -> . GET ( expresion )
    (91) removelist -> . REMOVE ( expresion )

    SET             shift and go to state 183
    APPEND          shift and go to state 190
    LENGTH          shift and go to state 188
    GET             shift and go to state 185
    REMOVE          shift and go to state 187

    inlistset                      shift and go to state 184
    getlist                        shift and go to state 186
    length                         shift and go to state 189
    x                              shift and go to state 191
    removelist                     shift and go to state 192
    append                         shift and go to state 193

state 174

    (45) for -> FOR ( asignacion expresion asignacion ) . bloque ;
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 194

state 175

    (41) asiglista -> NEW LIST ( ) .

    ;               reduce using rule 41 (asiglista -> NEW LIST ( ) .)


state 176

    (42) if -> IF ( expresion ) bloque l . ;

    ;               shift and go to state 195


state 177

    (44) l -> ELSE . bloque
    (28) bloque -> . { i }

    {               shift and go to state 51

    bloque                         shift and go to state 196

state 178

    (43) l -> empty .

    ;               reduce using rule 43 (l -> empty .)


state 179

    (93) play -> PLAY ( NOTA , CTEE ) ; .

    ID              reduce using rule 93 (play -> PLAY ( NOTA , CTEE ) ; .)
    IF              reduce using rule 93 (play -> PLAY ( NOTA , CTEE ) ; .)
    FOR             reduce using rule 93 (play -> PLAY ( NOTA , CTEE ) ; .)
    RETURN          reduce using rule 93 (play -> PLAY ( NOTA , CTEE ) ; .)
    WHILE           reduce using rule 93 (play -> PLAY ( NOTA , CTEE ) ; .)
    PLAY            reduce using rule 93 (play -> PLAY ( NOTA , CTEE ) ; .)
    PRINT           reduce using rule 93 (play -> PLAY ( NOTA , CTEE ) ; .)
    }               reduce using rule 93 (play -> PLAY ( NOTA , CTEE ) ; .)


state 180

    (97) s -> expresion . t
    (98) t -> . empty
    (99) t -> . , s
    (108) empty -> .

    ,               shift and go to state 199
    )               reduce using rule 108 (empty -> .)

    t                              shift and go to state 197
    empty                          shift and go to state 198

state 181

    (95) callfunc -> CALL ID ( s . ) ;

    )               shift and go to state 200


state 182

    (96) s -> empty .
    (47) m -> empty .

    )               reduce using rule 96 (s -> empty .)
    (               reduce using rule 47 (m -> empty .)
    -               reduce using rule 47 (m -> empty .)
    ID              reduce using rule 47 (m -> empty .)
    CTEE            reduce using rule 47 (m -> empty .)
    CTEF            reduce using rule 47 (m -> empty .)
    CTEBOOL         reduce using rule 47 (m -> empty .)
    CTECHAR         reduce using rule 47 (m -> empty .)
    CALL            reduce using rule 47 (m -> empty .)


state 183

    (87) inlistset -> SET . ( CTEE , expresion )

    (               shift and go to state 201


state 184

    (82) x -> inlistset .

    *               reduce using rule 82 (x -> inlistset .)
    /               reduce using rule 82 (x -> inlistset .)
    +               reduce using rule 82 (x -> inlistset .)
    -               reduce using rule 82 (x -> inlistset .)
    EQ              reduce using rule 82 (x -> inlistset .)
    NOTEQ           reduce using rule 82 (x -> inlistset .)
    >               reduce using rule 82 (x -> inlistset .)
    <               reduce using rule 82 (x -> inlistset .)
    MTHANEQ         reduce using rule 82 (x -> inlistset .)
    LTHANEQ         reduce using rule 82 (x -> inlistset .)
    AND             reduce using rule 82 (x -> inlistset .)
    OR              reduce using rule 82 (x -> inlistset .)
    ;               reduce using rule 82 (x -> inlistset .)
    )               reduce using rule 82 (x -> inlistset .)
    ID              reduce using rule 82 (x -> inlistset .)
    ,               reduce using rule 82 (x -> inlistset .)


state 185

    (90) getlist -> GET . ( expresion )

    (               shift and go to state 202


state 186

    (85) x -> getlist .

    *               reduce using rule 85 (x -> getlist .)
    /               reduce using rule 85 (x -> getlist .)
    +               reduce using rule 85 (x -> getlist .)
    -               reduce using rule 85 (x -> getlist .)
    EQ              reduce using rule 85 (x -> getlist .)
    NOTEQ           reduce using rule 85 (x -> getlist .)
    >               reduce using rule 85 (x -> getlist .)
    <               reduce using rule 85 (x -> getlist .)
    MTHANEQ         reduce using rule 85 (x -> getlist .)
    LTHANEQ         reduce using rule 85 (x -> getlist .)
    AND             reduce using rule 85 (x -> getlist .)
    OR              reduce using rule 85 (x -> getlist .)
    ;               reduce using rule 85 (x -> getlist .)
    )               reduce using rule 85 (x -> getlist .)
    ID              reduce using rule 85 (x -> getlist .)
    ,               reduce using rule 85 (x -> getlist .)


state 187

    (91) removelist -> REMOVE . ( expresion )

    (               shift and go to state 203


state 188

    (89) length -> LENGTH . ( )

    (               shift and go to state 204


state 189

    (84) x -> length .

    *               reduce using rule 84 (x -> length .)
    /               reduce using rule 84 (x -> length .)
    +               reduce using rule 84 (x -> length .)
    -               reduce using rule 84 (x -> length .)
    EQ              reduce using rule 84 (x -> length .)
    NOTEQ           reduce using rule 84 (x -> length .)
    >               reduce using rule 84 (x -> length .)
    <               reduce using rule 84 (x -> length .)
    MTHANEQ         reduce using rule 84 (x -> length .)
    LTHANEQ         reduce using rule 84 (x -> length .)
    AND             reduce using rule 84 (x -> length .)
    OR              reduce using rule 84 (x -> length .)
    ;               reduce using rule 84 (x -> length .)
    )               reduce using rule 84 (x -> length .)
    ID              reduce using rule 84 (x -> length .)
    ,               reduce using rule 84 (x -> length .)


state 190

    (88) append -> APPEND . ( expresion )

    (               shift and go to state 205


state 191

    (81) oplista -> ID . x .

    *               reduce using rule 81 (oplista -> ID . x .)
    /               reduce using rule 81 (oplista -> ID . x .)
    +               reduce using rule 81 (oplista -> ID . x .)
    -               reduce using rule 81 (oplista -> ID . x .)
    EQ              reduce using rule 81 (oplista -> ID . x .)
    NOTEQ           reduce using rule 81 (oplista -> ID . x .)
    >               reduce using rule 81 (oplista -> ID . x .)
    <               reduce using rule 81 (oplista -> ID . x .)
    MTHANEQ         reduce using rule 81 (oplista -> ID . x .)
    LTHANEQ         reduce using rule 81 (oplista -> ID . x .)
    AND             reduce using rule 81 (oplista -> ID . x .)
    OR              reduce using rule 81 (oplista -> ID . x .)
    ;               reduce using rule 81 (oplista -> ID . x .)
    )               reduce using rule 81 (oplista -> ID . x .)
    ID              reduce using rule 81 (oplista -> ID . x .)
    ,               reduce using rule 81 (oplista -> ID . x .)


state 192

    (86) x -> removelist .

    *               reduce using rule 86 (x -> removelist .)
    /               reduce using rule 86 (x -> removelist .)
    +               reduce using rule 86 (x -> removelist .)
    -               reduce using rule 86 (x -> removelist .)
    EQ              reduce using rule 86 (x -> removelist .)
    NOTEQ           reduce using rule 86 (x -> removelist .)
    >               reduce using rule 86 (x -> removelist .)
    <               reduce using rule 86 (x -> removelist .)
    MTHANEQ         reduce using rule 86 (x -> removelist .)
    LTHANEQ         reduce using rule 86 (x -> removelist .)
    AND             reduce using rule 86 (x -> removelist .)
    OR              reduce using rule 86 (x -> removelist .)
    ;               reduce using rule 86 (x -> removelist .)
    )               reduce using rule 86 (x -> removelist .)
    ID              reduce using rule 86 (x -> removelist .)
    ,               reduce using rule 86 (x -> removelist .)


state 193

    (83) x -> append .

    *               reduce using rule 83 (x -> append .)
    /               reduce using rule 83 (x -> append .)
    +               reduce using rule 83 (x -> append .)
    -               reduce using rule 83 (x -> append .)
    EQ              reduce using rule 83 (x -> append .)
    NOTEQ           reduce using rule 83 (x -> append .)
    >               reduce using rule 83 (x -> append .)
    <               reduce using rule 83 (x -> append .)
    MTHANEQ         reduce using rule 83 (x -> append .)
    LTHANEQ         reduce using rule 83 (x -> append .)
    AND             reduce using rule 83 (x -> append .)
    OR              reduce using rule 83 (x -> append .)
    ;               reduce using rule 83 (x -> append .)
    )               reduce using rule 83 (x -> append .)
    ID              reduce using rule 83 (x -> append .)
    ,               reduce using rule 83 (x -> append .)


state 194

    (45) for -> FOR ( asignacion expresion asignacion ) bloque . ;

    ;               shift and go to state 206


state 195

    (42) if -> IF ( expresion ) bloque l ; .

    ID              reduce using rule 42 (if -> IF ( expresion ) bloque l ; .)
    IF              reduce using rule 42 (if -> IF ( expresion ) bloque l ; .)
    FOR             reduce using rule 42 (if -> IF ( expresion ) bloque l ; .)
    RETURN          reduce using rule 42 (if -> IF ( expresion ) bloque l ; .)
    WHILE           reduce using rule 42 (if -> IF ( expresion ) bloque l ; .)
    PLAY            reduce using rule 42 (if -> IF ( expresion ) bloque l ; .)
    PRINT           reduce using rule 42 (if -> IF ( expresion ) bloque l ; .)
    }               reduce using rule 42 (if -> IF ( expresion ) bloque l ; .)


state 196

    (44) l -> ELSE bloque .

    ;               reduce using rule 44 (l -> ELSE bloque .)


state 197

    (97) s -> expresion t .

    )               reduce using rule 97 (s -> expresion t .)


state 198

    (98) t -> empty .

    )               reduce using rule 98 (t -> empty .)


state 199

    (99) t -> , . s
    (96) s -> . empty
    (97) s -> . expresion t
    (108) empty -> .
    (46) expresion -> . m subexpresion
    (47) m -> . empty
    (48) m -> . NOT

    )               reduce using rule 108 (empty -> .)
    (               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)
    NOT             shift and go to state 81

    expresion                      shift and go to state 180
    m                              shift and go to state 80
    s                              shift and go to state 207
    empty                          shift and go to state 182

state 200

    (95) callfunc -> CALL ID ( s ) . ;

    ;               shift and go to state 208


state 201

    (87) inlistset -> SET ( . CTEE , expresion )

    CTEE            shift and go to state 209


state 202

    (90) getlist -> GET ( . expresion )
    (46) expresion -> . m subexpresion
    (47) m -> . empty
    (48) m -> . NOT
    (108) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    expresion                      shift and go to state 210
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 203

    (91) removelist -> REMOVE ( . expresion )
    (46) expresion -> . m subexpresion
    (47) m -> . empty
    (48) m -> . NOT
    (108) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    expresion                      shift and go to state 211
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 204

    (89) length -> LENGTH ( . )

    )               shift and go to state 212


state 205

    (88) append -> APPEND ( . expresion )
    (46) expresion -> . m subexpresion
    (47) m -> . empty
    (48) m -> . NOT
    (108) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    expresion                      shift and go to state 213
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 206

    (45) for -> FOR ( asignacion expresion asignacion ) bloque ; .

    ID              reduce using rule 45 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    IF              reduce using rule 45 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    FOR             reduce using rule 45 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    RETURN          reduce using rule 45 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    WHILE           reduce using rule 45 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    PLAY            reduce using rule 45 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    PRINT           reduce using rule 45 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)
    }               reduce using rule 45 (for -> FOR ( asignacion expresion asignacion ) bloque ; .)


state 207

    (99) t -> , s .

    )               reduce using rule 99 (t -> , s .)


state 208

    (95) callfunc -> CALL ID ( s ) ; .

    *               reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    /               reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    +               reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    -               reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    EQ              reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    NOTEQ           reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    >               reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    <               reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    MTHANEQ         reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    LTHANEQ         reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    AND             reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    OR              reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    ;               reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    )               reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    ID              reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)
    ,               reduce using rule 95 (callfunc -> CALL ID ( s ) ; .)


state 209

    (87) inlistset -> SET ( CTEE . , expresion )

    ,               shift and go to state 214


state 210

    (90) getlist -> GET ( expresion . )

    )               shift and go to state 215


state 211

    (91) removelist -> REMOVE ( expresion . )

    )               shift and go to state 216


state 212

    (89) length -> LENGTH ( ) .

    *               reduce using rule 89 (length -> LENGTH ( ) .)
    /               reduce using rule 89 (length -> LENGTH ( ) .)
    +               reduce using rule 89 (length -> LENGTH ( ) .)
    -               reduce using rule 89 (length -> LENGTH ( ) .)
    EQ              reduce using rule 89 (length -> LENGTH ( ) .)
    NOTEQ           reduce using rule 89 (length -> LENGTH ( ) .)
    >               reduce using rule 89 (length -> LENGTH ( ) .)
    <               reduce using rule 89 (length -> LENGTH ( ) .)
    MTHANEQ         reduce using rule 89 (length -> LENGTH ( ) .)
    LTHANEQ         reduce using rule 89 (length -> LENGTH ( ) .)
    AND             reduce using rule 89 (length -> LENGTH ( ) .)
    OR              reduce using rule 89 (length -> LENGTH ( ) .)
    ;               reduce using rule 89 (length -> LENGTH ( ) .)
    )               reduce using rule 89 (length -> LENGTH ( ) .)
    ID              reduce using rule 89 (length -> LENGTH ( ) .)
    ,               reduce using rule 89 (length -> LENGTH ( ) .)


state 213

    (88) append -> APPEND ( expresion . )

    )               shift and go to state 217


state 214

    (87) inlistset -> SET ( CTEE , . expresion )
    (46) expresion -> . m subexpresion
    (47) m -> . empty
    (48) m -> . NOT
    (108) empty -> .

    NOT             shift and go to state 81
    (               reduce using rule 108 (empty -> .)
    -               reduce using rule 108 (empty -> .)
    ID              reduce using rule 108 (empty -> .)
    CTEE            reduce using rule 108 (empty -> .)
    CTEF            reduce using rule 108 (empty -> .)
    CTEBOOL         reduce using rule 108 (empty -> .)
    CTECHAR         reduce using rule 108 (empty -> .)
    CALL            reduce using rule 108 (empty -> .)

    expresion                      shift and go to state 218
    m                              shift and go to state 80
    empty                          shift and go to state 82

state 215

    (90) getlist -> GET ( expresion ) .

    *               reduce using rule 90 (getlist -> GET ( expresion ) .)
    /               reduce using rule 90 (getlist -> GET ( expresion ) .)
    +               reduce using rule 90 (getlist -> GET ( expresion ) .)
    -               reduce using rule 90 (getlist -> GET ( expresion ) .)
    EQ              reduce using rule 90 (getlist -> GET ( expresion ) .)
    NOTEQ           reduce using rule 90 (getlist -> GET ( expresion ) .)
    >               reduce using rule 90 (getlist -> GET ( expresion ) .)
    <               reduce using rule 90 (getlist -> GET ( expresion ) .)
    MTHANEQ         reduce using rule 90 (getlist -> GET ( expresion ) .)
    LTHANEQ         reduce using rule 90 (getlist -> GET ( expresion ) .)
    AND             reduce using rule 90 (getlist -> GET ( expresion ) .)
    OR              reduce using rule 90 (getlist -> GET ( expresion ) .)
    ;               reduce using rule 90 (getlist -> GET ( expresion ) .)
    )               reduce using rule 90 (getlist -> GET ( expresion ) .)
    ID              reduce using rule 90 (getlist -> GET ( expresion ) .)
    ,               reduce using rule 90 (getlist -> GET ( expresion ) .)


state 216

    (91) removelist -> REMOVE ( expresion ) .

    *               reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    /               reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    +               reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    -               reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    EQ              reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    NOTEQ           reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    >               reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    <               reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    MTHANEQ         reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    LTHANEQ         reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    AND             reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    OR              reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    ;               reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    )               reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    ID              reduce using rule 91 (removelist -> REMOVE ( expresion ) .)
    ,               reduce using rule 91 (removelist -> REMOVE ( expresion ) .)


state 217

    (88) append -> APPEND ( expresion ) .

    *               reduce using rule 88 (append -> APPEND ( expresion ) .)
    /               reduce using rule 88 (append -> APPEND ( expresion ) .)
    +               reduce using rule 88 (append -> APPEND ( expresion ) .)
    -               reduce using rule 88 (append -> APPEND ( expresion ) .)
    EQ              reduce using rule 88 (append -> APPEND ( expresion ) .)
    NOTEQ           reduce using rule 88 (append -> APPEND ( expresion ) .)
    >               reduce using rule 88 (append -> APPEND ( expresion ) .)
    <               reduce using rule 88 (append -> APPEND ( expresion ) .)
    MTHANEQ         reduce using rule 88 (append -> APPEND ( expresion ) .)
    LTHANEQ         reduce using rule 88 (append -> APPEND ( expresion ) .)
    AND             reduce using rule 88 (append -> APPEND ( expresion ) .)
    OR              reduce using rule 88 (append -> APPEND ( expresion ) .)
    ;               reduce using rule 88 (append -> APPEND ( expresion ) .)
    )               reduce using rule 88 (append -> APPEND ( expresion ) .)
    ID              reduce using rule 88 (append -> APPEND ( expresion ) .)
    ,               reduce using rule 88 (append -> APPEND ( expresion ) .)


state 218

    (87) inlistset -> SET ( CTEE , expresion . )

    )               shift and go to state 219


state 219

    (87) inlistset -> SET ( CTEE , expresion ) .

    *               reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    /               reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    +               reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    -               reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    EQ              reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    NOTEQ           reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    >               reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    <               reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    MTHANEQ         reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    LTHANEQ         reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    AND             reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    OR              reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    ;               reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    )               reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    ID              reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)
    ,               reduce using rule 87 (inlistset -> SET ( CTEE , expresion ) .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 120 resolved as shift
WARNING: reduce/reduce conflict in state 13 resolved using rule (a -> empty)
WARNING: rejected rule (b -> empty) in state 13
WARNING: reduce/reduce conflict in state 24 resolved using rule (c -> empty)
WARNING: rejected rule (d -> empty) in state 24
WARNING: reduce/reduce conflict in state 50 resolved using rule (f -> empty)
WARNING: rejected rule (g -> empty) in state 50
WARNING: reduce/reduce conflict in state 83 resolved using rule (i -> empty)
WARNING: rejected rule (j -> empty) in state 83
WARNING: Rule (b -> empty) is never reduced
WARNING: Rule (d -> empty) is never reduced
WARNING: Rule (g -> empty) is never reduced
WARNING: Rule (j -> empty) is never reduced
