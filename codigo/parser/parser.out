Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> programa
Rule 1     programa -> creadirprocglobal a neur22 c cancion
Rule 2     creadirprocglobal -> <empty>
Rule 3     a -> empty
Rule 4     a -> vars b
Rule 5     b -> empty
Rule 6     b -> a
Rule 7     neur22 -> <empty>
Rule 8     c -> empty
Rule 9     c -> funcion d
Rule 10    d -> empty
Rule 11    d -> c
Rule 12    vars -> VAR v : tipo ;
Rule 13    v -> ID
Rule 14    funcion -> FUNC z ID meterfuncion ( params ) f neur23 bloque
Rule 15    z -> INT
Rule 16    z -> CHAR
Rule 17    z -> FLOAT
Rule 18    z -> BOOL
Rule 19    z -> VOID
Rule 20    meterfuncion -> <empty>
Rule 21    neur23 -> <empty>
Rule 22    f -> empty
Rule 23    f -> vars g
Rule 24    g -> empty
Rule 25    g -> f
Rule 26    params -> empty
Rule 27    params -> tipo ID meterparams h
Rule 28    meterparams -> <empty>
Rule 29    h -> empty
Rule 30    h -> , params
Rule 31    i -> empty
Rule 32    i -> estatuto j
Rule 33    j -> empty
Rule 34    j -> i
Rule 35    bloque -> { i }
Rule 36    cancion -> CANCION ( CTEE ) metercancion f bloque
Rule 37    metercancion -> <empty>
Rule 38    estatuto -> asignacion
Rule 39    estatuto -> if
Rule 40    estatuto -> for
Rule 41    estatuto -> return
Rule 42    estatuto -> while
Rule 43    estatuto -> play
Rule 44    estatuto -> print
Rule 45    estatuto -> callvoidfunc
Rule 46    asignacion -> ID = neur8 k ;
Rule 47    neur8 -> <empty>
Rule 48    k -> expresion
Rule 49    k -> asiglista
Rule 50    asiglista -> NEW LIST ( )
Rule 51    if -> IF ( expresion ) neur13 bloque l ;
Rule 52    neur13 -> <empty>
Rule 53    l -> empty neur15
Rule 54    l -> ELSE neur14 bloque
Rule 55    neur14 -> <empty>
Rule 56    neur15 -> <empty>
Rule 57    for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
Rule 58    neur18 -> <empty>
Rule 59    neur19 -> <empty>
Rule 60    neur21 -> <empty>
Rule 61    neur20 -> <empty>
Rule 62    expresion -> m subexpresion
Rule 63    m -> empty
Rule 64    m -> NOT
Rule 65    subexpresion -> exp neur10 o
Rule 66    neur10 -> <empty>
Rule 67    o -> empty
Rule 68    o -> AND neur9_1 subexpresion
Rule 69    o -> OR neur9_2 subexpresion
Rule 70    neur9_1 -> <empty>
Rule 71    neur9_2 -> <empty>
Rule 72    exp -> nexp p neur12
Rule 73    neur12 -> <empty>
Rule 74    p -> empty
Rule 75    p -> EQ neur11_1 nexp
Rule 76    p -> NOTEQ neur11_2 nexp
Rule 77    p -> > neur11_3 nexp
Rule 78    p -> < neur11_4 nexp
Rule 79    p -> MTHANEQ neur11_5 nexp
Rule 80    p -> LTHANEQ neur11_6 nexp
Rule 81    neur11_1 -> <empty>
Rule 82    neur11_2 -> <empty>
Rule 83    neur11_3 -> <empty>
Rule 84    neur11_4 -> <empty>
Rule 85    neur11_5 -> <empty>
Rule 86    neur11_6 -> <empty>
Rule 87    nexp -> termino neur5 q
Rule 88    neur5 -> <empty>
Rule 89    q -> empty
Rule 90    q -> + neur3_1 nexp
Rule 91    q -> - neur3_2 nexp
Rule 92    neur3_1 -> <empty>
Rule 93    neur3_2 -> <empty>
Rule 94    termino -> factor neur4 n
Rule 95    neur4 -> <empty>
Rule 96    n -> empty
Rule 97    n -> * neur2_1 termino
Rule 98    n -> / neur2_2 termino
Rule 99    neur2_1 -> <empty>
Rule 100   neur2_2 -> <empty>
Rule 101   factor -> ( neur6 expresion ) neur7
Rule 102   factor -> varcte neur1
Rule 103   neur6 -> <empty>
Rule 104   neur7 -> <empty>
Rule 105   neur1 -> <empty>
Rule 106   varcte -> ID r neurVar
Rule 107   varcte -> CTEE neurCteE
Rule 108   varcte -> CTEF neurCteF
Rule 109   varcte -> CTEBOOL neurCteB
Rule 110   varcte -> callreturnfunc
Rule 111   varcte -> CTECHAR neurCteCh
Rule 112   neurVar -> <empty>
Rule 113   neurCteE -> <empty>
Rule 114   neurCteF -> <empty>
Rule 115   neurCteB -> <empty>
Rule 116   neurCteCh -> <empty>
Rule 117   r -> empty
Rule 118   r -> oplista
Rule 119   oplista -> ID . x
Rule 120   x -> inlistset
Rule 121   x -> append
Rule 122   x -> length
Rule 123   x -> getlist
Rule 124   x -> removelist
Rule 125   inlistset -> SET ( CTEE , expresion )
Rule 126   append -> APPEND ( expresion )
Rule 127   length -> LENGTH ( )
Rule 128   getlist -> GET ( expresion )
Rule 129   removelist -> REMOVE ( expresion )
Rule 130   while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17
Rule 131   neur16 -> <empty>
Rule 132   neur17 -> <empty>
Rule 133   play -> PLAY ( NOTA , CTEE ) ;
Rule 134   print -> PRINT expresion ;
Rule 135   callreturnfunc -> CALL ID neur24 ( s ) neur26 ;
Rule 136   s -> empty
Rule 137   s -> expresion neur25 t
Rule 138   neur25 -> <empty>
Rule 139   t -> empty
Rule 140   t -> , s
Rule 141   callvoidfunc -> CALL ID neur24 ( s ) neur26 ;
Rule 142   neur24 -> <empty>
Rule 143   neur26 -> <empty>
Rule 144   return -> RETURN ( expresion ) ;
Rule 145   tipo -> u y
Rule 146   u -> empty
Rule 147   u -> LIST
Rule 148   y -> INT
Rule 149   y -> CHAR
Rule 150   y -> FLOAT
Rule 151   y -> BOOL
Rule 152   empty -> <empty>

Terminals, with rules where they appear

(                    : 14 36 50 51 57 101 125 126 127 128 129 130 133 135 141 144
)                    : 14 36 50 51 57 101 125 126 127 128 129 130 133 135 141 144
*                    : 97
+                    : 90
,                    : 30 125 133 140
-                    : 91
.                    : 119
/                    : 98
:                    : 12
;                    : 12 46 51 57 57 130 133 134 135 141 144
<                    : 78
=                    : 46
>                    : 77
AND                  : 68
APPEND               : 126
BOOL                 : 18 151
CALL                 : 135 141
CANCION              : 36
CHAR                 : 16 149
CTEBOOL              : 109
CTECHAR              : 111
CTEE                 : 36 107 125 133
CTEF                 : 108
ELSE                 : 54
EQ                   : 75
FLOAT                : 17 150
FOR                  : 57
FUNC                 : 14
GET                  : 128
ID                   : 13 14 27 46 106 119 135 141
IF                   : 51
INT                  : 15 148
LENGTH               : 127
LIST                 : 50 147
LTHANEQ              : 80
MTHANEQ              : 79
NEW                  : 50
NOT                  : 64
NOTA                 : 133
NOTEQ                : 76
OR                   : 69
PLAY                 : 133
PRINT                : 134
REMOVE               : 129
RETURN               : 144
SET                  : 125
VAR                  : 12
VOID                 : 19
WHILE                : 130
error                : 
{                    : 35
}                    : 35

Nonterminals, with rules where they appear

a                    : 1 6
append               : 121
asiglista            : 49
asignacion           : 38 57 57
b                    : 4
bloque               : 14 36 51 54 57 130
c                    : 1 11
callreturnfunc       : 110
callvoidfunc         : 45
cancion              : 1
creadirprocglobal    : 1
d                    : 9
empty                : 3 5 8 10 22 24 26 29 31 33 53 63 67 74 89 96 117 136 139 146
estatuto             : 32
exp                  : 65
expresion            : 48 51 57 101 125 126 128 129 130 134 137 144
f                    : 14 25 36
factor               : 94
for                  : 40
funcion              : 9
g                    : 23
getlist              : 123
h                    : 27
i                    : 34 35
if                   : 39
inlistset            : 120
j                    : 32
k                    : 46
l                    : 51
length               : 122
m                    : 62
metercancion         : 36
meterfuncion         : 14
meterparams          : 27
n                    : 94
neur1                : 102
neur10               : 65
neur11_1             : 75
neur11_2             : 76
neur11_3             : 77
neur11_4             : 78
neur11_5             : 79
neur11_6             : 80
neur12               : 72
neur13               : 51 130
neur14               : 54
neur15               : 53
neur16               : 130
neur17               : 130
neur18               : 57
neur19               : 57
neur20               : 57
neur21               : 57
neur22               : 1
neur23               : 14
neur24               : 135 141
neur25               : 137
neur26               : 135 141
neur2_1              : 97
neur2_2              : 98
neur3_1              : 90
neur3_2              : 91
neur4                : 94
neur5                : 87
neur6                : 101
neur7                : 101
neur8                : 46
neur9_1              : 68
neur9_2              : 69
neurCteB             : 109
neurCteCh            : 111
neurCteE             : 107
neurCteF             : 108
neurVar              : 106
nexp                 : 72 75 76 77 78 79 80 90 91
o                    : 65
oplista              : 118
p                    : 72
params               : 14 30
play                 : 43
print                : 44
programa             : 0
q                    : 87
r                    : 106
removelist           : 124
return               : 41
s                    : 135 140 141
subexpresion         : 62 68 69
t                    : 137
termino              : 87 97 98
tipo                 : 12 27
u                    : 145
v                    : 12
varcte               : 102
vars                 : 4 23
while                : 42
x                    : 119
y                    : 145
z                    : 14

Parsing method: LALR

state 0

    (0) S' -> . programa
    (1) programa -> . creadirprocglobal a neur22 c cancion
    (2) creadirprocglobal -> .

    VAR             reduce using rule 2 (creadirprocglobal -> .)
    FUNC            reduce using rule 2 (creadirprocglobal -> .)
    CANCION         reduce using rule 2 (creadirprocglobal -> .)

    creadirprocglobal              shift and go to state 1
    programa                       shift and go to state 2

state 1

    (1) programa -> creadirprocglobal . a neur22 c cancion
    (3) a -> . empty
    (4) a -> . vars b
    (152) empty -> .
    (12) vars -> . VAR v : tipo ;

    FUNC            reduce using rule 152 (empty -> .)
    CANCION         reduce using rule 152 (empty -> .)
    VAR             shift and go to state 5

    a                              shift and go to state 3
    vars                           shift and go to state 4
    empty                          shift and go to state 6

state 2

    (0) S' -> programa .



state 3

    (1) programa -> creadirprocglobal a . neur22 c cancion
    (7) neur22 -> .

    FUNC            reduce using rule 7 (neur22 -> .)
    CANCION         reduce using rule 7 (neur22 -> .)

    neur22                         shift and go to state 7

state 4

    (4) a -> vars . b
    (5) b -> . empty
    (6) b -> . a
    (152) empty -> .
    (3) a -> . empty
    (4) a -> . vars b
    (12) vars -> . VAR v : tipo ;

    FUNC            reduce using rule 152 (empty -> .)
    CANCION         reduce using rule 152 (empty -> .)
    VAR             shift and go to state 5

    a                              shift and go to state 8
    b                              shift and go to state 9
    vars                           shift and go to state 4
    empty                          shift and go to state 10

state 5

    (12) vars -> VAR . v : tipo ;
    (13) v -> . ID

    ID              shift and go to state 12

    v                              shift and go to state 11

state 6

    (3) a -> empty .

    FUNC            reduce using rule 3 (a -> empty .)
    CANCION         reduce using rule 3 (a -> empty .)


state 7

    (1) programa -> creadirprocglobal a neur22 . c cancion
    (8) c -> . empty
    (9) c -> . funcion d
    (152) empty -> .
    (14) funcion -> . FUNC z ID meterfuncion ( params ) f neur23 bloque

    CANCION         reduce using rule 152 (empty -> .)
    FUNC            shift and go to state 14

    c                              shift and go to state 13
    empty                          shift and go to state 15
    funcion                        shift and go to state 16

state 8

    (6) b -> a .

    FUNC            reduce using rule 6 (b -> a .)
    CANCION         reduce using rule 6 (b -> a .)


state 9

    (4) a -> vars b .

    FUNC            reduce using rule 4 (a -> vars b .)
    CANCION         reduce using rule 4 (a -> vars b .)


state 10

    (5) b -> empty .
    (3) a -> empty .

  ! reduce/reduce conflict for FUNC resolved using rule 3 (a -> empty .)
  ! reduce/reduce conflict for CANCION resolved using rule 3 (a -> empty .)
    FUNC            reduce using rule 3 (a -> empty .)
    CANCION         reduce using rule 3 (a -> empty .)

  ! FUNC            [ reduce using rule 5 (b -> empty .) ]
  ! CANCION         [ reduce using rule 5 (b -> empty .) ]


state 11

    (12) vars -> VAR v . : tipo ;

    :               shift and go to state 17


state 12

    (13) v -> ID .

    :               reduce using rule 13 (v -> ID .)


state 13

    (1) programa -> creadirprocglobal a neur22 c . cancion
    (36) cancion -> . CANCION ( CTEE ) metercancion f bloque

    CANCION         shift and go to state 19

    cancion                        shift and go to state 18

state 14

    (14) funcion -> FUNC . z ID meterfuncion ( params ) f neur23 bloque
    (15) z -> . INT
    (16) z -> . CHAR
    (17) z -> . FLOAT
    (18) z -> . BOOL
    (19) z -> . VOID

    INT             shift and go to state 23
    CHAR            shift and go to state 22
    FLOAT           shift and go to state 21
    BOOL            shift and go to state 24
    VOID            shift and go to state 20

    z                              shift and go to state 25

state 15

    (8) c -> empty .

    CANCION         reduce using rule 8 (c -> empty .)


state 16

    (9) c -> funcion . d
    (10) d -> . empty
    (11) d -> . c
    (152) empty -> .
    (8) c -> . empty
    (9) c -> . funcion d
    (14) funcion -> . FUNC z ID meterfuncion ( params ) f neur23 bloque

    CANCION         reduce using rule 152 (empty -> .)
    FUNC            shift and go to state 14

    c                              shift and go to state 26
    d                              shift and go to state 27
    empty                          shift and go to state 28
    funcion                        shift and go to state 16

state 17

    (12) vars -> VAR v : . tipo ;
    (145) tipo -> . u y
    (146) u -> . empty
    (147) u -> . LIST
    (152) empty -> .

    LIST            shift and go to state 30
    INT             reduce using rule 152 (empty -> .)
    CHAR            reduce using rule 152 (empty -> .)
    FLOAT           reduce using rule 152 (empty -> .)
    BOOL            reduce using rule 152 (empty -> .)

    u                              shift and go to state 31
    empty                          shift and go to state 32
    tipo                           shift and go to state 29

state 18

    (1) programa -> creadirprocglobal a neur22 c cancion .

    $end            reduce using rule 1 (programa -> creadirprocglobal a neur22 c cancion .)


state 19

    (36) cancion -> CANCION . ( CTEE ) metercancion f bloque

    (               shift and go to state 33


state 20

    (19) z -> VOID .

    ID              reduce using rule 19 (z -> VOID .)


state 21

    (17) z -> FLOAT .

    ID              reduce using rule 17 (z -> FLOAT .)


state 22

    (16) z -> CHAR .

    ID              reduce using rule 16 (z -> CHAR .)


state 23

    (15) z -> INT .

    ID              reduce using rule 15 (z -> INT .)


state 24

    (18) z -> BOOL .

    ID              reduce using rule 18 (z -> BOOL .)


state 25

    (14) funcion -> FUNC z . ID meterfuncion ( params ) f neur23 bloque

    ID              shift and go to state 34


state 26

    (11) d -> c .

    CANCION         reduce using rule 11 (d -> c .)


state 27

    (9) c -> funcion d .

    CANCION         reduce using rule 9 (c -> funcion d .)


state 28

    (10) d -> empty .
    (8) c -> empty .

  ! reduce/reduce conflict for CANCION resolved using rule 8 (c -> empty .)
    CANCION         reduce using rule 8 (c -> empty .)

  ! CANCION         [ reduce using rule 10 (d -> empty .) ]


state 29

    (12) vars -> VAR v : tipo . ;

    ;               shift and go to state 35


state 30

    (147) u -> LIST .

    INT             reduce using rule 147 (u -> LIST .)
    CHAR            reduce using rule 147 (u -> LIST .)
    FLOAT           reduce using rule 147 (u -> LIST .)
    BOOL            reduce using rule 147 (u -> LIST .)


state 31

    (145) tipo -> u . y
    (148) y -> . INT
    (149) y -> . CHAR
    (150) y -> . FLOAT
    (151) y -> . BOOL

    INT             shift and go to state 36
    CHAR            shift and go to state 38
    FLOAT           shift and go to state 37
    BOOL            shift and go to state 40

    y                              shift and go to state 39

state 32

    (146) u -> empty .

    INT             reduce using rule 146 (u -> empty .)
    CHAR            reduce using rule 146 (u -> empty .)
    FLOAT           reduce using rule 146 (u -> empty .)
    BOOL            reduce using rule 146 (u -> empty .)


state 33

    (36) cancion -> CANCION ( . CTEE ) metercancion f bloque

    CTEE            shift and go to state 41


state 34

    (14) funcion -> FUNC z ID . meterfuncion ( params ) f neur23 bloque
    (20) meterfuncion -> .

    (               reduce using rule 20 (meterfuncion -> .)

    meterfuncion                   shift and go to state 42

state 35

    (12) vars -> VAR v : tipo ; .

    VAR             reduce using rule 12 (vars -> VAR v : tipo ; .)
    FUNC            reduce using rule 12 (vars -> VAR v : tipo ; .)
    CANCION         reduce using rule 12 (vars -> VAR v : tipo ; .)
    {               reduce using rule 12 (vars -> VAR v : tipo ; .)


state 36

    (148) y -> INT .

    ;               reduce using rule 148 (y -> INT .)
    ID              reduce using rule 148 (y -> INT .)


state 37

    (150) y -> FLOAT .

    ;               reduce using rule 150 (y -> FLOAT .)
    ID              reduce using rule 150 (y -> FLOAT .)


state 38

    (149) y -> CHAR .

    ;               reduce using rule 149 (y -> CHAR .)
    ID              reduce using rule 149 (y -> CHAR .)


state 39

    (145) tipo -> u y .

    ID              reduce using rule 145 (tipo -> u y .)
    ;               reduce using rule 145 (tipo -> u y .)


state 40

    (151) y -> BOOL .

    ;               reduce using rule 151 (y -> BOOL .)
    ID              reduce using rule 151 (y -> BOOL .)


state 41

    (36) cancion -> CANCION ( CTEE . ) metercancion f bloque

    )               shift and go to state 43


state 42

    (14) funcion -> FUNC z ID meterfuncion . ( params ) f neur23 bloque

    (               shift and go to state 44


state 43

    (36) cancion -> CANCION ( CTEE ) . metercancion f bloque
    (37) metercancion -> .

    VAR             reduce using rule 37 (metercancion -> .)
    {               reduce using rule 37 (metercancion -> .)

    metercancion                   shift and go to state 45

state 44

    (14) funcion -> FUNC z ID meterfuncion ( . params ) f neur23 bloque
    (26) params -> . empty
    (27) params -> . tipo ID meterparams h
    (152) empty -> .
    (145) tipo -> . u y
    (146) u -> . empty
    (147) u -> . LIST

    )               reduce using rule 152 (empty -> .)
    INT             reduce using rule 152 (empty -> .)
    CHAR            reduce using rule 152 (empty -> .)
    FLOAT           reduce using rule 152 (empty -> .)
    BOOL            reduce using rule 152 (empty -> .)
    LIST            shift and go to state 30

    tipo                           shift and go to state 46
    params                         shift and go to state 47
    u                              shift and go to state 31
    empty                          shift and go to state 48

state 45

    (36) cancion -> CANCION ( CTEE ) metercancion . f bloque
    (22) f -> . empty
    (23) f -> . vars g
    (152) empty -> .
    (12) vars -> . VAR v : tipo ;

    {               reduce using rule 152 (empty -> .)
    VAR             shift and go to state 5

    vars                           shift and go to state 49
    f                              shift and go to state 50
    empty                          shift and go to state 51

state 46

    (27) params -> tipo . ID meterparams h

    ID              shift and go to state 52


state 47

    (14) funcion -> FUNC z ID meterfuncion ( params . ) f neur23 bloque

    )               shift and go to state 53


state 48

    (26) params -> empty .
    (146) u -> empty .

    )               reduce using rule 26 (params -> empty .)
    INT             reduce using rule 146 (u -> empty .)
    CHAR            reduce using rule 146 (u -> empty .)
    FLOAT           reduce using rule 146 (u -> empty .)
    BOOL            reduce using rule 146 (u -> empty .)


state 49

    (23) f -> vars . g
    (24) g -> . empty
    (25) g -> . f
    (152) empty -> .
    (22) f -> . empty
    (23) f -> . vars g
    (12) vars -> . VAR v : tipo ;

    {               reduce using rule 152 (empty -> .)
    VAR             shift and go to state 5

    g                              shift and go to state 54
    f                              shift and go to state 55
    vars                           shift and go to state 49
    empty                          shift and go to state 56

state 50

    (36) cancion -> CANCION ( CTEE ) metercancion f . bloque
    (35) bloque -> . { i }

    {               shift and go to state 57

    bloque                         shift and go to state 58

state 51

    (22) f -> empty .

    {               reduce using rule 22 (f -> empty .)


state 52

    (27) params -> tipo ID . meterparams h
    (28) meterparams -> .

    ,               reduce using rule 28 (meterparams -> .)
    )               reduce using rule 28 (meterparams -> .)

    meterparams                    shift and go to state 59

state 53

    (14) funcion -> FUNC z ID meterfuncion ( params ) . f neur23 bloque
    (22) f -> . empty
    (23) f -> . vars g
    (152) empty -> .
    (12) vars -> . VAR v : tipo ;

    {               reduce using rule 152 (empty -> .)
    VAR             shift and go to state 5

    vars                           shift and go to state 49
    f                              shift and go to state 60
    empty                          shift and go to state 51

state 54

    (23) f -> vars g .

    {               reduce using rule 23 (f -> vars g .)


state 55

    (25) g -> f .

    {               reduce using rule 25 (g -> f .)


state 56

    (24) g -> empty .
    (22) f -> empty .

  ! reduce/reduce conflict for { resolved using rule 22 (f -> empty .)
    {               reduce using rule 22 (f -> empty .)

  ! {               [ reduce using rule 24 (g -> empty .) ]


state 57

    (35) bloque -> { . i }
    (31) i -> . empty
    (32) i -> . estatuto j
    (152) empty -> .
    (38) estatuto -> . asignacion
    (39) estatuto -> . if
    (40) estatuto -> . for
    (41) estatuto -> . return
    (42) estatuto -> . while
    (43) estatuto -> . play
    (44) estatuto -> . print
    (45) estatuto -> . callvoidfunc
    (46) asignacion -> . ID = neur8 k ;
    (51) if -> . IF ( expresion ) neur13 bloque l ;
    (57) for -> . FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (144) return -> . RETURN ( expresion ) ;
    (130) while -> . WHILE ( neur16 expresion ) neur13 bloque ; neur17
    (133) play -> . PLAY ( NOTA , CTEE ) ;
    (134) print -> . PRINT expresion ;
    (141) callvoidfunc -> . CALL ID neur24 ( s ) neur26 ;

    }               reduce using rule 152 (empty -> .)
    ID              shift and go to state 75
    IF              shift and go to state 76
    FOR             shift and go to state 74
    RETURN          shift and go to state 61
    WHILE           shift and go to state 62
    PLAY            shift and go to state 71
    PRINT           shift and go to state 63
    CALL            shift and go to state 69

    if                             shift and go to state 64
    for                            shift and go to state 65
    callvoidfunc                   shift and go to state 66
    estatuto                       shift and go to state 67
    print                          shift and go to state 68
    empty                          shift and go to state 70
    play                           shift and go to state 72
    return                         shift and go to state 73
    asignacion                     shift and go to state 77
    i                              shift and go to state 78
    while                          shift and go to state 79

state 58

    (36) cancion -> CANCION ( CTEE ) metercancion f bloque .

    $end            reduce using rule 36 (cancion -> CANCION ( CTEE ) metercancion f bloque .)


state 59

    (27) params -> tipo ID meterparams . h
    (29) h -> . empty
    (30) h -> . , params
    (152) empty -> .

    ,               shift and go to state 81
    )               reduce using rule 152 (empty -> .)

    h                              shift and go to state 80
    empty                          shift and go to state 82

state 60

    (14) funcion -> FUNC z ID meterfuncion ( params ) f . neur23 bloque
    (21) neur23 -> .

    {               reduce using rule 21 (neur23 -> .)

    neur23                         shift and go to state 83

state 61

    (144) return -> RETURN . ( expresion ) ;

    (               shift and go to state 84


state 62

    (130) while -> WHILE . ( neur16 expresion ) neur13 bloque ; neur17

    (               shift and go to state 85


state 63

    (134) print -> PRINT . expresion ;
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (152) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 152 (empty -> .)
    ID              reduce using rule 152 (empty -> .)
    CTEE            reduce using rule 152 (empty -> .)
    CTEF            reduce using rule 152 (empty -> .)
    CTEBOOL         reduce using rule 152 (empty -> .)
    CTECHAR         reduce using rule 152 (empty -> .)
    CALL            reduce using rule 152 (empty -> .)

    expresion                      shift and go to state 86
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 64

    (39) estatuto -> if .

    ID              reduce using rule 39 (estatuto -> if .)
    IF              reduce using rule 39 (estatuto -> if .)
    FOR             reduce using rule 39 (estatuto -> if .)
    RETURN          reduce using rule 39 (estatuto -> if .)
    WHILE           reduce using rule 39 (estatuto -> if .)
    PLAY            reduce using rule 39 (estatuto -> if .)
    PRINT           reduce using rule 39 (estatuto -> if .)
    CALL            reduce using rule 39 (estatuto -> if .)
    }               reduce using rule 39 (estatuto -> if .)


state 65

    (40) estatuto -> for .

    ID              reduce using rule 40 (estatuto -> for .)
    IF              reduce using rule 40 (estatuto -> for .)
    FOR             reduce using rule 40 (estatuto -> for .)
    RETURN          reduce using rule 40 (estatuto -> for .)
    WHILE           reduce using rule 40 (estatuto -> for .)
    PLAY            reduce using rule 40 (estatuto -> for .)
    PRINT           reduce using rule 40 (estatuto -> for .)
    CALL            reduce using rule 40 (estatuto -> for .)
    }               reduce using rule 40 (estatuto -> for .)


state 66

    (45) estatuto -> callvoidfunc .

    ID              reduce using rule 45 (estatuto -> callvoidfunc .)
    IF              reduce using rule 45 (estatuto -> callvoidfunc .)
    FOR             reduce using rule 45 (estatuto -> callvoidfunc .)
    RETURN          reduce using rule 45 (estatuto -> callvoidfunc .)
    WHILE           reduce using rule 45 (estatuto -> callvoidfunc .)
    PLAY            reduce using rule 45 (estatuto -> callvoidfunc .)
    PRINT           reduce using rule 45 (estatuto -> callvoidfunc .)
    CALL            reduce using rule 45 (estatuto -> callvoidfunc .)
    }               reduce using rule 45 (estatuto -> callvoidfunc .)


state 67

    (32) i -> estatuto . j
    (33) j -> . empty
    (34) j -> . i
    (152) empty -> .
    (31) i -> . empty
    (32) i -> . estatuto j
    (38) estatuto -> . asignacion
    (39) estatuto -> . if
    (40) estatuto -> . for
    (41) estatuto -> . return
    (42) estatuto -> . while
    (43) estatuto -> . play
    (44) estatuto -> . print
    (45) estatuto -> . callvoidfunc
    (46) asignacion -> . ID = neur8 k ;
    (51) if -> . IF ( expresion ) neur13 bloque l ;
    (57) for -> . FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (144) return -> . RETURN ( expresion ) ;
    (130) while -> . WHILE ( neur16 expresion ) neur13 bloque ; neur17
    (133) play -> . PLAY ( NOTA , CTEE ) ;
    (134) print -> . PRINT expresion ;
    (141) callvoidfunc -> . CALL ID neur24 ( s ) neur26 ;

    }               reduce using rule 152 (empty -> .)
    ID              shift and go to state 75
    IF              shift and go to state 76
    FOR             shift and go to state 74
    RETURN          shift and go to state 61
    WHILE           shift and go to state 62
    PLAY            shift and go to state 71
    PRINT           shift and go to state 63
    CALL            shift and go to state 69

    if                             shift and go to state 64
    for                            shift and go to state 65
    callvoidfunc                   shift and go to state 66
    estatuto                       shift and go to state 67
    print                          shift and go to state 68
    empty                          shift and go to state 90
    play                           shift and go to state 72
    return                         shift and go to state 73
    asignacion                     shift and go to state 77
    i                              shift and go to state 91
    j                              shift and go to state 92
    while                          shift and go to state 79

state 68

    (44) estatuto -> print .

    ID              reduce using rule 44 (estatuto -> print .)
    IF              reduce using rule 44 (estatuto -> print .)
    FOR             reduce using rule 44 (estatuto -> print .)
    RETURN          reduce using rule 44 (estatuto -> print .)
    WHILE           reduce using rule 44 (estatuto -> print .)
    PLAY            reduce using rule 44 (estatuto -> print .)
    PRINT           reduce using rule 44 (estatuto -> print .)
    CALL            reduce using rule 44 (estatuto -> print .)
    }               reduce using rule 44 (estatuto -> print .)


state 69

    (141) callvoidfunc -> CALL . ID neur24 ( s ) neur26 ;

    ID              shift and go to state 93


state 70

    (31) i -> empty .

    }               reduce using rule 31 (i -> empty .)


state 71

    (133) play -> PLAY . ( NOTA , CTEE ) ;

    (               shift and go to state 94


state 72

    (43) estatuto -> play .

    ID              reduce using rule 43 (estatuto -> play .)
    IF              reduce using rule 43 (estatuto -> play .)
    FOR             reduce using rule 43 (estatuto -> play .)
    RETURN          reduce using rule 43 (estatuto -> play .)
    WHILE           reduce using rule 43 (estatuto -> play .)
    PLAY            reduce using rule 43 (estatuto -> play .)
    PRINT           reduce using rule 43 (estatuto -> play .)
    CALL            reduce using rule 43 (estatuto -> play .)
    }               reduce using rule 43 (estatuto -> play .)


state 73

    (41) estatuto -> return .

    ID              reduce using rule 41 (estatuto -> return .)
    IF              reduce using rule 41 (estatuto -> return .)
    FOR             reduce using rule 41 (estatuto -> return .)
    RETURN          reduce using rule 41 (estatuto -> return .)
    WHILE           reduce using rule 41 (estatuto -> return .)
    PLAY            reduce using rule 41 (estatuto -> return .)
    PRINT           reduce using rule 41 (estatuto -> return .)
    CALL            reduce using rule 41 (estatuto -> return .)
    }               reduce using rule 41 (estatuto -> return .)


state 74

    (57) for -> FOR . ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20

    (               shift and go to state 95


state 75

    (46) asignacion -> ID . = neur8 k ;

    =               shift and go to state 96


state 76

    (51) if -> IF . ( expresion ) neur13 bloque l ;

    (               shift and go to state 97


state 77

    (38) estatuto -> asignacion .

    ID              reduce using rule 38 (estatuto -> asignacion .)
    IF              reduce using rule 38 (estatuto -> asignacion .)
    FOR             reduce using rule 38 (estatuto -> asignacion .)
    RETURN          reduce using rule 38 (estatuto -> asignacion .)
    WHILE           reduce using rule 38 (estatuto -> asignacion .)
    PLAY            reduce using rule 38 (estatuto -> asignacion .)
    PRINT           reduce using rule 38 (estatuto -> asignacion .)
    CALL            reduce using rule 38 (estatuto -> asignacion .)
    }               reduce using rule 38 (estatuto -> asignacion .)


state 78

    (35) bloque -> { i . }

    }               shift and go to state 98


state 79

    (42) estatuto -> while .

    ID              reduce using rule 42 (estatuto -> while .)
    IF              reduce using rule 42 (estatuto -> while .)
    FOR             reduce using rule 42 (estatuto -> while .)
    RETURN          reduce using rule 42 (estatuto -> while .)
    WHILE           reduce using rule 42 (estatuto -> while .)
    PLAY            reduce using rule 42 (estatuto -> while .)
    PRINT           reduce using rule 42 (estatuto -> while .)
    CALL            reduce using rule 42 (estatuto -> while .)
    }               reduce using rule 42 (estatuto -> while .)


state 80

    (27) params -> tipo ID meterparams h .

    )               reduce using rule 27 (params -> tipo ID meterparams h .)


state 81

    (30) h -> , . params
    (26) params -> . empty
    (27) params -> . tipo ID meterparams h
    (152) empty -> .
    (145) tipo -> . u y
    (146) u -> . empty
    (147) u -> . LIST

    )               reduce using rule 152 (empty -> .)
    INT             reduce using rule 152 (empty -> .)
    CHAR            reduce using rule 152 (empty -> .)
    FLOAT           reduce using rule 152 (empty -> .)
    BOOL            reduce using rule 152 (empty -> .)
    LIST            shift and go to state 30

    tipo                           shift and go to state 46
    u                              shift and go to state 31
    params                         shift and go to state 99
    empty                          shift and go to state 48

state 82

    (29) h -> empty .

    )               reduce using rule 29 (h -> empty .)


state 83

    (14) funcion -> FUNC z ID meterfuncion ( params ) f neur23 . bloque
    (35) bloque -> . { i }

    {               shift and go to state 57

    bloque                         shift and go to state 100

state 84

    (144) return -> RETURN ( . expresion ) ;
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (152) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 152 (empty -> .)
    ID              reduce using rule 152 (empty -> .)
    CTEE            reduce using rule 152 (empty -> .)
    CTEF            reduce using rule 152 (empty -> .)
    CTEBOOL         reduce using rule 152 (empty -> .)
    CTECHAR         reduce using rule 152 (empty -> .)
    CALL            reduce using rule 152 (empty -> .)

    expresion                      shift and go to state 101
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 85

    (130) while -> WHILE ( . neur16 expresion ) neur13 bloque ; neur17
    (131) neur16 -> .

    NOT             reduce using rule 131 (neur16 -> .)
    (               reduce using rule 131 (neur16 -> .)
    ID              reduce using rule 131 (neur16 -> .)
    CTEE            reduce using rule 131 (neur16 -> .)
    CTEF            reduce using rule 131 (neur16 -> .)
    CTEBOOL         reduce using rule 131 (neur16 -> .)
    CTECHAR         reduce using rule 131 (neur16 -> .)
    CALL            reduce using rule 131 (neur16 -> .)

    neur16                         shift and go to state 102

state 86

    (134) print -> PRINT expresion . ;

    ;               shift and go to state 103


state 87

    (62) expresion -> m . subexpresion
    (65) subexpresion -> . exp neur10 o
    (72) exp -> . nexp p neur12
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte neur1
    (106) varcte -> . ID r neurVar
    (107) varcte -> . CTEE neurCteE
    (108) varcte -> . CTEF neurCteF
    (109) varcte -> . CTEBOOL neurCteB
    (110) varcte -> . callreturnfunc
    (111) varcte -> . CTECHAR neurCteCh
    (135) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 108
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110
    subexpresion                   shift and go to state 112
    exp                            shift and go to state 116

state 88

    (64) m -> NOT .

    (               reduce using rule 64 (m -> NOT .)
    ID              reduce using rule 64 (m -> NOT .)
    CTEE            reduce using rule 64 (m -> NOT .)
    CTEF            reduce using rule 64 (m -> NOT .)
    CTEBOOL         reduce using rule 64 (m -> NOT .)
    CTECHAR         reduce using rule 64 (m -> NOT .)
    CALL            reduce using rule 64 (m -> NOT .)


state 89

    (63) m -> empty .

    (               reduce using rule 63 (m -> empty .)
    ID              reduce using rule 63 (m -> empty .)
    CTEE            reduce using rule 63 (m -> empty .)
    CTEF            reduce using rule 63 (m -> empty .)
    CTEBOOL         reduce using rule 63 (m -> empty .)
    CTECHAR         reduce using rule 63 (m -> empty .)
    CALL            reduce using rule 63 (m -> empty .)


state 90

    (33) j -> empty .
    (31) i -> empty .

  ! reduce/reduce conflict for } resolved using rule 31 (i -> empty .)
    }               reduce using rule 31 (i -> empty .)

  ! }               [ reduce using rule 33 (j -> empty .) ]


state 91

    (34) j -> i .

    }               reduce using rule 34 (j -> i .)


state 92

    (32) i -> estatuto j .

    }               reduce using rule 32 (i -> estatuto j .)


state 93

    (141) callvoidfunc -> CALL ID . neur24 ( s ) neur26 ;
    (142) neur24 -> .

    (               reduce using rule 142 (neur24 -> .)

    neur24                         shift and go to state 118

state 94

    (133) play -> PLAY ( . NOTA , CTEE ) ;

    NOTA            shift and go to state 119


state 95

    (57) for -> FOR ( . asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (46) asignacion -> . ID = neur8 k ;

    ID              shift and go to state 75

    asignacion                     shift and go to state 120

state 96

    (46) asignacion -> ID = . neur8 k ;
    (47) neur8 -> .

    NEW             reduce using rule 47 (neur8 -> .)
    NOT             reduce using rule 47 (neur8 -> .)
    (               reduce using rule 47 (neur8 -> .)
    ID              reduce using rule 47 (neur8 -> .)
    CTEE            reduce using rule 47 (neur8 -> .)
    CTEF            reduce using rule 47 (neur8 -> .)
    CTEBOOL         reduce using rule 47 (neur8 -> .)
    CTECHAR         reduce using rule 47 (neur8 -> .)
    CALL            reduce using rule 47 (neur8 -> .)

    neur8                          shift and go to state 121

state 97

    (51) if -> IF ( . expresion ) neur13 bloque l ;
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (152) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 152 (empty -> .)
    ID              reduce using rule 152 (empty -> .)
    CTEE            reduce using rule 152 (empty -> .)
    CTEF            reduce using rule 152 (empty -> .)
    CTEBOOL         reduce using rule 152 (empty -> .)
    CTECHAR         reduce using rule 152 (empty -> .)
    CALL            reduce using rule 152 (empty -> .)

    expresion                      shift and go to state 122
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 98

    (35) bloque -> { i } .

    ;               reduce using rule 35 (bloque -> { i } .)
    ELSE            reduce using rule 35 (bloque -> { i } .)
    $end            reduce using rule 35 (bloque -> { i } .)
    FUNC            reduce using rule 35 (bloque -> { i } .)
    CANCION         reduce using rule 35 (bloque -> { i } .)


state 99

    (30) h -> , params .

    )               reduce using rule 30 (h -> , params .)


state 100

    (14) funcion -> FUNC z ID meterfuncion ( params ) f neur23 bloque .

    FUNC            reduce using rule 14 (funcion -> FUNC z ID meterfuncion ( params ) f neur23 bloque .)
    CANCION         reduce using rule 14 (funcion -> FUNC z ID meterfuncion ( params ) f neur23 bloque .)


state 101

    (144) return -> RETURN ( expresion . ) ;

    )               shift and go to state 123


state 102

    (130) while -> WHILE ( neur16 . expresion ) neur13 bloque ; neur17
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (152) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 152 (empty -> .)
    ID              reduce using rule 152 (empty -> .)
    CTEE            reduce using rule 152 (empty -> .)
    CTEF            reduce using rule 152 (empty -> .)
    CTEBOOL         reduce using rule 152 (empty -> .)
    CTECHAR         reduce using rule 152 (empty -> .)
    CALL            reduce using rule 152 (empty -> .)

    expresion                      shift and go to state 124
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 103

    (134) print -> PRINT expresion ; .

    ID              reduce using rule 134 (print -> PRINT expresion ; .)
    IF              reduce using rule 134 (print -> PRINT expresion ; .)
    FOR             reduce using rule 134 (print -> PRINT expresion ; .)
    RETURN          reduce using rule 134 (print -> PRINT expresion ; .)
    WHILE           reduce using rule 134 (print -> PRINT expresion ; .)
    PLAY            reduce using rule 134 (print -> PRINT expresion ; .)
    PRINT           reduce using rule 134 (print -> PRINT expresion ; .)
    CALL            reduce using rule 134 (print -> PRINT expresion ; .)
    }               reduce using rule 134 (print -> PRINT expresion ; .)


state 104

    (87) nexp -> termino . neur5 q
    (88) neur5 -> .

    +               reduce using rule 88 (neur5 -> .)
    -               reduce using rule 88 (neur5 -> .)
    EQ              reduce using rule 88 (neur5 -> .)
    NOTEQ           reduce using rule 88 (neur5 -> .)
    >               reduce using rule 88 (neur5 -> .)
    <               reduce using rule 88 (neur5 -> .)
    MTHANEQ         reduce using rule 88 (neur5 -> .)
    LTHANEQ         reduce using rule 88 (neur5 -> .)
    AND             reduce using rule 88 (neur5 -> .)
    OR              reduce using rule 88 (neur5 -> .)
    ;               reduce using rule 88 (neur5 -> .)
    )               reduce using rule 88 (neur5 -> .)
    ,               reduce using rule 88 (neur5 -> .)

    neur5                          shift and go to state 125

state 105

    (111) varcte -> CTECHAR . neurCteCh
    (116) neurCteCh -> .

    *               reduce using rule 116 (neurCteCh -> .)
    /               reduce using rule 116 (neurCteCh -> .)
    +               reduce using rule 116 (neurCteCh -> .)
    -               reduce using rule 116 (neurCteCh -> .)
    EQ              reduce using rule 116 (neurCteCh -> .)
    NOTEQ           reduce using rule 116 (neurCteCh -> .)
    >               reduce using rule 116 (neurCteCh -> .)
    <               reduce using rule 116 (neurCteCh -> .)
    MTHANEQ         reduce using rule 116 (neurCteCh -> .)
    LTHANEQ         reduce using rule 116 (neurCteCh -> .)
    AND             reduce using rule 116 (neurCteCh -> .)
    OR              reduce using rule 116 (neurCteCh -> .)
    ;               reduce using rule 116 (neurCteCh -> .)
    )               reduce using rule 116 (neurCteCh -> .)
    ,               reduce using rule 116 (neurCteCh -> .)

    neurCteCh                      shift and go to state 126

state 106

    (102) factor -> varcte . neur1
    (105) neur1 -> .

    *               reduce using rule 105 (neur1 -> .)
    /               reduce using rule 105 (neur1 -> .)
    +               reduce using rule 105 (neur1 -> .)
    -               reduce using rule 105 (neur1 -> .)
    EQ              reduce using rule 105 (neur1 -> .)
    NOTEQ           reduce using rule 105 (neur1 -> .)
    >               reduce using rule 105 (neur1 -> .)
    <               reduce using rule 105 (neur1 -> .)
    MTHANEQ         reduce using rule 105 (neur1 -> .)
    LTHANEQ         reduce using rule 105 (neur1 -> .)
    AND             reduce using rule 105 (neur1 -> .)
    OR              reduce using rule 105 (neur1 -> .)
    ;               reduce using rule 105 (neur1 -> .)
    )               reduce using rule 105 (neur1 -> .)
    ,               reduce using rule 105 (neur1 -> .)

    neur1                          shift and go to state 127

state 107

    (101) factor -> ( . neur6 expresion ) neur7
    (103) neur6 -> .

    NOT             reduce using rule 103 (neur6 -> .)
    (               reduce using rule 103 (neur6 -> .)
    ID              reduce using rule 103 (neur6 -> .)
    CTEE            reduce using rule 103 (neur6 -> .)
    CTEF            reduce using rule 103 (neur6 -> .)
    CTEBOOL         reduce using rule 103 (neur6 -> .)
    CTECHAR         reduce using rule 103 (neur6 -> .)
    CALL            reduce using rule 103 (neur6 -> .)

    neur6                          shift and go to state 128

state 108

    (72) exp -> nexp . p neur12
    (74) p -> . empty
    (75) p -> . EQ neur11_1 nexp
    (76) p -> . NOTEQ neur11_2 nexp
    (77) p -> . > neur11_3 nexp
    (78) p -> . < neur11_4 nexp
    (79) p -> . MTHANEQ neur11_5 nexp
    (80) p -> . LTHANEQ neur11_6 nexp
    (152) empty -> .

    EQ              shift and go to state 133
    NOTEQ           shift and go to state 132
    >               shift and go to state 136
    <               shift and go to state 134
    MTHANEQ         shift and go to state 129
    LTHANEQ         shift and go to state 131
    AND             reduce using rule 152 (empty -> .)
    OR              reduce using rule 152 (empty -> .)
    ;               reduce using rule 152 (empty -> .)
    )               reduce using rule 152 (empty -> .)
    ,               reduce using rule 152 (empty -> .)

    p                              shift and go to state 130
    empty                          shift and go to state 135

state 109

    (110) varcte -> callreturnfunc .

    *               reduce using rule 110 (varcte -> callreturnfunc .)
    /               reduce using rule 110 (varcte -> callreturnfunc .)
    +               reduce using rule 110 (varcte -> callreturnfunc .)
    -               reduce using rule 110 (varcte -> callreturnfunc .)
    AND             reduce using rule 110 (varcte -> callreturnfunc .)
    OR              reduce using rule 110 (varcte -> callreturnfunc .)
    ;               reduce using rule 110 (varcte -> callreturnfunc .)
    )               reduce using rule 110 (varcte -> callreturnfunc .)
    ,               reduce using rule 110 (varcte -> callreturnfunc .)
    EQ              reduce using rule 110 (varcte -> callreturnfunc .)
    NOTEQ           reduce using rule 110 (varcte -> callreturnfunc .)
    >               reduce using rule 110 (varcte -> callreturnfunc .)
    <               reduce using rule 110 (varcte -> callreturnfunc .)
    MTHANEQ         reduce using rule 110 (varcte -> callreturnfunc .)
    LTHANEQ         reduce using rule 110 (varcte -> callreturnfunc .)


state 110

    (94) termino -> factor . neur4 n
    (95) neur4 -> .

    *               reduce using rule 95 (neur4 -> .)
    /               reduce using rule 95 (neur4 -> .)
    +               reduce using rule 95 (neur4 -> .)
    -               reduce using rule 95 (neur4 -> .)
    EQ              reduce using rule 95 (neur4 -> .)
    NOTEQ           reduce using rule 95 (neur4 -> .)
    >               reduce using rule 95 (neur4 -> .)
    <               reduce using rule 95 (neur4 -> .)
    MTHANEQ         reduce using rule 95 (neur4 -> .)
    LTHANEQ         reduce using rule 95 (neur4 -> .)
    AND             reduce using rule 95 (neur4 -> .)
    OR              reduce using rule 95 (neur4 -> .)
    ;               reduce using rule 95 (neur4 -> .)
    )               reduce using rule 95 (neur4 -> .)
    ,               reduce using rule 95 (neur4 -> .)

    neur4                          shift and go to state 137

state 111

    (135) callreturnfunc -> CALL . ID neur24 ( s ) neur26 ;

    ID              shift and go to state 138


state 112

    (62) expresion -> m subexpresion .

    )               reduce using rule 62 (expresion -> m subexpresion .)
    ;               reduce using rule 62 (expresion -> m subexpresion .)
    ,               reduce using rule 62 (expresion -> m subexpresion .)


state 113

    (106) varcte -> ID . r neurVar
    (117) r -> . empty
    (118) r -> . oplista
    (152) empty -> .
    (119) oplista -> . ID . x

    *               reduce using rule 152 (empty -> .)
    /               reduce using rule 152 (empty -> .)
    +               reduce using rule 152 (empty -> .)
    -               reduce using rule 152 (empty -> .)
    EQ              reduce using rule 152 (empty -> .)
    NOTEQ           reduce using rule 152 (empty -> .)
    >               reduce using rule 152 (empty -> .)
    <               reduce using rule 152 (empty -> .)
    MTHANEQ         reduce using rule 152 (empty -> .)
    LTHANEQ         reduce using rule 152 (empty -> .)
    AND             reduce using rule 152 (empty -> .)
    OR              reduce using rule 152 (empty -> .)
    ;               reduce using rule 152 (empty -> .)
    )               reduce using rule 152 (empty -> .)
    ,               reduce using rule 152 (empty -> .)
    ID              shift and go to state 141

    oplista                        shift and go to state 139
    r                              shift and go to state 140
    empty                          shift and go to state 142

state 114

    (109) varcte -> CTEBOOL . neurCteB
    (115) neurCteB -> .

    *               reduce using rule 115 (neurCteB -> .)
    /               reduce using rule 115 (neurCteB -> .)
    +               reduce using rule 115 (neurCteB -> .)
    -               reduce using rule 115 (neurCteB -> .)
    EQ              reduce using rule 115 (neurCteB -> .)
    NOTEQ           reduce using rule 115 (neurCteB -> .)
    >               reduce using rule 115 (neurCteB -> .)
    <               reduce using rule 115 (neurCteB -> .)
    MTHANEQ         reduce using rule 115 (neurCteB -> .)
    LTHANEQ         reduce using rule 115 (neurCteB -> .)
    AND             reduce using rule 115 (neurCteB -> .)
    OR              reduce using rule 115 (neurCteB -> .)
    ;               reduce using rule 115 (neurCteB -> .)
    )               reduce using rule 115 (neurCteB -> .)
    ,               reduce using rule 115 (neurCteB -> .)

    neurCteB                       shift and go to state 143

state 115

    (108) varcte -> CTEF . neurCteF
    (114) neurCteF -> .

    *               reduce using rule 114 (neurCteF -> .)
    /               reduce using rule 114 (neurCteF -> .)
    +               reduce using rule 114 (neurCteF -> .)
    -               reduce using rule 114 (neurCteF -> .)
    EQ              reduce using rule 114 (neurCteF -> .)
    NOTEQ           reduce using rule 114 (neurCteF -> .)
    >               reduce using rule 114 (neurCteF -> .)
    <               reduce using rule 114 (neurCteF -> .)
    MTHANEQ         reduce using rule 114 (neurCteF -> .)
    LTHANEQ         reduce using rule 114 (neurCteF -> .)
    AND             reduce using rule 114 (neurCteF -> .)
    OR              reduce using rule 114 (neurCteF -> .)
    ;               reduce using rule 114 (neurCteF -> .)
    )               reduce using rule 114 (neurCteF -> .)
    ,               reduce using rule 114 (neurCteF -> .)

    neurCteF                       shift and go to state 144

state 116

    (65) subexpresion -> exp . neur10 o
    (66) neur10 -> .

    AND             reduce using rule 66 (neur10 -> .)
    OR              reduce using rule 66 (neur10 -> .)
    ;               reduce using rule 66 (neur10 -> .)
    )               reduce using rule 66 (neur10 -> .)
    ,               reduce using rule 66 (neur10 -> .)

    neur10                         shift and go to state 145

state 117

    (107) varcte -> CTEE . neurCteE
    (113) neurCteE -> .

    *               reduce using rule 113 (neurCteE -> .)
    /               reduce using rule 113 (neurCteE -> .)
    +               reduce using rule 113 (neurCteE -> .)
    -               reduce using rule 113 (neurCteE -> .)
    EQ              reduce using rule 113 (neurCteE -> .)
    NOTEQ           reduce using rule 113 (neurCteE -> .)
    >               reduce using rule 113 (neurCteE -> .)
    <               reduce using rule 113 (neurCteE -> .)
    MTHANEQ         reduce using rule 113 (neurCteE -> .)
    LTHANEQ         reduce using rule 113 (neurCteE -> .)
    AND             reduce using rule 113 (neurCteE -> .)
    OR              reduce using rule 113 (neurCteE -> .)
    ;               reduce using rule 113 (neurCteE -> .)
    )               reduce using rule 113 (neurCteE -> .)
    ,               reduce using rule 113 (neurCteE -> .)

    neurCteE                       shift and go to state 146

state 118

    (141) callvoidfunc -> CALL ID neur24 . ( s ) neur26 ;

    (               shift and go to state 147


state 119

    (133) play -> PLAY ( NOTA . , CTEE ) ;

    ,               shift and go to state 148


state 120

    (57) for -> FOR ( asignacion . neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (58) neur18 -> .

    NOT             reduce using rule 58 (neur18 -> .)
    (               reduce using rule 58 (neur18 -> .)
    ID              reduce using rule 58 (neur18 -> .)
    CTEE            reduce using rule 58 (neur18 -> .)
    CTEF            reduce using rule 58 (neur18 -> .)
    CTEBOOL         reduce using rule 58 (neur18 -> .)
    CTECHAR         reduce using rule 58 (neur18 -> .)
    CALL            reduce using rule 58 (neur18 -> .)

    neur18                         shift and go to state 149

state 121

    (46) asignacion -> ID = neur8 . k ;
    (48) k -> . expresion
    (49) k -> . asiglista
    (62) expresion -> . m subexpresion
    (50) asiglista -> . NEW LIST ( )
    (63) m -> . empty
    (64) m -> . NOT
    (152) empty -> .

    NEW             shift and go to state 153
    NOT             shift and go to state 88
    (               reduce using rule 152 (empty -> .)
    ID              reduce using rule 152 (empty -> .)
    CTEE            reduce using rule 152 (empty -> .)
    CTEF            reduce using rule 152 (empty -> .)
    CTEBOOL         reduce using rule 152 (empty -> .)
    CTECHAR         reduce using rule 152 (empty -> .)
    CALL            reduce using rule 152 (empty -> .)

    expresion                      shift and go to state 150
    k                              shift and go to state 151
    m                              shift and go to state 87
    asiglista                      shift and go to state 152
    empty                          shift and go to state 89

state 122

    (51) if -> IF ( expresion . ) neur13 bloque l ;

    )               shift and go to state 154


state 123

    (144) return -> RETURN ( expresion ) . ;

    ;               shift and go to state 155


state 124

    (130) while -> WHILE ( neur16 expresion . ) neur13 bloque ; neur17

    )               shift and go to state 156


state 125

    (87) nexp -> termino neur5 . q
    (89) q -> . empty
    (90) q -> . + neur3_1 nexp
    (91) q -> . - neur3_2 nexp
    (152) empty -> .

    +               shift and go to state 157
    -               shift and go to state 158
    EQ              reduce using rule 152 (empty -> .)
    NOTEQ           reduce using rule 152 (empty -> .)
    >               reduce using rule 152 (empty -> .)
    <               reduce using rule 152 (empty -> .)
    MTHANEQ         reduce using rule 152 (empty -> .)
    LTHANEQ         reduce using rule 152 (empty -> .)
    AND             reduce using rule 152 (empty -> .)
    OR              reduce using rule 152 (empty -> .)
    ;               reduce using rule 152 (empty -> .)
    )               reduce using rule 152 (empty -> .)
    ,               reduce using rule 152 (empty -> .)

    q                              shift and go to state 159
    empty                          shift and go to state 160

state 126

    (111) varcte -> CTECHAR neurCteCh .

    *               reduce using rule 111 (varcte -> CTECHAR neurCteCh .)
    /               reduce using rule 111 (varcte -> CTECHAR neurCteCh .)
    +               reduce using rule 111 (varcte -> CTECHAR neurCteCh .)
    -               reduce using rule 111 (varcte -> CTECHAR neurCteCh .)
    AND             reduce using rule 111 (varcte -> CTECHAR neurCteCh .)
    OR              reduce using rule 111 (varcte -> CTECHAR neurCteCh .)
    ;               reduce using rule 111 (varcte -> CTECHAR neurCteCh .)
    )               reduce using rule 111 (varcte -> CTECHAR neurCteCh .)
    ,               reduce using rule 111 (varcte -> CTECHAR neurCteCh .)
    EQ              reduce using rule 111 (varcte -> CTECHAR neurCteCh .)
    NOTEQ           reduce using rule 111 (varcte -> CTECHAR neurCteCh .)
    >               reduce using rule 111 (varcte -> CTECHAR neurCteCh .)
    <               reduce using rule 111 (varcte -> CTECHAR neurCteCh .)
    MTHANEQ         reduce using rule 111 (varcte -> CTECHAR neurCteCh .)
    LTHANEQ         reduce using rule 111 (varcte -> CTECHAR neurCteCh .)


state 127

    (102) factor -> varcte neur1 .

    *               reduce using rule 102 (factor -> varcte neur1 .)
    /               reduce using rule 102 (factor -> varcte neur1 .)
    +               reduce using rule 102 (factor -> varcte neur1 .)
    -               reduce using rule 102 (factor -> varcte neur1 .)
    AND             reduce using rule 102 (factor -> varcte neur1 .)
    OR              reduce using rule 102 (factor -> varcte neur1 .)
    ;               reduce using rule 102 (factor -> varcte neur1 .)
    )               reduce using rule 102 (factor -> varcte neur1 .)
    ,               reduce using rule 102 (factor -> varcte neur1 .)
    EQ              reduce using rule 102 (factor -> varcte neur1 .)
    NOTEQ           reduce using rule 102 (factor -> varcte neur1 .)
    >               reduce using rule 102 (factor -> varcte neur1 .)
    <               reduce using rule 102 (factor -> varcte neur1 .)
    MTHANEQ         reduce using rule 102 (factor -> varcte neur1 .)
    LTHANEQ         reduce using rule 102 (factor -> varcte neur1 .)


state 128

    (101) factor -> ( neur6 . expresion ) neur7
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (152) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 152 (empty -> .)
    ID              reduce using rule 152 (empty -> .)
    CTEE            reduce using rule 152 (empty -> .)
    CTEF            reduce using rule 152 (empty -> .)
    CTEBOOL         reduce using rule 152 (empty -> .)
    CTECHAR         reduce using rule 152 (empty -> .)
    CALL            reduce using rule 152 (empty -> .)

    expresion                      shift and go to state 161
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 129

    (79) p -> MTHANEQ . neur11_5 nexp
    (85) neur11_5 -> .

    (               reduce using rule 85 (neur11_5 -> .)
    ID              reduce using rule 85 (neur11_5 -> .)
    CTEE            reduce using rule 85 (neur11_5 -> .)
    CTEF            reduce using rule 85 (neur11_5 -> .)
    CTEBOOL         reduce using rule 85 (neur11_5 -> .)
    CTECHAR         reduce using rule 85 (neur11_5 -> .)
    CALL            reduce using rule 85 (neur11_5 -> .)

    neur11_5                       shift and go to state 162

state 130

    (72) exp -> nexp p . neur12
    (73) neur12 -> .

    AND             reduce using rule 73 (neur12 -> .)
    OR              reduce using rule 73 (neur12 -> .)
    ;               reduce using rule 73 (neur12 -> .)
    )               reduce using rule 73 (neur12 -> .)
    ,               reduce using rule 73 (neur12 -> .)

    neur12                         shift and go to state 163

state 131

    (80) p -> LTHANEQ . neur11_6 nexp
    (86) neur11_6 -> .

    (               reduce using rule 86 (neur11_6 -> .)
    ID              reduce using rule 86 (neur11_6 -> .)
    CTEE            reduce using rule 86 (neur11_6 -> .)
    CTEF            reduce using rule 86 (neur11_6 -> .)
    CTEBOOL         reduce using rule 86 (neur11_6 -> .)
    CTECHAR         reduce using rule 86 (neur11_6 -> .)
    CALL            reduce using rule 86 (neur11_6 -> .)

    neur11_6                       shift and go to state 164

state 132

    (76) p -> NOTEQ . neur11_2 nexp
    (82) neur11_2 -> .

    (               reduce using rule 82 (neur11_2 -> .)
    ID              reduce using rule 82 (neur11_2 -> .)
    CTEE            reduce using rule 82 (neur11_2 -> .)
    CTEF            reduce using rule 82 (neur11_2 -> .)
    CTEBOOL         reduce using rule 82 (neur11_2 -> .)
    CTECHAR         reduce using rule 82 (neur11_2 -> .)
    CALL            reduce using rule 82 (neur11_2 -> .)

    neur11_2                       shift and go to state 165

state 133

    (75) p -> EQ . neur11_1 nexp
    (81) neur11_1 -> .

    (               reduce using rule 81 (neur11_1 -> .)
    ID              reduce using rule 81 (neur11_1 -> .)
    CTEE            reduce using rule 81 (neur11_1 -> .)
    CTEF            reduce using rule 81 (neur11_1 -> .)
    CTEBOOL         reduce using rule 81 (neur11_1 -> .)
    CTECHAR         reduce using rule 81 (neur11_1 -> .)
    CALL            reduce using rule 81 (neur11_1 -> .)

    neur11_1                       shift and go to state 166

state 134

    (78) p -> < . neur11_4 nexp
    (84) neur11_4 -> .

    (               reduce using rule 84 (neur11_4 -> .)
    ID              reduce using rule 84 (neur11_4 -> .)
    CTEE            reduce using rule 84 (neur11_4 -> .)
    CTEF            reduce using rule 84 (neur11_4 -> .)
    CTEBOOL         reduce using rule 84 (neur11_4 -> .)
    CTECHAR         reduce using rule 84 (neur11_4 -> .)
    CALL            reduce using rule 84 (neur11_4 -> .)

    neur11_4                       shift and go to state 167

state 135

    (74) p -> empty .

    AND             reduce using rule 74 (p -> empty .)
    OR              reduce using rule 74 (p -> empty .)
    ;               reduce using rule 74 (p -> empty .)
    )               reduce using rule 74 (p -> empty .)
    ,               reduce using rule 74 (p -> empty .)


state 136

    (77) p -> > . neur11_3 nexp
    (83) neur11_3 -> .

    (               reduce using rule 83 (neur11_3 -> .)
    ID              reduce using rule 83 (neur11_3 -> .)
    CTEE            reduce using rule 83 (neur11_3 -> .)
    CTEF            reduce using rule 83 (neur11_3 -> .)
    CTEBOOL         reduce using rule 83 (neur11_3 -> .)
    CTECHAR         reduce using rule 83 (neur11_3 -> .)
    CALL            reduce using rule 83 (neur11_3 -> .)

    neur11_3                       shift and go to state 168

state 137

    (94) termino -> factor neur4 . n
    (96) n -> . empty
    (97) n -> . * neur2_1 termino
    (98) n -> . / neur2_2 termino
    (152) empty -> .

    *               shift and go to state 169
    /               shift and go to state 170
    +               reduce using rule 152 (empty -> .)
    -               reduce using rule 152 (empty -> .)
    EQ              reduce using rule 152 (empty -> .)
    NOTEQ           reduce using rule 152 (empty -> .)
    >               reduce using rule 152 (empty -> .)
    <               reduce using rule 152 (empty -> .)
    MTHANEQ         reduce using rule 152 (empty -> .)
    LTHANEQ         reduce using rule 152 (empty -> .)
    AND             reduce using rule 152 (empty -> .)
    OR              reduce using rule 152 (empty -> .)
    ;               reduce using rule 152 (empty -> .)
    )               reduce using rule 152 (empty -> .)
    ,               reduce using rule 152 (empty -> .)

    n                              shift and go to state 171
    empty                          shift and go to state 172

state 138

    (135) callreturnfunc -> CALL ID . neur24 ( s ) neur26 ;
    (142) neur24 -> .

    (               reduce using rule 142 (neur24 -> .)

    neur24                         shift and go to state 173

state 139

    (118) r -> oplista .

    *               reduce using rule 118 (r -> oplista .)
    /               reduce using rule 118 (r -> oplista .)
    +               reduce using rule 118 (r -> oplista .)
    -               reduce using rule 118 (r -> oplista .)
    EQ              reduce using rule 118 (r -> oplista .)
    NOTEQ           reduce using rule 118 (r -> oplista .)
    >               reduce using rule 118 (r -> oplista .)
    <               reduce using rule 118 (r -> oplista .)
    MTHANEQ         reduce using rule 118 (r -> oplista .)
    LTHANEQ         reduce using rule 118 (r -> oplista .)
    AND             reduce using rule 118 (r -> oplista .)
    OR              reduce using rule 118 (r -> oplista .)
    ;               reduce using rule 118 (r -> oplista .)
    )               reduce using rule 118 (r -> oplista .)
    ,               reduce using rule 118 (r -> oplista .)


state 140

    (106) varcte -> ID r . neurVar
    (112) neurVar -> .

    *               reduce using rule 112 (neurVar -> .)
    /               reduce using rule 112 (neurVar -> .)
    +               reduce using rule 112 (neurVar -> .)
    -               reduce using rule 112 (neurVar -> .)
    EQ              reduce using rule 112 (neurVar -> .)
    NOTEQ           reduce using rule 112 (neurVar -> .)
    >               reduce using rule 112 (neurVar -> .)
    <               reduce using rule 112 (neurVar -> .)
    MTHANEQ         reduce using rule 112 (neurVar -> .)
    LTHANEQ         reduce using rule 112 (neurVar -> .)
    AND             reduce using rule 112 (neurVar -> .)
    OR              reduce using rule 112 (neurVar -> .)
    ;               reduce using rule 112 (neurVar -> .)
    )               reduce using rule 112 (neurVar -> .)
    ,               reduce using rule 112 (neurVar -> .)

    neurVar                        shift and go to state 174

state 141

    (119) oplista -> ID . . x

    .               shift and go to state 175


state 142

    (117) r -> empty .

    *               reduce using rule 117 (r -> empty .)
    /               reduce using rule 117 (r -> empty .)
    +               reduce using rule 117 (r -> empty .)
    -               reduce using rule 117 (r -> empty .)
    EQ              reduce using rule 117 (r -> empty .)
    NOTEQ           reduce using rule 117 (r -> empty .)
    >               reduce using rule 117 (r -> empty .)
    <               reduce using rule 117 (r -> empty .)
    MTHANEQ         reduce using rule 117 (r -> empty .)
    LTHANEQ         reduce using rule 117 (r -> empty .)
    AND             reduce using rule 117 (r -> empty .)
    OR              reduce using rule 117 (r -> empty .)
    ;               reduce using rule 117 (r -> empty .)
    )               reduce using rule 117 (r -> empty .)
    ,               reduce using rule 117 (r -> empty .)


state 143

    (109) varcte -> CTEBOOL neurCteB .

    *               reduce using rule 109 (varcte -> CTEBOOL neurCteB .)
    /               reduce using rule 109 (varcte -> CTEBOOL neurCteB .)
    +               reduce using rule 109 (varcte -> CTEBOOL neurCteB .)
    -               reduce using rule 109 (varcte -> CTEBOOL neurCteB .)
    AND             reduce using rule 109 (varcte -> CTEBOOL neurCteB .)
    OR              reduce using rule 109 (varcte -> CTEBOOL neurCteB .)
    ;               reduce using rule 109 (varcte -> CTEBOOL neurCteB .)
    )               reduce using rule 109 (varcte -> CTEBOOL neurCteB .)
    ,               reduce using rule 109 (varcte -> CTEBOOL neurCteB .)
    EQ              reduce using rule 109 (varcte -> CTEBOOL neurCteB .)
    NOTEQ           reduce using rule 109 (varcte -> CTEBOOL neurCteB .)
    >               reduce using rule 109 (varcte -> CTEBOOL neurCteB .)
    <               reduce using rule 109 (varcte -> CTEBOOL neurCteB .)
    MTHANEQ         reduce using rule 109 (varcte -> CTEBOOL neurCteB .)
    LTHANEQ         reduce using rule 109 (varcte -> CTEBOOL neurCteB .)


state 144

    (108) varcte -> CTEF neurCteF .

    *               reduce using rule 108 (varcte -> CTEF neurCteF .)
    /               reduce using rule 108 (varcte -> CTEF neurCteF .)
    +               reduce using rule 108 (varcte -> CTEF neurCteF .)
    -               reduce using rule 108 (varcte -> CTEF neurCteF .)
    AND             reduce using rule 108 (varcte -> CTEF neurCteF .)
    OR              reduce using rule 108 (varcte -> CTEF neurCteF .)
    ;               reduce using rule 108 (varcte -> CTEF neurCteF .)
    )               reduce using rule 108 (varcte -> CTEF neurCteF .)
    ,               reduce using rule 108 (varcte -> CTEF neurCteF .)
    EQ              reduce using rule 108 (varcte -> CTEF neurCteF .)
    NOTEQ           reduce using rule 108 (varcte -> CTEF neurCteF .)
    >               reduce using rule 108 (varcte -> CTEF neurCteF .)
    <               reduce using rule 108 (varcte -> CTEF neurCteF .)
    MTHANEQ         reduce using rule 108 (varcte -> CTEF neurCteF .)
    LTHANEQ         reduce using rule 108 (varcte -> CTEF neurCteF .)


state 145

    (65) subexpresion -> exp neur10 . o
    (67) o -> . empty
    (68) o -> . AND neur9_1 subexpresion
    (69) o -> . OR neur9_2 subexpresion
    (152) empty -> .

    AND             shift and go to state 176
    OR              shift and go to state 178
    ;               reduce using rule 152 (empty -> .)
    )               reduce using rule 152 (empty -> .)
    ,               reduce using rule 152 (empty -> .)

    o                              shift and go to state 177
    empty                          shift and go to state 179

state 146

    (107) varcte -> CTEE neurCteE .

    *               reduce using rule 107 (varcte -> CTEE neurCteE .)
    /               reduce using rule 107 (varcte -> CTEE neurCteE .)
    +               reduce using rule 107 (varcte -> CTEE neurCteE .)
    -               reduce using rule 107 (varcte -> CTEE neurCteE .)
    AND             reduce using rule 107 (varcte -> CTEE neurCteE .)
    OR              reduce using rule 107 (varcte -> CTEE neurCteE .)
    ;               reduce using rule 107 (varcte -> CTEE neurCteE .)
    )               reduce using rule 107 (varcte -> CTEE neurCteE .)
    ,               reduce using rule 107 (varcte -> CTEE neurCteE .)
    EQ              reduce using rule 107 (varcte -> CTEE neurCteE .)
    NOTEQ           reduce using rule 107 (varcte -> CTEE neurCteE .)
    >               reduce using rule 107 (varcte -> CTEE neurCteE .)
    <               reduce using rule 107 (varcte -> CTEE neurCteE .)
    MTHANEQ         reduce using rule 107 (varcte -> CTEE neurCteE .)
    LTHANEQ         reduce using rule 107 (varcte -> CTEE neurCteE .)


state 147

    (141) callvoidfunc -> CALL ID neur24 ( . s ) neur26 ;
    (136) s -> . empty
    (137) s -> . expresion neur25 t
    (152) empty -> .
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT

    )               reduce using rule 152 (empty -> .)
    (               reduce using rule 152 (empty -> .)
    ID              reduce using rule 152 (empty -> .)
    CTEE            reduce using rule 152 (empty -> .)
    CTEF            reduce using rule 152 (empty -> .)
    CTEBOOL         reduce using rule 152 (empty -> .)
    CTECHAR         reduce using rule 152 (empty -> .)
    CALL            reduce using rule 152 (empty -> .)
    NOT             shift and go to state 88

    expresion                      shift and go to state 180
    m                              shift and go to state 87
    s                              shift and go to state 181
    empty                          shift and go to state 182

state 148

    (133) play -> PLAY ( NOTA , . CTEE ) ;

    CTEE            shift and go to state 183


state 149

    (57) for -> FOR ( asignacion neur18 . expresion ; neur19 asignacion ) neur21 bloque ; neur20
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (152) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 152 (empty -> .)
    ID              reduce using rule 152 (empty -> .)
    CTEE            reduce using rule 152 (empty -> .)
    CTEF            reduce using rule 152 (empty -> .)
    CTEBOOL         reduce using rule 152 (empty -> .)
    CTECHAR         reduce using rule 152 (empty -> .)
    CALL            reduce using rule 152 (empty -> .)

    expresion                      shift and go to state 184
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 150

    (48) k -> expresion .

    ;               reduce using rule 48 (k -> expresion .)


state 151

    (46) asignacion -> ID = neur8 k . ;

    ;               shift and go to state 185


state 152

    (49) k -> asiglista .

    ;               reduce using rule 49 (k -> asiglista .)


state 153

    (50) asiglista -> NEW . LIST ( )

    LIST            shift and go to state 186


state 154

    (51) if -> IF ( expresion ) . neur13 bloque l ;
    (52) neur13 -> .

    {               reduce using rule 52 (neur13 -> .)

    neur13                         shift and go to state 187

state 155

    (144) return -> RETURN ( expresion ) ; .

    ID              reduce using rule 144 (return -> RETURN ( expresion ) ; .)
    IF              reduce using rule 144 (return -> RETURN ( expresion ) ; .)
    FOR             reduce using rule 144 (return -> RETURN ( expresion ) ; .)
    RETURN          reduce using rule 144 (return -> RETURN ( expresion ) ; .)
    WHILE           reduce using rule 144 (return -> RETURN ( expresion ) ; .)
    PLAY            reduce using rule 144 (return -> RETURN ( expresion ) ; .)
    PRINT           reduce using rule 144 (return -> RETURN ( expresion ) ; .)
    CALL            reduce using rule 144 (return -> RETURN ( expresion ) ; .)
    }               reduce using rule 144 (return -> RETURN ( expresion ) ; .)


state 156

    (130) while -> WHILE ( neur16 expresion ) . neur13 bloque ; neur17
    (52) neur13 -> .

    {               reduce using rule 52 (neur13 -> .)

    neur13                         shift and go to state 188

state 157

    (90) q -> + . neur3_1 nexp
    (92) neur3_1 -> .

    (               reduce using rule 92 (neur3_1 -> .)
    ID              reduce using rule 92 (neur3_1 -> .)
    CTEE            reduce using rule 92 (neur3_1 -> .)
    CTEF            reduce using rule 92 (neur3_1 -> .)
    CTEBOOL         reduce using rule 92 (neur3_1 -> .)
    CTECHAR         reduce using rule 92 (neur3_1 -> .)
    CALL            reduce using rule 92 (neur3_1 -> .)

    neur3_1                        shift and go to state 189

state 158

    (91) q -> - . neur3_2 nexp
    (93) neur3_2 -> .

    (               reduce using rule 93 (neur3_2 -> .)
    ID              reduce using rule 93 (neur3_2 -> .)
    CTEE            reduce using rule 93 (neur3_2 -> .)
    CTEF            reduce using rule 93 (neur3_2 -> .)
    CTEBOOL         reduce using rule 93 (neur3_2 -> .)
    CTECHAR         reduce using rule 93 (neur3_2 -> .)
    CALL            reduce using rule 93 (neur3_2 -> .)

    neur3_2                        shift and go to state 190

state 159

    (87) nexp -> termino neur5 q .

    AND             reduce using rule 87 (nexp -> termino neur5 q .)
    OR              reduce using rule 87 (nexp -> termino neur5 q .)
    ;               reduce using rule 87 (nexp -> termino neur5 q .)
    )               reduce using rule 87 (nexp -> termino neur5 q .)
    ,               reduce using rule 87 (nexp -> termino neur5 q .)
    EQ              reduce using rule 87 (nexp -> termino neur5 q .)
    NOTEQ           reduce using rule 87 (nexp -> termino neur5 q .)
    >               reduce using rule 87 (nexp -> termino neur5 q .)
    <               reduce using rule 87 (nexp -> termino neur5 q .)
    MTHANEQ         reduce using rule 87 (nexp -> termino neur5 q .)
    LTHANEQ         reduce using rule 87 (nexp -> termino neur5 q .)


state 160

    (89) q -> empty .

    EQ              reduce using rule 89 (q -> empty .)
    NOTEQ           reduce using rule 89 (q -> empty .)
    >               reduce using rule 89 (q -> empty .)
    <               reduce using rule 89 (q -> empty .)
    MTHANEQ         reduce using rule 89 (q -> empty .)
    LTHANEQ         reduce using rule 89 (q -> empty .)
    AND             reduce using rule 89 (q -> empty .)
    OR              reduce using rule 89 (q -> empty .)
    ;               reduce using rule 89 (q -> empty .)
    )               reduce using rule 89 (q -> empty .)
    ,               reduce using rule 89 (q -> empty .)


state 161

    (101) factor -> ( neur6 expresion . ) neur7

    )               shift and go to state 191


state 162

    (79) p -> MTHANEQ neur11_5 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte neur1
    (106) varcte -> . ID r neurVar
    (107) varcte -> . CTEE neurCteE
    (108) varcte -> . CTEF neurCteF
    (109) varcte -> . CTEBOOL neurCteB
    (110) varcte -> . callreturnfunc
    (111) varcte -> . CTECHAR neurCteCh
    (135) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 192
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 163

    (72) exp -> nexp p neur12 .

    AND             reduce using rule 72 (exp -> nexp p neur12 .)
    OR              reduce using rule 72 (exp -> nexp p neur12 .)
    ;               reduce using rule 72 (exp -> nexp p neur12 .)
    )               reduce using rule 72 (exp -> nexp p neur12 .)
    ,               reduce using rule 72 (exp -> nexp p neur12 .)


state 164

    (80) p -> LTHANEQ neur11_6 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte neur1
    (106) varcte -> . ID r neurVar
    (107) varcte -> . CTEE neurCteE
    (108) varcte -> . CTEF neurCteF
    (109) varcte -> . CTEBOOL neurCteB
    (110) varcte -> . callreturnfunc
    (111) varcte -> . CTECHAR neurCteCh
    (135) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 193
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 165

    (76) p -> NOTEQ neur11_2 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte neur1
    (106) varcte -> . ID r neurVar
    (107) varcte -> . CTEE neurCteE
    (108) varcte -> . CTEF neurCteF
    (109) varcte -> . CTEBOOL neurCteB
    (110) varcte -> . callreturnfunc
    (111) varcte -> . CTECHAR neurCteCh
    (135) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 194
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 166

    (75) p -> EQ neur11_1 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte neur1
    (106) varcte -> . ID r neurVar
    (107) varcte -> . CTEE neurCteE
    (108) varcte -> . CTEF neurCteF
    (109) varcte -> . CTEBOOL neurCteB
    (110) varcte -> . callreturnfunc
    (111) varcte -> . CTECHAR neurCteCh
    (135) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 195
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 167

    (78) p -> < neur11_4 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte neur1
    (106) varcte -> . ID r neurVar
    (107) varcte -> . CTEE neurCteE
    (108) varcte -> . CTEF neurCteF
    (109) varcte -> . CTEBOOL neurCteB
    (110) varcte -> . callreturnfunc
    (111) varcte -> . CTECHAR neurCteCh
    (135) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 196
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 168

    (77) p -> > neur11_3 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte neur1
    (106) varcte -> . ID r neurVar
    (107) varcte -> . CTEE neurCteE
    (108) varcte -> . CTEF neurCteF
    (109) varcte -> . CTEBOOL neurCteB
    (110) varcte -> . callreturnfunc
    (111) varcte -> . CTECHAR neurCteCh
    (135) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 197
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 169

    (97) n -> * . neur2_1 termino
    (99) neur2_1 -> .

    (               reduce using rule 99 (neur2_1 -> .)
    ID              reduce using rule 99 (neur2_1 -> .)
    CTEE            reduce using rule 99 (neur2_1 -> .)
    CTEF            reduce using rule 99 (neur2_1 -> .)
    CTEBOOL         reduce using rule 99 (neur2_1 -> .)
    CTECHAR         reduce using rule 99 (neur2_1 -> .)
    CALL            reduce using rule 99 (neur2_1 -> .)

    neur2_1                        shift and go to state 198

state 170

    (98) n -> / . neur2_2 termino
    (100) neur2_2 -> .

    (               reduce using rule 100 (neur2_2 -> .)
    ID              reduce using rule 100 (neur2_2 -> .)
    CTEE            reduce using rule 100 (neur2_2 -> .)
    CTEF            reduce using rule 100 (neur2_2 -> .)
    CTEBOOL         reduce using rule 100 (neur2_2 -> .)
    CTECHAR         reduce using rule 100 (neur2_2 -> .)
    CALL            reduce using rule 100 (neur2_2 -> .)

    neur2_2                        shift and go to state 199

state 171

    (94) termino -> factor neur4 n .

    +               reduce using rule 94 (termino -> factor neur4 n .)
    -               reduce using rule 94 (termino -> factor neur4 n .)
    AND             reduce using rule 94 (termino -> factor neur4 n .)
    OR              reduce using rule 94 (termino -> factor neur4 n .)
    ;               reduce using rule 94 (termino -> factor neur4 n .)
    )               reduce using rule 94 (termino -> factor neur4 n .)
    ,               reduce using rule 94 (termino -> factor neur4 n .)
    EQ              reduce using rule 94 (termino -> factor neur4 n .)
    NOTEQ           reduce using rule 94 (termino -> factor neur4 n .)
    >               reduce using rule 94 (termino -> factor neur4 n .)
    <               reduce using rule 94 (termino -> factor neur4 n .)
    MTHANEQ         reduce using rule 94 (termino -> factor neur4 n .)
    LTHANEQ         reduce using rule 94 (termino -> factor neur4 n .)


state 172

    (96) n -> empty .

    +               reduce using rule 96 (n -> empty .)
    -               reduce using rule 96 (n -> empty .)
    EQ              reduce using rule 96 (n -> empty .)
    NOTEQ           reduce using rule 96 (n -> empty .)
    >               reduce using rule 96 (n -> empty .)
    <               reduce using rule 96 (n -> empty .)
    MTHANEQ         reduce using rule 96 (n -> empty .)
    LTHANEQ         reduce using rule 96 (n -> empty .)
    AND             reduce using rule 96 (n -> empty .)
    OR              reduce using rule 96 (n -> empty .)
    ;               reduce using rule 96 (n -> empty .)
    )               reduce using rule 96 (n -> empty .)
    ,               reduce using rule 96 (n -> empty .)


state 173

    (135) callreturnfunc -> CALL ID neur24 . ( s ) neur26 ;

    (               shift and go to state 200


state 174

    (106) varcte -> ID r neurVar .

    *               reduce using rule 106 (varcte -> ID r neurVar .)
    /               reduce using rule 106 (varcte -> ID r neurVar .)
    +               reduce using rule 106 (varcte -> ID r neurVar .)
    -               reduce using rule 106 (varcte -> ID r neurVar .)
    AND             reduce using rule 106 (varcte -> ID r neurVar .)
    OR              reduce using rule 106 (varcte -> ID r neurVar .)
    ;               reduce using rule 106 (varcte -> ID r neurVar .)
    )               reduce using rule 106 (varcte -> ID r neurVar .)
    ,               reduce using rule 106 (varcte -> ID r neurVar .)
    EQ              reduce using rule 106 (varcte -> ID r neurVar .)
    NOTEQ           reduce using rule 106 (varcte -> ID r neurVar .)
    >               reduce using rule 106 (varcte -> ID r neurVar .)
    <               reduce using rule 106 (varcte -> ID r neurVar .)
    MTHANEQ         reduce using rule 106 (varcte -> ID r neurVar .)
    LTHANEQ         reduce using rule 106 (varcte -> ID r neurVar .)


state 175

    (119) oplista -> ID . . x
    (120) x -> . inlistset
    (121) x -> . append
    (122) x -> . length
    (123) x -> . getlist
    (124) x -> . removelist
    (125) inlistset -> . SET ( CTEE , expresion )
    (126) append -> . APPEND ( expresion )
    (127) length -> . LENGTH ( )
    (128) getlist -> . GET ( expresion )
    (129) removelist -> . REMOVE ( expresion )

    SET             shift and go to state 201
    APPEND          shift and go to state 208
    LENGTH          shift and go to state 206
    GET             shift and go to state 203
    REMOVE          shift and go to state 205

    inlistset                      shift and go to state 202
    getlist                        shift and go to state 204
    length                         shift and go to state 207
    x                              shift and go to state 209
    removelist                     shift and go to state 210
    append                         shift and go to state 211

state 176

    (68) o -> AND . neur9_1 subexpresion
    (70) neur9_1 -> .

    (               reduce using rule 70 (neur9_1 -> .)
    ID              reduce using rule 70 (neur9_1 -> .)
    CTEE            reduce using rule 70 (neur9_1 -> .)
    CTEF            reduce using rule 70 (neur9_1 -> .)
    CTEBOOL         reduce using rule 70 (neur9_1 -> .)
    CTECHAR         reduce using rule 70 (neur9_1 -> .)
    CALL            reduce using rule 70 (neur9_1 -> .)

    neur9_1                        shift and go to state 212

state 177

    (65) subexpresion -> exp neur10 o .

    ;               reduce using rule 65 (subexpresion -> exp neur10 o .)
    )               reduce using rule 65 (subexpresion -> exp neur10 o .)
    ,               reduce using rule 65 (subexpresion -> exp neur10 o .)


state 178

    (69) o -> OR . neur9_2 subexpresion
    (71) neur9_2 -> .

    (               reduce using rule 71 (neur9_2 -> .)
    ID              reduce using rule 71 (neur9_2 -> .)
    CTEE            reduce using rule 71 (neur9_2 -> .)
    CTEF            reduce using rule 71 (neur9_2 -> .)
    CTEBOOL         reduce using rule 71 (neur9_2 -> .)
    CTECHAR         reduce using rule 71 (neur9_2 -> .)
    CALL            reduce using rule 71 (neur9_2 -> .)

    neur9_2                        shift and go to state 213

state 179

    (67) o -> empty .

    ;               reduce using rule 67 (o -> empty .)
    )               reduce using rule 67 (o -> empty .)
    ,               reduce using rule 67 (o -> empty .)


state 180

    (137) s -> expresion . neur25 t
    (138) neur25 -> .

    ,               reduce using rule 138 (neur25 -> .)
    )               reduce using rule 138 (neur25 -> .)

    neur25                         shift and go to state 214

state 181

    (141) callvoidfunc -> CALL ID neur24 ( s . ) neur26 ;

    )               shift and go to state 215


state 182

    (136) s -> empty .
    (63) m -> empty .

    )               reduce using rule 136 (s -> empty .)
    (               reduce using rule 63 (m -> empty .)
    ID              reduce using rule 63 (m -> empty .)
    CTEE            reduce using rule 63 (m -> empty .)
    CTEF            reduce using rule 63 (m -> empty .)
    CTEBOOL         reduce using rule 63 (m -> empty .)
    CTECHAR         reduce using rule 63 (m -> empty .)
    CALL            reduce using rule 63 (m -> empty .)


state 183

    (133) play -> PLAY ( NOTA , CTEE . ) ;

    )               shift and go to state 216


state 184

    (57) for -> FOR ( asignacion neur18 expresion . ; neur19 asignacion ) neur21 bloque ; neur20

    ;               shift and go to state 217


state 185

    (46) asignacion -> ID = neur8 k ; .

    NOT             reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    (               reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    ID              reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    CTEE            reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    CTEF            reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    CTEBOOL         reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    CTECHAR         reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    CALL            reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    IF              reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    FOR             reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    RETURN          reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    WHILE           reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    PLAY            reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    PRINT           reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    }               reduce using rule 46 (asignacion -> ID = neur8 k ; .)
    )               reduce using rule 46 (asignacion -> ID = neur8 k ; .)


state 186

    (50) asiglista -> NEW LIST . ( )

    (               shift and go to state 218


state 187

    (51) if -> IF ( expresion ) neur13 . bloque l ;
    (35) bloque -> . { i }

    {               shift and go to state 57

    bloque                         shift and go to state 219

state 188

    (130) while -> WHILE ( neur16 expresion ) neur13 . bloque ; neur17
    (35) bloque -> . { i }

    {               shift and go to state 57

    bloque                         shift and go to state 220

state 189

    (90) q -> + neur3_1 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte neur1
    (106) varcte -> . ID r neurVar
    (107) varcte -> . CTEE neurCteE
    (108) varcte -> . CTEF neurCteF
    (109) varcte -> . CTEBOOL neurCteB
    (110) varcte -> . callreturnfunc
    (111) varcte -> . CTECHAR neurCteCh
    (135) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 221
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 190

    (91) q -> - neur3_2 . nexp
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte neur1
    (106) varcte -> . ID r neurVar
    (107) varcte -> . CTEE neurCteE
    (108) varcte -> . CTEF neurCteF
    (109) varcte -> . CTEBOOL neurCteB
    (110) varcte -> . callreturnfunc
    (111) varcte -> . CTECHAR neurCteCh
    (135) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 222
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110

state 191

    (101) factor -> ( neur6 expresion ) . neur7
    (104) neur7 -> .

    *               reduce using rule 104 (neur7 -> .)
    /               reduce using rule 104 (neur7 -> .)
    +               reduce using rule 104 (neur7 -> .)
    -               reduce using rule 104 (neur7 -> .)
    EQ              reduce using rule 104 (neur7 -> .)
    NOTEQ           reduce using rule 104 (neur7 -> .)
    >               reduce using rule 104 (neur7 -> .)
    <               reduce using rule 104 (neur7 -> .)
    MTHANEQ         reduce using rule 104 (neur7 -> .)
    LTHANEQ         reduce using rule 104 (neur7 -> .)
    AND             reduce using rule 104 (neur7 -> .)
    OR              reduce using rule 104 (neur7 -> .)
    ;               reduce using rule 104 (neur7 -> .)
    )               reduce using rule 104 (neur7 -> .)
    ,               reduce using rule 104 (neur7 -> .)

    neur7                          shift and go to state 223

state 192

    (79) p -> MTHANEQ neur11_5 nexp .

    AND             reduce using rule 79 (p -> MTHANEQ neur11_5 nexp .)
    OR              reduce using rule 79 (p -> MTHANEQ neur11_5 nexp .)
    ;               reduce using rule 79 (p -> MTHANEQ neur11_5 nexp .)
    )               reduce using rule 79 (p -> MTHANEQ neur11_5 nexp .)
    ,               reduce using rule 79 (p -> MTHANEQ neur11_5 nexp .)


state 193

    (80) p -> LTHANEQ neur11_6 nexp .

    AND             reduce using rule 80 (p -> LTHANEQ neur11_6 nexp .)
    OR              reduce using rule 80 (p -> LTHANEQ neur11_6 nexp .)
    ;               reduce using rule 80 (p -> LTHANEQ neur11_6 nexp .)
    )               reduce using rule 80 (p -> LTHANEQ neur11_6 nexp .)
    ,               reduce using rule 80 (p -> LTHANEQ neur11_6 nexp .)


state 194

    (76) p -> NOTEQ neur11_2 nexp .

    AND             reduce using rule 76 (p -> NOTEQ neur11_2 nexp .)
    OR              reduce using rule 76 (p -> NOTEQ neur11_2 nexp .)
    ;               reduce using rule 76 (p -> NOTEQ neur11_2 nexp .)
    )               reduce using rule 76 (p -> NOTEQ neur11_2 nexp .)
    ,               reduce using rule 76 (p -> NOTEQ neur11_2 nexp .)


state 195

    (75) p -> EQ neur11_1 nexp .

    AND             reduce using rule 75 (p -> EQ neur11_1 nexp .)
    OR              reduce using rule 75 (p -> EQ neur11_1 nexp .)
    ;               reduce using rule 75 (p -> EQ neur11_1 nexp .)
    )               reduce using rule 75 (p -> EQ neur11_1 nexp .)
    ,               reduce using rule 75 (p -> EQ neur11_1 nexp .)


state 196

    (78) p -> < neur11_4 nexp .

    AND             reduce using rule 78 (p -> < neur11_4 nexp .)
    OR              reduce using rule 78 (p -> < neur11_4 nexp .)
    ;               reduce using rule 78 (p -> < neur11_4 nexp .)
    )               reduce using rule 78 (p -> < neur11_4 nexp .)
    ,               reduce using rule 78 (p -> < neur11_4 nexp .)


state 197

    (77) p -> > neur11_3 nexp .

    AND             reduce using rule 77 (p -> > neur11_3 nexp .)
    OR              reduce using rule 77 (p -> > neur11_3 nexp .)
    ;               reduce using rule 77 (p -> > neur11_3 nexp .)
    )               reduce using rule 77 (p -> > neur11_3 nexp .)
    ,               reduce using rule 77 (p -> > neur11_3 nexp .)


state 198

    (97) n -> * neur2_1 . termino
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte neur1
    (106) varcte -> . ID r neurVar
    (107) varcte -> . CTEE neurCteE
    (108) varcte -> . CTEF neurCteF
    (109) varcte -> . CTEBOOL neurCteB
    (110) varcte -> . callreturnfunc
    (111) varcte -> . CTECHAR neurCteCh
    (135) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    varcte                         shift and go to state 106
    callreturnfunc                 shift and go to state 109
    termino                        shift and go to state 224
    factor                         shift and go to state 110

state 199

    (98) n -> / neur2_2 . termino
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte neur1
    (106) varcte -> . ID r neurVar
    (107) varcte -> . CTEE neurCteE
    (108) varcte -> . CTEF neurCteF
    (109) varcte -> . CTEBOOL neurCteB
    (110) varcte -> . callreturnfunc
    (111) varcte -> . CTECHAR neurCteCh
    (135) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    varcte                         shift and go to state 106
    callreturnfunc                 shift and go to state 109
    termino                        shift and go to state 225
    factor                         shift and go to state 110

state 200

    (135) callreturnfunc -> CALL ID neur24 ( . s ) neur26 ;
    (136) s -> . empty
    (137) s -> . expresion neur25 t
    (152) empty -> .
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT

    )               reduce using rule 152 (empty -> .)
    (               reduce using rule 152 (empty -> .)
    ID              reduce using rule 152 (empty -> .)
    CTEE            reduce using rule 152 (empty -> .)
    CTEF            reduce using rule 152 (empty -> .)
    CTEBOOL         reduce using rule 152 (empty -> .)
    CTECHAR         reduce using rule 152 (empty -> .)
    CALL            reduce using rule 152 (empty -> .)
    NOT             shift and go to state 88

    expresion                      shift and go to state 180
    m                              shift and go to state 87
    s                              shift and go to state 226
    empty                          shift and go to state 182

state 201

    (125) inlistset -> SET . ( CTEE , expresion )

    (               shift and go to state 227


state 202

    (120) x -> inlistset .

    *               reduce using rule 120 (x -> inlistset .)
    /               reduce using rule 120 (x -> inlistset .)
    +               reduce using rule 120 (x -> inlistset .)
    -               reduce using rule 120 (x -> inlistset .)
    EQ              reduce using rule 120 (x -> inlistset .)
    NOTEQ           reduce using rule 120 (x -> inlistset .)
    >               reduce using rule 120 (x -> inlistset .)
    <               reduce using rule 120 (x -> inlistset .)
    MTHANEQ         reduce using rule 120 (x -> inlistset .)
    LTHANEQ         reduce using rule 120 (x -> inlistset .)
    AND             reduce using rule 120 (x -> inlistset .)
    OR              reduce using rule 120 (x -> inlistset .)
    ;               reduce using rule 120 (x -> inlistset .)
    )               reduce using rule 120 (x -> inlistset .)
    ,               reduce using rule 120 (x -> inlistset .)


state 203

    (128) getlist -> GET . ( expresion )

    (               shift and go to state 228


state 204

    (123) x -> getlist .

    *               reduce using rule 123 (x -> getlist .)
    /               reduce using rule 123 (x -> getlist .)
    +               reduce using rule 123 (x -> getlist .)
    -               reduce using rule 123 (x -> getlist .)
    EQ              reduce using rule 123 (x -> getlist .)
    NOTEQ           reduce using rule 123 (x -> getlist .)
    >               reduce using rule 123 (x -> getlist .)
    <               reduce using rule 123 (x -> getlist .)
    MTHANEQ         reduce using rule 123 (x -> getlist .)
    LTHANEQ         reduce using rule 123 (x -> getlist .)
    AND             reduce using rule 123 (x -> getlist .)
    OR              reduce using rule 123 (x -> getlist .)
    ;               reduce using rule 123 (x -> getlist .)
    )               reduce using rule 123 (x -> getlist .)
    ,               reduce using rule 123 (x -> getlist .)


state 205

    (129) removelist -> REMOVE . ( expresion )

    (               shift and go to state 229


state 206

    (127) length -> LENGTH . ( )

    (               shift and go to state 230


state 207

    (122) x -> length .

    *               reduce using rule 122 (x -> length .)
    /               reduce using rule 122 (x -> length .)
    +               reduce using rule 122 (x -> length .)
    -               reduce using rule 122 (x -> length .)
    EQ              reduce using rule 122 (x -> length .)
    NOTEQ           reduce using rule 122 (x -> length .)
    >               reduce using rule 122 (x -> length .)
    <               reduce using rule 122 (x -> length .)
    MTHANEQ         reduce using rule 122 (x -> length .)
    LTHANEQ         reduce using rule 122 (x -> length .)
    AND             reduce using rule 122 (x -> length .)
    OR              reduce using rule 122 (x -> length .)
    ;               reduce using rule 122 (x -> length .)
    )               reduce using rule 122 (x -> length .)
    ,               reduce using rule 122 (x -> length .)


state 208

    (126) append -> APPEND . ( expresion )

    (               shift and go to state 231


state 209

    (119) oplista -> ID . x .

    *               reduce using rule 119 (oplista -> ID . x .)
    /               reduce using rule 119 (oplista -> ID . x .)
    +               reduce using rule 119 (oplista -> ID . x .)
    -               reduce using rule 119 (oplista -> ID . x .)
    EQ              reduce using rule 119 (oplista -> ID . x .)
    NOTEQ           reduce using rule 119 (oplista -> ID . x .)
    >               reduce using rule 119 (oplista -> ID . x .)
    <               reduce using rule 119 (oplista -> ID . x .)
    MTHANEQ         reduce using rule 119 (oplista -> ID . x .)
    LTHANEQ         reduce using rule 119 (oplista -> ID . x .)
    AND             reduce using rule 119 (oplista -> ID . x .)
    OR              reduce using rule 119 (oplista -> ID . x .)
    ;               reduce using rule 119 (oplista -> ID . x .)
    )               reduce using rule 119 (oplista -> ID . x .)
    ,               reduce using rule 119 (oplista -> ID . x .)


state 210

    (124) x -> removelist .

    *               reduce using rule 124 (x -> removelist .)
    /               reduce using rule 124 (x -> removelist .)
    +               reduce using rule 124 (x -> removelist .)
    -               reduce using rule 124 (x -> removelist .)
    EQ              reduce using rule 124 (x -> removelist .)
    NOTEQ           reduce using rule 124 (x -> removelist .)
    >               reduce using rule 124 (x -> removelist .)
    <               reduce using rule 124 (x -> removelist .)
    MTHANEQ         reduce using rule 124 (x -> removelist .)
    LTHANEQ         reduce using rule 124 (x -> removelist .)
    AND             reduce using rule 124 (x -> removelist .)
    OR              reduce using rule 124 (x -> removelist .)
    ;               reduce using rule 124 (x -> removelist .)
    )               reduce using rule 124 (x -> removelist .)
    ,               reduce using rule 124 (x -> removelist .)


state 211

    (121) x -> append .

    *               reduce using rule 121 (x -> append .)
    /               reduce using rule 121 (x -> append .)
    +               reduce using rule 121 (x -> append .)
    -               reduce using rule 121 (x -> append .)
    EQ              reduce using rule 121 (x -> append .)
    NOTEQ           reduce using rule 121 (x -> append .)
    >               reduce using rule 121 (x -> append .)
    <               reduce using rule 121 (x -> append .)
    MTHANEQ         reduce using rule 121 (x -> append .)
    LTHANEQ         reduce using rule 121 (x -> append .)
    AND             reduce using rule 121 (x -> append .)
    OR              reduce using rule 121 (x -> append .)
    ;               reduce using rule 121 (x -> append .)
    )               reduce using rule 121 (x -> append .)
    ,               reduce using rule 121 (x -> append .)


state 212

    (68) o -> AND neur9_1 . subexpresion
    (65) subexpresion -> . exp neur10 o
    (72) exp -> . nexp p neur12
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte neur1
    (106) varcte -> . ID r neurVar
    (107) varcte -> . CTEE neurCteE
    (108) varcte -> . CTEF neurCteF
    (109) varcte -> . CTEBOOL neurCteB
    (110) varcte -> . callreturnfunc
    (111) varcte -> . CTECHAR neurCteCh
    (135) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 108
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110
    subexpresion                   shift and go to state 232
    exp                            shift and go to state 116

state 213

    (69) o -> OR neur9_2 . subexpresion
    (65) subexpresion -> . exp neur10 o
    (72) exp -> . nexp p neur12
    (87) nexp -> . termino neur5 q
    (94) termino -> . factor neur4 n
    (101) factor -> . ( neur6 expresion ) neur7
    (102) factor -> . varcte neur1
    (106) varcte -> . ID r neurVar
    (107) varcte -> . CTEE neurCteE
    (108) varcte -> . CTEF neurCteF
    (109) varcte -> . CTEBOOL neurCteB
    (110) varcte -> . callreturnfunc
    (111) varcte -> . CTECHAR neurCteCh
    (135) callreturnfunc -> . CALL ID neur24 ( s ) neur26 ;

    (               shift and go to state 107
    ID              shift and go to state 113
    CTEE            shift and go to state 117
    CTEF            shift and go to state 115
    CTEBOOL         shift and go to state 114
    CTECHAR         shift and go to state 105
    CALL            shift and go to state 111

    termino                        shift and go to state 104
    varcte                         shift and go to state 106
    nexp                           shift and go to state 108
    callreturnfunc                 shift and go to state 109
    factor                         shift and go to state 110
    subexpresion                   shift and go to state 233
    exp                            shift and go to state 116

state 214

    (137) s -> expresion neur25 . t
    (139) t -> . empty
    (140) t -> . , s
    (152) empty -> .

    ,               shift and go to state 234
    )               reduce using rule 152 (empty -> .)

    t                              shift and go to state 235
    empty                          shift and go to state 236

state 215

    (141) callvoidfunc -> CALL ID neur24 ( s ) . neur26 ;
    (143) neur26 -> .

    ;               reduce using rule 143 (neur26 -> .)

    neur26                         shift and go to state 237

state 216

    (133) play -> PLAY ( NOTA , CTEE ) . ;

    ;               shift and go to state 238


state 217

    (57) for -> FOR ( asignacion neur18 expresion ; . neur19 asignacion ) neur21 bloque ; neur20
    (59) neur19 -> .

    ID              reduce using rule 59 (neur19 -> .)

    neur19                         shift and go to state 239

state 218

    (50) asiglista -> NEW LIST ( . )

    )               shift and go to state 240


state 219

    (51) if -> IF ( expresion ) neur13 bloque . l ;
    (53) l -> . empty neur15
    (54) l -> . ELSE neur14 bloque
    (152) empty -> .

    ELSE            shift and go to state 242
    ;               reduce using rule 152 (empty -> .)

    l                              shift and go to state 241
    empty                          shift and go to state 243

state 220

    (130) while -> WHILE ( neur16 expresion ) neur13 bloque . ; neur17

    ;               shift and go to state 244


state 221

    (90) q -> + neur3_1 nexp .

    EQ              reduce using rule 90 (q -> + neur3_1 nexp .)
    NOTEQ           reduce using rule 90 (q -> + neur3_1 nexp .)
    >               reduce using rule 90 (q -> + neur3_1 nexp .)
    <               reduce using rule 90 (q -> + neur3_1 nexp .)
    MTHANEQ         reduce using rule 90 (q -> + neur3_1 nexp .)
    LTHANEQ         reduce using rule 90 (q -> + neur3_1 nexp .)
    AND             reduce using rule 90 (q -> + neur3_1 nexp .)
    OR              reduce using rule 90 (q -> + neur3_1 nexp .)
    ;               reduce using rule 90 (q -> + neur3_1 nexp .)
    )               reduce using rule 90 (q -> + neur3_1 nexp .)
    ,               reduce using rule 90 (q -> + neur3_1 nexp .)


state 222

    (91) q -> - neur3_2 nexp .

    EQ              reduce using rule 91 (q -> - neur3_2 nexp .)
    NOTEQ           reduce using rule 91 (q -> - neur3_2 nexp .)
    >               reduce using rule 91 (q -> - neur3_2 nexp .)
    <               reduce using rule 91 (q -> - neur3_2 nexp .)
    MTHANEQ         reduce using rule 91 (q -> - neur3_2 nexp .)
    LTHANEQ         reduce using rule 91 (q -> - neur3_2 nexp .)
    AND             reduce using rule 91 (q -> - neur3_2 nexp .)
    OR              reduce using rule 91 (q -> - neur3_2 nexp .)
    ;               reduce using rule 91 (q -> - neur3_2 nexp .)
    )               reduce using rule 91 (q -> - neur3_2 nexp .)
    ,               reduce using rule 91 (q -> - neur3_2 nexp .)


state 223

    (101) factor -> ( neur6 expresion ) neur7 .

    *               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    /               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    +               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    -               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    AND             reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    OR              reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    ;               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    )               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    ,               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    EQ              reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    NOTEQ           reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    >               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    <               reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    MTHANEQ         reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)
    LTHANEQ         reduce using rule 101 (factor -> ( neur6 expresion ) neur7 .)


state 224

    (97) n -> * neur2_1 termino .

    +               reduce using rule 97 (n -> * neur2_1 termino .)
    -               reduce using rule 97 (n -> * neur2_1 termino .)
    EQ              reduce using rule 97 (n -> * neur2_1 termino .)
    NOTEQ           reduce using rule 97 (n -> * neur2_1 termino .)
    >               reduce using rule 97 (n -> * neur2_1 termino .)
    <               reduce using rule 97 (n -> * neur2_1 termino .)
    MTHANEQ         reduce using rule 97 (n -> * neur2_1 termino .)
    LTHANEQ         reduce using rule 97 (n -> * neur2_1 termino .)
    AND             reduce using rule 97 (n -> * neur2_1 termino .)
    OR              reduce using rule 97 (n -> * neur2_1 termino .)
    ;               reduce using rule 97 (n -> * neur2_1 termino .)
    )               reduce using rule 97 (n -> * neur2_1 termino .)
    ,               reduce using rule 97 (n -> * neur2_1 termino .)


state 225

    (98) n -> / neur2_2 termino .

    +               reduce using rule 98 (n -> / neur2_2 termino .)
    -               reduce using rule 98 (n -> / neur2_2 termino .)
    EQ              reduce using rule 98 (n -> / neur2_2 termino .)
    NOTEQ           reduce using rule 98 (n -> / neur2_2 termino .)
    >               reduce using rule 98 (n -> / neur2_2 termino .)
    <               reduce using rule 98 (n -> / neur2_2 termino .)
    MTHANEQ         reduce using rule 98 (n -> / neur2_2 termino .)
    LTHANEQ         reduce using rule 98 (n -> / neur2_2 termino .)
    AND             reduce using rule 98 (n -> / neur2_2 termino .)
    OR              reduce using rule 98 (n -> / neur2_2 termino .)
    ;               reduce using rule 98 (n -> / neur2_2 termino .)
    )               reduce using rule 98 (n -> / neur2_2 termino .)
    ,               reduce using rule 98 (n -> / neur2_2 termino .)


state 226

    (135) callreturnfunc -> CALL ID neur24 ( s . ) neur26 ;

    )               shift and go to state 245


state 227

    (125) inlistset -> SET ( . CTEE , expresion )

    CTEE            shift and go to state 246


state 228

    (128) getlist -> GET ( . expresion )
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (152) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 152 (empty -> .)
    ID              reduce using rule 152 (empty -> .)
    CTEE            reduce using rule 152 (empty -> .)
    CTEF            reduce using rule 152 (empty -> .)
    CTEBOOL         reduce using rule 152 (empty -> .)
    CTECHAR         reduce using rule 152 (empty -> .)
    CALL            reduce using rule 152 (empty -> .)

    expresion                      shift and go to state 247
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 229

    (129) removelist -> REMOVE ( . expresion )
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (152) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 152 (empty -> .)
    ID              reduce using rule 152 (empty -> .)
    CTEE            reduce using rule 152 (empty -> .)
    CTEF            reduce using rule 152 (empty -> .)
    CTEBOOL         reduce using rule 152 (empty -> .)
    CTECHAR         reduce using rule 152 (empty -> .)
    CALL            reduce using rule 152 (empty -> .)

    expresion                      shift and go to state 248
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 230

    (127) length -> LENGTH ( . )

    )               shift and go to state 249


state 231

    (126) append -> APPEND ( . expresion )
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (152) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 152 (empty -> .)
    ID              reduce using rule 152 (empty -> .)
    CTEE            reduce using rule 152 (empty -> .)
    CTEF            reduce using rule 152 (empty -> .)
    CTEBOOL         reduce using rule 152 (empty -> .)
    CTECHAR         reduce using rule 152 (empty -> .)
    CALL            reduce using rule 152 (empty -> .)

    expresion                      shift and go to state 250
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 232

    (68) o -> AND neur9_1 subexpresion .

    ;               reduce using rule 68 (o -> AND neur9_1 subexpresion .)
    )               reduce using rule 68 (o -> AND neur9_1 subexpresion .)
    ,               reduce using rule 68 (o -> AND neur9_1 subexpresion .)


state 233

    (69) o -> OR neur9_2 subexpresion .

    ;               reduce using rule 69 (o -> OR neur9_2 subexpresion .)
    )               reduce using rule 69 (o -> OR neur9_2 subexpresion .)
    ,               reduce using rule 69 (o -> OR neur9_2 subexpresion .)


state 234

    (140) t -> , . s
    (136) s -> . empty
    (137) s -> . expresion neur25 t
    (152) empty -> .
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT

    )               reduce using rule 152 (empty -> .)
    (               reduce using rule 152 (empty -> .)
    ID              reduce using rule 152 (empty -> .)
    CTEE            reduce using rule 152 (empty -> .)
    CTEF            reduce using rule 152 (empty -> .)
    CTEBOOL         reduce using rule 152 (empty -> .)
    CTECHAR         reduce using rule 152 (empty -> .)
    CALL            reduce using rule 152 (empty -> .)
    NOT             shift and go to state 88

    expresion                      shift and go to state 180
    m                              shift and go to state 87
    s                              shift and go to state 251
    empty                          shift and go to state 182

state 235

    (137) s -> expresion neur25 t .

    )               reduce using rule 137 (s -> expresion neur25 t .)


state 236

    (139) t -> empty .

    )               reduce using rule 139 (t -> empty .)


state 237

    (141) callvoidfunc -> CALL ID neur24 ( s ) neur26 . ;

    ;               shift and go to state 252


state 238

    (133) play -> PLAY ( NOTA , CTEE ) ; .

    ID              reduce using rule 133 (play -> PLAY ( NOTA , CTEE ) ; .)
    IF              reduce using rule 133 (play -> PLAY ( NOTA , CTEE ) ; .)
    FOR             reduce using rule 133 (play -> PLAY ( NOTA , CTEE ) ; .)
    RETURN          reduce using rule 133 (play -> PLAY ( NOTA , CTEE ) ; .)
    WHILE           reduce using rule 133 (play -> PLAY ( NOTA , CTEE ) ; .)
    PLAY            reduce using rule 133 (play -> PLAY ( NOTA , CTEE ) ; .)
    PRINT           reduce using rule 133 (play -> PLAY ( NOTA , CTEE ) ; .)
    CALL            reduce using rule 133 (play -> PLAY ( NOTA , CTEE ) ; .)
    }               reduce using rule 133 (play -> PLAY ( NOTA , CTEE ) ; .)


state 239

    (57) for -> FOR ( asignacion neur18 expresion ; neur19 . asignacion ) neur21 bloque ; neur20
    (46) asignacion -> . ID = neur8 k ;

    ID              shift and go to state 75

    asignacion                     shift and go to state 253

state 240

    (50) asiglista -> NEW LIST ( ) .

    ;               reduce using rule 50 (asiglista -> NEW LIST ( ) .)


state 241

    (51) if -> IF ( expresion ) neur13 bloque l . ;

    ;               shift and go to state 254


state 242

    (54) l -> ELSE . neur14 bloque
    (55) neur14 -> .

    {               reduce using rule 55 (neur14 -> .)

    neur14                         shift and go to state 255

state 243

    (53) l -> empty . neur15
    (56) neur15 -> .

    ;               reduce using rule 56 (neur15 -> .)

    neur15                         shift and go to state 256

state 244

    (130) while -> WHILE ( neur16 expresion ) neur13 bloque ; . neur17
    (132) neur17 -> .

    ID              reduce using rule 132 (neur17 -> .)
    IF              reduce using rule 132 (neur17 -> .)
    FOR             reduce using rule 132 (neur17 -> .)
    RETURN          reduce using rule 132 (neur17 -> .)
    WHILE           reduce using rule 132 (neur17 -> .)
    PLAY            reduce using rule 132 (neur17 -> .)
    PRINT           reduce using rule 132 (neur17 -> .)
    CALL            reduce using rule 132 (neur17 -> .)
    }               reduce using rule 132 (neur17 -> .)

    neur17                         shift and go to state 257

state 245

    (135) callreturnfunc -> CALL ID neur24 ( s ) . neur26 ;
    (143) neur26 -> .

    ;               reduce using rule 143 (neur26 -> .)

    neur26                         shift and go to state 258

state 246

    (125) inlistset -> SET ( CTEE . , expresion )

    ,               shift and go to state 259


state 247

    (128) getlist -> GET ( expresion . )

    )               shift and go to state 260


state 248

    (129) removelist -> REMOVE ( expresion . )

    )               shift and go to state 261


state 249

    (127) length -> LENGTH ( ) .

    *               reduce using rule 127 (length -> LENGTH ( ) .)
    /               reduce using rule 127 (length -> LENGTH ( ) .)
    +               reduce using rule 127 (length -> LENGTH ( ) .)
    -               reduce using rule 127 (length -> LENGTH ( ) .)
    EQ              reduce using rule 127 (length -> LENGTH ( ) .)
    NOTEQ           reduce using rule 127 (length -> LENGTH ( ) .)
    >               reduce using rule 127 (length -> LENGTH ( ) .)
    <               reduce using rule 127 (length -> LENGTH ( ) .)
    MTHANEQ         reduce using rule 127 (length -> LENGTH ( ) .)
    LTHANEQ         reduce using rule 127 (length -> LENGTH ( ) .)
    AND             reduce using rule 127 (length -> LENGTH ( ) .)
    OR              reduce using rule 127 (length -> LENGTH ( ) .)
    ;               reduce using rule 127 (length -> LENGTH ( ) .)
    )               reduce using rule 127 (length -> LENGTH ( ) .)
    ,               reduce using rule 127 (length -> LENGTH ( ) .)


state 250

    (126) append -> APPEND ( expresion . )

    )               shift and go to state 262


state 251

    (140) t -> , s .

    )               reduce using rule 140 (t -> , s .)


state 252

    (141) callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .

    ID              reduce using rule 141 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    IF              reduce using rule 141 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    FOR             reduce using rule 141 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    RETURN          reduce using rule 141 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    WHILE           reduce using rule 141 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    PLAY            reduce using rule 141 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    PRINT           reduce using rule 141 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    CALL            reduce using rule 141 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)
    }               reduce using rule 141 (callvoidfunc -> CALL ID neur24 ( s ) neur26 ; .)


state 253

    (57) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion . ) neur21 bloque ; neur20

    )               shift and go to state 263


state 254

    (51) if -> IF ( expresion ) neur13 bloque l ; .

    ID              reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; .)
    IF              reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; .)
    FOR             reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; .)
    RETURN          reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; .)
    WHILE           reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; .)
    PLAY            reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; .)
    PRINT           reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; .)
    CALL            reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; .)
    }               reduce using rule 51 (if -> IF ( expresion ) neur13 bloque l ; .)


state 255

    (54) l -> ELSE neur14 . bloque
    (35) bloque -> . { i }

    {               shift and go to state 57

    bloque                         shift and go to state 264

state 256

    (53) l -> empty neur15 .

    ;               reduce using rule 53 (l -> empty neur15 .)


state 257

    (130) while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .

    ID              reduce using rule 130 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    IF              reduce using rule 130 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    FOR             reduce using rule 130 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    RETURN          reduce using rule 130 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    WHILE           reduce using rule 130 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    PLAY            reduce using rule 130 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    PRINT           reduce using rule 130 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    CALL            reduce using rule 130 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)
    }               reduce using rule 130 (while -> WHILE ( neur16 expresion ) neur13 bloque ; neur17 .)


state 258

    (135) callreturnfunc -> CALL ID neur24 ( s ) neur26 . ;

    ;               shift and go to state 265


state 259

    (125) inlistset -> SET ( CTEE , . expresion )
    (62) expresion -> . m subexpresion
    (63) m -> . empty
    (64) m -> . NOT
    (152) empty -> .

    NOT             shift and go to state 88
    (               reduce using rule 152 (empty -> .)
    ID              reduce using rule 152 (empty -> .)
    CTEE            reduce using rule 152 (empty -> .)
    CTEF            reduce using rule 152 (empty -> .)
    CTEBOOL         reduce using rule 152 (empty -> .)
    CTECHAR         reduce using rule 152 (empty -> .)
    CALL            reduce using rule 152 (empty -> .)

    expresion                      shift and go to state 266
    m                              shift and go to state 87
    empty                          shift and go to state 89

state 260

    (128) getlist -> GET ( expresion ) .

    *               reduce using rule 128 (getlist -> GET ( expresion ) .)
    /               reduce using rule 128 (getlist -> GET ( expresion ) .)
    +               reduce using rule 128 (getlist -> GET ( expresion ) .)
    -               reduce using rule 128 (getlist -> GET ( expresion ) .)
    EQ              reduce using rule 128 (getlist -> GET ( expresion ) .)
    NOTEQ           reduce using rule 128 (getlist -> GET ( expresion ) .)
    >               reduce using rule 128 (getlist -> GET ( expresion ) .)
    <               reduce using rule 128 (getlist -> GET ( expresion ) .)
    MTHANEQ         reduce using rule 128 (getlist -> GET ( expresion ) .)
    LTHANEQ         reduce using rule 128 (getlist -> GET ( expresion ) .)
    AND             reduce using rule 128 (getlist -> GET ( expresion ) .)
    OR              reduce using rule 128 (getlist -> GET ( expresion ) .)
    ;               reduce using rule 128 (getlist -> GET ( expresion ) .)
    )               reduce using rule 128 (getlist -> GET ( expresion ) .)
    ,               reduce using rule 128 (getlist -> GET ( expresion ) .)


state 261

    (129) removelist -> REMOVE ( expresion ) .

    *               reduce using rule 129 (removelist -> REMOVE ( expresion ) .)
    /               reduce using rule 129 (removelist -> REMOVE ( expresion ) .)
    +               reduce using rule 129 (removelist -> REMOVE ( expresion ) .)
    -               reduce using rule 129 (removelist -> REMOVE ( expresion ) .)
    EQ              reduce using rule 129 (removelist -> REMOVE ( expresion ) .)
    NOTEQ           reduce using rule 129 (removelist -> REMOVE ( expresion ) .)
    >               reduce using rule 129 (removelist -> REMOVE ( expresion ) .)
    <               reduce using rule 129 (removelist -> REMOVE ( expresion ) .)
    MTHANEQ         reduce using rule 129 (removelist -> REMOVE ( expresion ) .)
    LTHANEQ         reduce using rule 129 (removelist -> REMOVE ( expresion ) .)
    AND             reduce using rule 129 (removelist -> REMOVE ( expresion ) .)
    OR              reduce using rule 129 (removelist -> REMOVE ( expresion ) .)
    ;               reduce using rule 129 (removelist -> REMOVE ( expresion ) .)
    )               reduce using rule 129 (removelist -> REMOVE ( expresion ) .)
    ,               reduce using rule 129 (removelist -> REMOVE ( expresion ) .)


state 262

    (126) append -> APPEND ( expresion ) .

    *               reduce using rule 126 (append -> APPEND ( expresion ) .)
    /               reduce using rule 126 (append -> APPEND ( expresion ) .)
    +               reduce using rule 126 (append -> APPEND ( expresion ) .)
    -               reduce using rule 126 (append -> APPEND ( expresion ) .)
    EQ              reduce using rule 126 (append -> APPEND ( expresion ) .)
    NOTEQ           reduce using rule 126 (append -> APPEND ( expresion ) .)
    >               reduce using rule 126 (append -> APPEND ( expresion ) .)
    <               reduce using rule 126 (append -> APPEND ( expresion ) .)
    MTHANEQ         reduce using rule 126 (append -> APPEND ( expresion ) .)
    LTHANEQ         reduce using rule 126 (append -> APPEND ( expresion ) .)
    AND             reduce using rule 126 (append -> APPEND ( expresion ) .)
    OR              reduce using rule 126 (append -> APPEND ( expresion ) .)
    ;               reduce using rule 126 (append -> APPEND ( expresion ) .)
    )               reduce using rule 126 (append -> APPEND ( expresion ) .)
    ,               reduce using rule 126 (append -> APPEND ( expresion ) .)


state 263

    (57) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) . neur21 bloque ; neur20
    (60) neur21 -> .

    {               reduce using rule 60 (neur21 -> .)

    neur21                         shift and go to state 267

state 264

    (54) l -> ELSE neur14 bloque .

    ;               reduce using rule 54 (l -> ELSE neur14 bloque .)


state 265

    (135) callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .

    *               reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    /               reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    +               reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    -               reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    AND             reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    OR              reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    ;               reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    )               reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    ,               reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    EQ              reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    NOTEQ           reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    >               reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    <               reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    MTHANEQ         reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)
    LTHANEQ         reduce using rule 135 (callreturnfunc -> CALL ID neur24 ( s ) neur26 ; .)


state 266

    (125) inlistset -> SET ( CTEE , expresion . )

    )               shift and go to state 268


state 267

    (57) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 . bloque ; neur20
    (35) bloque -> . { i }

    {               shift and go to state 57

    bloque                         shift and go to state 269

state 268

    (125) inlistset -> SET ( CTEE , expresion ) .

    *               reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)
    /               reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)
    +               reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)
    -               reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)
    EQ              reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)
    NOTEQ           reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)
    >               reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)
    <               reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)
    MTHANEQ         reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)
    LTHANEQ         reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)
    AND             reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)
    OR              reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)
    ;               reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)
    )               reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)
    ,               reduce using rule 125 (inlistset -> SET ( CTEE , expresion ) .)


state 269

    (57) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque . ; neur20

    ;               shift and go to state 270


state 270

    (57) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; . neur20
    (61) neur20 -> .

    ID              reduce using rule 61 (neur20 -> .)
    IF              reduce using rule 61 (neur20 -> .)
    FOR             reduce using rule 61 (neur20 -> .)
    RETURN          reduce using rule 61 (neur20 -> .)
    WHILE           reduce using rule 61 (neur20 -> .)
    PLAY            reduce using rule 61 (neur20 -> .)
    PRINT           reduce using rule 61 (neur20 -> .)
    CALL            reduce using rule 61 (neur20 -> .)
    }               reduce using rule 61 (neur20 -> .)

    neur20                         shift and go to state 271

state 271

    (57) for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .

    ID              reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    IF              reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    FOR             reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    RETURN          reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    WHILE           reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    PLAY            reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    PRINT           reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    CALL            reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)
    }               reduce using rule 57 (for -> FOR ( asignacion neur18 expresion ; neur19 asignacion ) neur21 bloque ; neur20 .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 10 resolved using rule (a -> empty)
WARNING: rejected rule (b -> empty) in state 10
WARNING: reduce/reduce conflict in state 28 resolved using rule (c -> empty)
WARNING: rejected rule (d -> empty) in state 28
WARNING: reduce/reduce conflict in state 56 resolved using rule (f -> empty)
WARNING: rejected rule (g -> empty) in state 56
WARNING: reduce/reduce conflict in state 90 resolved using rule (i -> empty)
WARNING: rejected rule (j -> empty) in state 90
WARNING: Rule (b -> empty) is never reduced
WARNING: Rule (d -> empty) is never reduced
WARNING: Rule (g -> empty) is never reduced
WARNING: Rule (j -> empty) is never reduced
